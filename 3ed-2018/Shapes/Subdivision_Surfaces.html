
<!doctype html>
<html lang="en">
<head>

<!-- all praise to https://realfavicongenerator.net -->
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">

  <!-- Required meta tags -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="/fonts.css">
  <link rel="stylesheet" href="/fontawesome-free-5.15.3-web/css/all.css">
  <link rel="stylesheet" href="/bootstrap.min.css">

  <script async src="https://cse.google.com/cse.js?cx=003601324460585362024:4xwpwgaitgd"></script>
  <script src="/react.min.js"></script>
  <script src="/react-dom.min.js"></script>
  <script src="/jeri.min.js"></script>
  <link rel="preload" href="/exr.worker.js" as="script" crossorigin="anonymous">

  <link rel="stylesheet" href="../pbrstyle.css">
  <script src="/3ed-2018/pbrt-display.js"></script>
        

  <title>Subdivision Surfaces</title>
</head>
        
<body>

<nav class="fixed-top-lg-navbar navbar navbar-expand">
  <ul class="nav navbar-nav">
    <a class="navbar-brand" href="../contents.html"><img src="../pbr.jpg" width=25 height=25></a>
    <li class="nav-item"><a class="nav-link" href="../Shapes.html">Shapes</a></li>
    <span class="navbar-text">/</span>
    <li class="nav-item"><a class="nav-link" href="#">Subdivision Surfaces</a></li>
    <span class="navbar-text">&nbsp;&nbsp;</span>
    <li class="nav-item"><a class="nav-link" href="../Shapes/Curves.html">(Previous: Curves)</a></li>
  </ul>

  <ul class="nav navbar-nav ml-auto d-none d-md-block">
        <li class="nav-item"><div class="gcse-search"></div></li>
    </ul>
  <ul class="nav navbar-nav d-block d-md-none">
        <li class="nav-item"><div class="gcse-search"></div></li>
    </ul>
  <ul class="nav navbar-nav d-block">
    <li class="nav-item"><button class="displaymode" onclick="TogglePBRTDisplayMode()"></button></li>
  </ul>
</nav>

<div class="maincontainer">
<div class="container-fluid">

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">

</div>
<div class="col-md-10 col-lg-8">

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#"><i class="fas fa-link "></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span class="anchor" id="sec:loop-subdiv"></span><h2>3.8 Subdivision Surfaces<button data-toggle="tooltip" data-placement="right" class="btn difficult-button"
title="This section contains advanced content and may be skipped on a first reading.">
<i class="fas fa-exclamation-triangle midredtext"></i></button>
</h2><p>



</p>
<p><span class="anchor" id="LoopSubdiv"></span>

</p>
<p>

</p>
<p>The last shape representation that we&rsquo;ll define in this chapter implements
<em>subdivision surfaces</em>, a representation that is particularly well
suited to describing complex smooth shapes.  The subdivision surface for a
particular mesh is defined by repeatedly subdividing the faces of the mesh
into smaller faces and then finding the new vertex locations using weighted
combinations of the old vertex positions.

</p>
<p>For appropriately chosen subdivision rules, this process converges to give
a smooth <em>limit surface</em> as the number of subdivision steps goes to
infinity.  In practice, just a few levels of subdivision typically suffice
to give a good approximation of the limit surface.
Figure&nbsp;<a href="#fig:subdiv-tetra">3.24</a> shows a simple example of a subdivision, where a
tetrahedron has been subdivided zero, one, two, and six times.

</p>
<p></p>
<span class="anchor" id="fig:subdiv-tetra"></span><div class="card outerfigure"><div class="card-body figure"><p>


</p>
<div class="figure-row">
<img src="tetsubdiv.png" style="max-width: 100%; height: auto;" width=1369 height=354>
</div>
<p>

</p>
<figcaption class="caption">Figure 3.24: Subdivision of a Tetrahedron. <span class="legend">  From
left to right, zero, one, two, and six subdivision steps have been used.
(At zero levels, the vertices are just moved to lie on the limit surface.)
As more subdivision is done, the mesh approaches the limit surface,
the smooth surface described by the original mesh.  Notice how the specular
highlights become progressively more accurate and the silhouette edges
appear smoother as more levels of subdivision are performed.</span>
</figcaption><p>


</p>
</div></div><p>


</p>
<p>Figure&nbsp;<a href="#fig:subdiv-killeroo">3.25</a> shows the effect of applying subdivision
to the Killeroo model; on the top is the original control mesh, and below
is the subdivision surface that the control mesh represents.

</p>
<p></p>
<span class="anchor" id="fig:subdiv-killeroo"></span><div class="card outerfigure"><div class="card-body figure"><p>



</p>

<div class="card-img-top" style="display:block; width: 100%; padding-top: 71.731%;  position:relative;">
<div id="Control_mesh11" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0;"></div></div>
<script>
Jeri.renderViewer(document.getElementById('Control_mesh11'), {
  title: 'Control_mesh11', children: [
 { title: 'Control mesh', image: 'killeroo-control.png' },  { title: 'Subdivision mesh', image: 'killeroo-subdivided.png' }]});
</script>
<button data-toggle="tooltip" data-placement="left" class="btn yojeri" title="This image is interactive. Click and drag to pan and use the mouse-wheel to zoom. After clicking on the image to select it, type '?' to see a summary of keyboard controls."><i class="fa fa-snowflake fa-border"></i></button><p>

</p>
<figcaption class="caption">Figure 3.25: Subdivision Applied to the Killeroo
Model. <span class="legend">  (1)&nbsp;The control mesh describes (2)&nbsp;the resulting subdivision surface.
Subdivision is well suited to modeling shapes like this one,
since it&rsquo;s easy to add detail locally by refining the control mesh, and
there are no limitations on the topology of the final surface.  <em>(Model
courtesy of headus/Rezard.)</em></span>
</figcaption><p>


</p>
</div></div><p>


</p>
<p>Although originally developed in the 1970s, subdivision surfaces have seen
widespread use in recent years thanks to some important advantages over
polygonal and spline-based representations of surfaces.  The advantages of
subdivision include the following:

</p>
<p></p>
<ul>
<li> Subdivision surfaces are smooth, as opposed to polygon meshes, which
appear faceted when viewed close up, regardless of how finely they are modeled.

<li> Much of the existing infrastructure in modeling systems can be retargeted to
subdivision.  The classic toolbox of techniques for modeling polygon meshes can
be applied to modeling subdivision control meshes.

<li> Subdivision surfaces are well suited to describing objects with complex
topology, since they start with a control mesh of arbitrary (manifold) topology.
Parametric surface models generally don&rsquo;t handle complex topology well.

<li> Subdivision methods are often generalizations of spline-based surface
representations, so spline surfaces can often just be run through general
subdivision surface renderers.

<li> It is easy to add detail to a localized region of a subdivision
surface simply by adding faces to appropriate parts of the control mesh.
This is much harder with spline representations.
</ul><p>


</p>
<p></p>
<span class="anchor" id="fig:loop-basic"></span><div class="card outerfigure"><div class="card-body figure"><p>



</p>
<div class="figure-row">
  <a href="Subdiv%20refinement.svg" title=""><img src="Subdiv%20refinement.svg" width=487 height=169 style="max-width: 100%;"></a>
</div>
<p>


</p>
<figcaption class="caption">Figure 3.26: Basic Refinement Process for Loop
Subdivision. <span class="legend"> (left) The control mesh before subdivision.
(right)&nbsp;The new mesh after one subdivision step.  Each triangular face of the mesh has
been subdivided into four new faces by splitting each of the edges and
connecting the new vertices with new edges.</span>
</figcaption><p>


</p>
</div></div><p>


</p>
<p>

</p>
<p>Here, we will describe an implementation of <em>Loop subdivision
surfaces</em>.<button style="button" data-toggle="tooltip" data-placement="right" data-html="true" class="btn footnote-button" title="Named after the inventor of the subdivision rules used,
Charles Loop.">
      <sup>&dagger;</sup>
    </button>
		  The Loop subdivision rules are based on triangular faces in
the control mesh; faces with more than three vertices are triangulated at
the start.  At each subdivision step, all faces split into four child faces
(Figure&nbsp;<a href="#fig:loop-basic">3.26</a>).  New vertices are added along all of the
edges of the original mesh, with positions computed using weighted averages
of nearby vertices.  Furthermore, the position of each original vertex is
updated with a weighted average of its position and its new neighbors&rsquo;
positions.  The implementation here uses weights based on improvements to
Loop&rsquo;s method developed by Hoppe et al. (<a href="Further_Reading.html#cite:Hoppe94">1994</a>). We will not include
discussion here about how these weights are derived.  They must be
chosen carefully to ensure that the limit surface actually has
particular desirable smoothness properties, although subtle mathematics is
necessary to prove that they indeed do this.

</p>
<p>Rather than being implemented as a <tt>Shape</tt> in <tt>pbrt</tt>, subdivision
surfaces are generated by a function, <tt>LoopSubdivide()</tt>, that
applies the subdivision rules to a mesh represented by a
collection of vertices and vertex indices and returns a vector of
<a href="../Shapes/Triangle_Meshes.html#Triangle"><tt>Triangle</tt></a>s that represent the final subdivided mesh.

</p>
<p>

</p>
<p></p>
<span class="anchor" id="fragment-LoopSubdivFunctionDefinitions-0"></span><div class="fragmentname">&lt;&lt;LoopSubdiv Function Definitions&gt;&gt;=&nbsp;<a href="#fragment-LoopSubdivFunctionDefinitions-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">std::vector&lt;std::shared_ptr&lt;<a href="../Shapes/Basic_Shape_Interface.html#Shape" class="code">Shape</a>&gt;&gt; <span class="anchor" id="LoopSubdivide"></span>LoopSubdivide(
        const <a href="../Geometry_and_Transformations/Transformations.html#Transform" class="code">Transform</a> *ObjectToWorld, const <a href="../Geometry_and_Transformations/Transformations.html#Transform" class="code">Transform</a> *WorldToObject,
        bool reverseOrientation, int nLevels, int nIndices,
        const int *vertexIndices, int nVertices, const <a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a> *p) {
    std::vector&lt;SDVertex *&gt; <span class="anchor" id="LoopSubdiv::vertices"></span>vertices;
    std::vector&lt;SDFace *&gt; <span class="anchor" id="LoopSubdiv::faces"></span>faces;
    &lt;&lt;<span class="fragmentname"><a href="#fragment-AllocatemonoLoopSubdivverticesandfaces-0">Allocate <tt>LoopSubdiv</tt> vertices and faces</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-373" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-373"><i></i></a><div id="fragbit-373" class="collapse"><div class="fragmentcode">       std::unique_ptr&lt;SDVertex[]&gt; verts(new SDVertex[nVertices]);
       for (int i = 0; i &lt; nVertices; ++i) {
           verts[i] = SDVertex(p[i]);
           <a href="#LoopSubdiv::vertices" class="code">vertices</a>.push_back(&amp;verts[i]);
       }
       int nFaces = nIndices / 3;
       std::unique_ptr&lt;SDFace[]&gt; fs(new SDFace[nFaces]);
       for (int i = 0; i &lt; nFaces; ++i)
           <a href="#LoopSubdiv::faces" class="code">faces</a>.push_back(&amp;fs[i]);</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Setfacetovertexpointers-0">Set face to vertex pointers</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-374" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-374"><i></i></a><div id="fragbit-374" class="collapse"><div class="fragmentcode">       const int *vp = vertexIndices;
       for (int i = 0; i &lt; nFaces; ++i, vp += 3) {
           SDFace *f = faces[i];
           for (int j = 0; j &lt; 3; ++j) {
               SDVertex *<a href="#SDFace::v" class="code">v</a> = vertices[vp[j]];
               f-&gt;<a href="#SDFace::v" class="code">v</a>[j] = <a href="#SDFace::v" class="code">v</a>;
               <a href="#SDFace::v" class="code">v</a>-&gt;<a href="#SDVertex::startFace" class="code">startFace</a> = f;
           }
       }</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Setneighborpointersinmonofaces-0">Set neighbor pointers in <tt>faces</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-375" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-375"><i></i></a><div id="fragbit-375" class="collapse"><div class="fragmentcode">       std::set&lt;SDEdge&gt; edges;
       for (int i = 0; i &lt; nFaces; ++i) {
           SDFace *f = faces[i];
           for (int edgeNum = 0; edgeNum &lt; 3; ++edgeNum) {
               &lt;&lt;<span class="fragmentname"><a href="#fragment-UpdateneighborpointerformonoedgeNum-0">Update neighbor pointer for <tt>edgeNum</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-376" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-376"><i></i></a><div id="fragbit-376" class="collapse"><div class="fragmentcode">                  int v0 = edgeNum, v1 = <a href="#NEXT" class="code">NEXT</a>(edgeNum);
                  SDEdge e(f-&gt;v[v0], f-&gt;v[v1]);
                  if (edges.find(e) == edges.end()) {
                      &lt;&lt;<span class="fragmentname"><a href="#fragment-Handlenewedge-0">Handle new edge</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-377" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-377"><i></i></a><div id="fragbit-377" class="collapse"><div class="fragmentcode">                         e.<a href="#SDEdge::f" class="code">f</a>[0] = <a href="#SDEdge::f" class="code">f</a>;
                         e.<a href="#SDEdge::f0edgeNum" class="code">f0edgeNum</a> = edgeNum;
                         edges.insert(e);</div></div>
                  } else {
                      &lt;&lt;<span class="fragmentname"><a href="#fragment-Handlepreviouslyseenedge-0">Handle previously seen edge</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-378" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-378"><i></i></a><div id="fragbit-378" class="collapse"><div class="fragmentcode">                         e = *edges.find(e);
                         e.<a href="#SDEdge::f" class="code">f</a>[0]-&gt;<a href="#SDEdge::f" class="code">f</a>[e.<a href="#SDEdge::f0edgeNum" class="code">f0edgeNum</a>] = <a href="#SDEdge::f" class="code">f</a>;
                         <a href="#SDEdge::f" class="code">f</a>-&gt;<a href="#SDEdge::f" class="code">f</a>[edgeNum] = e.<a href="#SDEdge::f" class="code">f</a>[0];
                         edges.erase(e);</div></div>
                  }</div></div>
           }
       }</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Finishvertexinitialization-0">Finish vertex initialization</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-379" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-379"><i></i></a><div id="fragbit-379" class="collapse"><div class="fragmentcode">       for (int i = 0; i &lt; nVertices; ++i) {
           SDVertex *v = vertices[i];
           SDFace *f = v-&gt;<a href="#SDVertex::startFace" class="code">startFace</a>;
           do {
               f = f-&gt;<a href="#SDFace::nextFace" class="code">nextFace</a>(v);
           } while (f &amp;&amp; f != v-&gt;<a href="#SDVertex::startFace" class="code">startFace</a>);
           v-&gt;<a href="#SDVertex::boundary" class="code">boundary</a> = (f == nullptr);
           if (!v-&gt;<a href="#SDVertex::boundary" class="code">boundary</a> &amp;&amp; v-&gt;valence() == 6)
               v-&gt;<a href="#SDVertex::regular" class="code">regular</a> = true;
           else if (v-&gt;<a href="#SDVertex::boundary" class="code">boundary</a> &amp;&amp; v-&gt;valence() == 4)
               v-&gt;<a href="#SDVertex::regular" class="code">regular</a> = true;
           else
               v-&gt;<a href="#SDVertex::regular" class="code">regular</a> = false;
       }</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Refinesubdivisionmeshintotriangles-0">Refine subdivision mesh into triangles</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-380" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-380"><i></i></a><div id="fragbit-380" class="collapse"><div class="fragmentcode">       std::vector&lt;SDFace *&gt; f = <a href="#LoopSubdiv::faces" class="code">faces</a>;
       std::vector&lt;SDVertex *&gt; v = <a href="#LoopSubdiv::vertices" class="code">vertices</a>;
       <a href="../Utilities/Memory_Management.html#MemoryArena" class="code">MemoryArena</a> arena;
       for (int i = 0; i &lt; nLevels; ++i) {
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Updatemonofandmonovfornextlevelofsubdivision-0">Update <tt>f</tt> and <tt>v</tt> for next level of subdivision</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-381" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-381"><i></i></a><div id="fragbit-381" class="collapse"><div class="fragmentcode">              std::vector&lt;SDFace *&gt; newFaces;
              std::vector&lt;SDVertex *&gt; newVertices;
              &lt;&lt;<span class="fragmentname"><a href="#fragment-Allocatenextlevelofchildreninmeshtree-0">Allocate next level of children in mesh tree</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-382" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-382"><i></i></a><div id="fragbit-382" class="collapse"><div class="fragmentcode">                 for (SDVertex *vertex : v) {
                     vertex-&gt;child = arena.<a href="../Utilities/Memory_Management.html#MemoryArena::Alloc" class="code">Alloc</a>&lt;SDVertex&gt;();
                     vertex-&gt;child-&gt;<a href="#SDVertex::regular" class="code">regular</a> = vertex-&gt;<a href="#SDVertex::regular" class="code">regular</a>;
                     vertex-&gt;child-&gt;<a href="#SDVertex::boundary" class="code">boundary</a> = vertex-&gt;<a href="#SDVertex::boundary" class="code">boundary</a>;
                     newVertices.push_back(vertex-&gt;child);
                 }
                 for (SDFace *face : f) {
                     for (int k = 0; k &lt; 4; ++k) {
                         face-&gt;<a href="#SDFace::children" class="code">children</a>[k] = arena.<a href="../Utilities/Memory_Management.html#MemoryArena::Alloc" class="code">Alloc</a>&lt;SDFace&gt;();
                         newFaces.push_back(face-&gt;<a href="#SDFace::children" class="code">children</a>[k]);
                     }
                 }</div></div>
              &lt;&lt;<span class="fragmentname"><a href="#fragment-Updatevertexpositionsandcreatenewedgevertices-0">Update vertex positions and create new edge vertices</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-383" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-383"><i></i></a><div id="fragbit-383" class="collapse"><div class="fragmentcode">                 &lt;&lt;<span class="fragmentname"><a href="#fragment-Updatevertexpositionsforevenvertices-0">Update vertex positions for even vertices</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-384" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-384"><i></i></a><div id="fragbit-384" class="collapse"><div class="fragmentcode">                    for (SDVertex *vertex : v) {
                        if (!vertex-&gt;<a href="#SDVertex::boundary" class="code">boundary</a>) {
                            &lt;&lt;<span class="fragmentname"><a href="#fragment-Applyone-ringruleforevenvertex-0">Apply one-ring rule for even vertex</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-385" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-385"><i></i></a><div id="fragbit-385" class="collapse"><div class="fragmentcode">                               if (vertex-&gt;<a href="#SDVertex::regular" class="code">regular</a>)
                                   vertex-&gt;<a href="#SDVertex::child" class="code">child</a>-&gt;<a href="#SDVertex::p" class="code">p</a> = <a href="#LoopSubdiv::weightOneRing" class="code">weightOneRing</a>(vertex, 1.f / 16.f);
                               else
                                   vertex-&gt;<a href="#SDVertex::child" class="code">child</a>-&gt;<a href="#SDVertex::p" class="code">p</a> = <a href="#LoopSubdiv::weightOneRing" class="code">weightOneRing</a>(vertex, <a href="#LoopSubdiv::beta" class="code">beta</a>(vertex-&gt;<a href="#SDVertex::valence" class="code">valence</a>()));</div></div>
                        } else {
                            &lt;&lt;<span class="fragmentname"><a href="#fragment-Applyboundaryruleforevenvertex-0">Apply boundary rule for even vertex</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-386" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-386"><i></i></a><div id="fragbit-386" class="collapse"><div class="fragmentcode">                               vertex-&gt;<a href="#SDVertex::child" class="code">child</a>-&gt;<a href="#SDVertex::p" class="code">p</a> = <a href="#LoopSubdiv::weightBoundary" class="code">weightBoundary</a>(vertex, 1.f / 8.f);</div></div>
                        }
                    }</div></div>
                 &lt;&lt;<span class="fragmentname"><a href="#fragment-Computenewoddedgevertices-0">Compute new odd edge vertices</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-387" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-387"><i></i></a><div id="fragbit-387" class="collapse"><div class="fragmentcode">                    std::map&lt;SDEdge, SDVertex *&gt; edgeVerts;
                    for (SDFace *face : f) {
                        for (int k = 0; k &lt; 3; ++k) {
                            &lt;&lt;<span class="fragmentname"><a href="#fragment-Computeoddvertexonmonokthedge-0">Compute odd vertex on <tt>k</tt>th edge</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-388" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-388"><i></i></a><div id="fragbit-388" class="collapse"><div class="fragmentcode">                               SDEdge edge(face-&gt;<a href="#SDFace::v" class="code">v</a>[k], face-&gt;<a href="#SDFace::v" class="code">v</a>[<a href="#NEXT" class="code">NEXT</a>(k)]);
                               SDVertex *vert = edgeVerts[edge];
                               if (!vert) {
                                   &lt;&lt;<span class="fragmentname"><a href="#fragment-Createandinitializenewoddvertex-0">Create and initialize new odd vertex</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-389" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-389"><i></i></a><div id="fragbit-389" class="collapse"><div class="fragmentcode">                                      vert = arena.<a href="../Utilities/Memory_Management.html#MemoryArena::Alloc" class="code">Alloc</a>&lt;SDVertex&gt;();
                                      newVertices.push_back(vert);
                                      vert-&gt;<a href="#SDVertex::regular" class="code">regular</a> = true;
                                      vert-&gt;<a href="#SDVertex::boundary" class="code">boundary</a> = (face-&gt;<a href="#SDFace::f" class="code">f</a>[k] == nullptr);
                                      vert-&gt;<a href="#SDVertex::startFace" class="code">startFace</a> = face-&gt;<a href="#SDFace::children" class="code">children</a>[3];</div></div>
                                   &lt;&lt;<span class="fragmentname"><a href="#fragment-Applyedgerulestocomputenewvertexposition-0">Apply edge rules to compute new vertex position</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-390" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-390"><i></i></a><div id="fragbit-390" class="collapse"><div class="fragmentcode">                                      if (vert-&gt;<a href="#SDVertex::boundary" class="code">boundary</a>) {
                                          vert-&gt;<a href="#SDVertex::p" class="code">p</a> =  0.5f * edge.<a href="#SDEdge::v" class="code">v</a>[0]-&gt;<a href="#SDVertex::p" class="code">p</a>;
                                          vert-&gt;<a href="#SDVertex::p" class="code">p</a> += 0.5f * edge.<a href="#SDEdge::v" class="code">v</a>[1]-&gt;<a href="#SDVertex::p" class="code">p</a>;
                                      } else {
                                          vert-&gt;<a href="#SDVertex::p" class="code">p</a> =  3.f/8.f * edge.<a href="#SDEdge::v" class="code">v</a>[0]-&gt;<a href="#SDVertex::p" class="code">p</a>;
                                          vert-&gt;<a href="#SDVertex::p" class="code">p</a> += 3.f/8.f * edge.<a href="#SDEdge::v" class="code">v</a>[1]-&gt;<a href="#SDVertex::p" class="code">p</a>;
                                          vert-&gt;<a href="#SDVertex::p" class="code">p</a> += 1.f/8.f * face-&gt;<a href="#SDFace::otherVert" class="code">otherVert</a>(edge.<a href="#SDEdge::v" class="code">v</a>[0], edge.<a href="#SDEdge::v" class="code">v</a>[1])-&gt;<a href="#SDVertex::p" class="code">p</a>;
                                          vert-&gt;<a href="#SDVertex::p" class="code">p</a> += 1.f/8.f *
                                              face-&gt;f[k]-&gt;<a href="#SDFace::otherVert" class="code">otherVert</a>(edge.<a href="#SDEdge::v" class="code">v</a>[0], edge.<a href="#SDEdge::v" class="code">v</a>[1])-&gt;<a href="#SDVertex::p" class="code">p</a>;
                                      }</div></div>
                                   edgeVerts[edge] = vert;
                               }</div></div>
                        }
                    }</div></div></div></div>
              &lt;&lt;<span class="fragmentname"><a href="#fragment-Updatenewmeshtopology-0">Update new mesh topology</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-391" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-391"><i></i></a><div id="fragbit-391" class="collapse"><div class="fragmentcode">                 &lt;&lt;<span class="fragmentname"><a href="#fragment-Updateevenvertexfacepointers-0">Update even vertex face pointers</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-392" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-392"><i></i></a><div id="fragbit-392" class="collapse"><div class="fragmentcode">                    for (SDVertex *vertex : v) {
                        int vertNum = vertex-&gt;<a href="#SDVertex::startFace" class="code">startFace</a>-&gt;<a href="#SDFace::vnum" class="code">vnum</a>(vertex);
                        vertex-&gt;child-&gt;<a href="#SDVertex::startFace" class="code">startFace</a> = 
                            vertex-&gt;<a href="#SDVertex::startFace" class="code">startFace</a>-&gt;<a href="#SDFace::children" class="code">children</a>[vertNum];
                    }</div></div>
                 &lt;&lt;<span class="fragmentname"><a href="#fragment-Updatefaceneighborpointers-0">Update face neighbor pointers</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-393" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-393"><i></i></a><div id="fragbit-393" class="collapse"><div class="fragmentcode">                    for (SDFace *face : f) {
                        for (int j = 0; j &lt; 3; ++j) {
                            &lt;&lt;<span class="fragmentname"><a href="#fragment-Updatechildrenmonofpointersforsiblings-0">Update children <tt>f</tt> pointers for siblings</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-394" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-394"><i></i></a><div id="fragbit-394" class="collapse"><div class="fragmentcode">                               face-&gt;<a href="#SDFace::children" class="code">children</a>[3]-&gt;<a href="#SDFace::f" class="code">f</a>[j] = face-&gt;<a href="#SDFace::children" class="code">children</a>[<a href="#NEXT" class="code">NEXT</a>(j)];
                               face-&gt;<a href="#SDFace::children" class="code">children</a>[j]-&gt;<a href="#SDFace::f" class="code">f</a>[<a href="#NEXT" class="code">NEXT</a>(j)] = face-&gt;<a href="#SDFace::children" class="code">children</a>[3];</div></div>
                            &lt;&lt;<span class="fragmentname"><a href="#fragment-Updatechildrenmonofpointersforneighborchildren-0">Update children <tt>f</tt> pointers for neighbor children</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-395" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-395"><i></i></a><div id="fragbit-395" class="collapse"><div class="fragmentcode">                               SDFace *f2 = face-&gt;<a href="#SDFace::f" class="code">f</a>[j];
                               face-&gt;<a href="#SDFace::children" class="code">children</a>[j]-&gt;<a href="#SDFace::f" class="code">f</a>[j] =
                                   f2 ? f2-&gt;<a href="#SDFace::children" class="code">children</a>[f2-&gt;<a href="#SDFace::vnum" class="code">vnum</a>(face-&gt;v[j])] : nullptr;
                               f2 = face-&gt;<a href="#SDFace::f" class="code">f</a>[<a href="#PREV" class="code">PREV</a>(j)];
                               face-&gt;<a href="#SDFace::children" class="code">children</a>[j]-&gt;<a href="#SDFace::f" class="code">f</a>[<a href="#PREV" class="code">PREV</a>(j)] = 
                                   f2 ? f2-&gt;<a href="#SDFace::children" class="code">children</a>[f2-&gt;<a href="#SDFace::vnum" class="code">vnum</a>(face-&gt;v[j])] : nullptr;</div></div>
                        }
                    }</div></div>
                 &lt;&lt;<span class="fragmentname"><a href="#fragment-Updatefacevertexpointers-0">Update face vertex pointers</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-396" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-396"><i></i></a><div id="fragbit-396" class="collapse"><div class="fragmentcode">                    for (SDFace *face : f) {
                        for (int j = 0; j &lt; 3; ++j) {
                            &lt;&lt;<span class="fragmentname"><a href="#fragment-Updatechildvertexpointertonewevenvertex-0">Update child vertex pointer to new even vertex</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-397" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-397"><i></i></a><div id="fragbit-397" class="collapse"><div class="fragmentcode">                               face-&gt;<a href="#SDFace::children" class="code">children</a>[j]-&gt;<a href="#SDFace::v" class="code">v</a>[j] = face-&gt;<a href="#SDFace::v" class="code">v</a>[j]-&gt;<a href="#SDVertex::child" class="code">child</a>;</div></div>
                            &lt;&lt;<span class="fragmentname"><a href="#fragment-Updatechildvertexpointertonewoddvertex-0">Update child vertex pointer to new odd vertex</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-398" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-398"><i></i></a><div id="fragbit-398" class="collapse"><div class="fragmentcode">                               SDVertex *vert = edgeVerts[SDEdge(face-&gt;<a href="#SDFace::v" class="code">v</a>[j], face-&gt;<a href="#SDFace::v" class="code">v</a>[<a href="#NEXT" class="code">NEXT</a>(j)])];
                               face-&gt;<a href="#SDFace::children" class="code">children</a>[j]-&gt;<a href="#SDFace::v" class="code">v</a>[<a href="#NEXT" class="code">NEXT</a>(j)] = vert;
                               face-&gt;<a href="#SDFace::children" class="code">children</a>[<a href="#NEXT" class="code">NEXT</a>(j)]-&gt;<a href="#SDFace::v" class="code">v</a>[j] = vert;
                               face-&gt;<a href="#SDFace::children" class="code">children</a>[3]-&gt;<a href="#SDFace::v" class="code">v</a>[j] = vert;</div></div>
                        }
                    }</div></div></div></div>
              &lt;&lt;<span class="fragmentname"><a href="#fragment-Preparefornextlevelofsubdivision-0">Prepare for next level of subdivision</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-399" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-399"><i></i></a><div id="fragbit-399" class="collapse"><div class="fragmentcode">                 f = newFaces;
                 v = newVertices;</div></div></div></div>
       }
       &lt;&lt;<span class="fragmentname"><a href="#fragment-Pushverticestolimitsurface-0">Push vertices to limit surface</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-400" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-400"><i></i></a><div id="fragbit-400" class="collapse"><div class="fragmentcode">          std::unique_ptr&lt;<a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a>[]&gt; pLimit(new <a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a>[v.size()]);
          for (size_t i = 0; i &lt; v.size(); ++i) {
              if (v[i]-&gt;<a href="#SDVertex::boundary" class="code">boundary</a>)
                  pLimit[i] =  <a href="#LoopSubdiv::weightBoundary" class="code">weightBoundary</a>(v[i], 1.f / 5.f);
              else
                  pLimit[i] =  <a href="#LoopSubdiv::weightOneRing" class="code">weightOneRing</a>(v[i], <a href="#LoopSubdiv::loopGamma" class="code">loopGamma</a>(v[i]-&gt;<a href="#SDVertex::valence" class="code">valence</a>()));
          }
          for (size_t i = 0; i &lt; v.size(); ++i)
              v[i]-&gt;p = pLimit[i];</div></div>
       &lt;&lt;<span class="fragmentname"><a href="#fragment-Computevertextangentsonlimitsurface-0">Compute vertex tangents on limit surface</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-401" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-401"><i></i></a><div id="fragbit-401" class="collapse"><div class="fragmentcode">          std::vector&lt;<a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a>&gt; Ns;
          Ns.reserve(v.size());
          std::vector&lt;<a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a>&gt; pRing(16, <a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a>());
          for (SDVertex *vertex : v) {
              <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> S(0,0,0), T(0,0,0);
              int <a href="#SDVertex::valence" class="code">valence</a> = vertex-&gt;<a href="#SDVertex::valence" class="code">valence</a>();
              if (<a href="#SDVertex::valence" class="code">valence</a> &gt; (int)pRing.size())
                  pRing.resize(<a href="#SDVertex::valence" class="code">valence</a>);
              vertex-&gt;<a href="#SDVertex::oneRing" class="code">oneRing</a>(&amp;pRing[0]);
              if (!vertex-&gt;<a href="#SDVertex::boundary" class="code">boundary</a>) {
                  &lt;&lt;<span class="fragmentname"><a href="#fragment-Computetangentsofinteriorface-0">Compute tangents of interior face</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-402" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-402"><i></i></a><div id="fragbit-402" class="collapse"><div class="fragmentcode">                     for (int j = 0; j &lt; valence; ++j) {
                         S += std::cos(2 * <a href="../Utilities/Main_Include_File.html#Pi" class="code">Pi</a> * j / valence) * <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a>(pRing[j]);
                         T += std::sin(2 * <a href="../Utilities/Main_Include_File.html#Pi" class="code">Pi</a> * j / valence) * <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a>(pRing[j]);
                     }</div></div>
              } else {
                  &lt;&lt;<span class="fragmentname"><a href="#fragment-Computetangentsofboundaryface-0">Compute tangents of boundary face</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-403" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-403"><i></i></a><div id="fragbit-403" class="collapse"><div class="fragmentcode">                     S = pRing[valence - 1] - pRing[0];
                     if (valence == 2)
                         T = <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a>(pRing[0] + pRing[1] - 2 * vertex-&gt;p);
                     else if (valence == 3)
                         T = pRing[1] - vertex-&gt;p;
                     else if (valence == 4) // regular
                         T = <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a>(-1 * pRing[0] +  2 * pRing[1] + 2 * pRing[2] + 
                                      -1 * pRing[3] + -2 * vertex-&gt;p);
                     else {
                         Float theta = <a href="../Utilities/Main_Include_File.html#Pi" class="code">Pi</a> / float(valence - 1);
                         T = <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a>(std::sin(theta) * (pRing[0] + pRing[valence - 1]));
                         for (int k = 1; k &lt; valence - 1; ++k) {
                             Float wt = (2 * std::cos(theta) - 2) * std::sin((k) * theta);
                             T += <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a>(wt * pRing[k]);
                         }
                         T = -T;
                     }</div></div>
              }
              Ns.push_back(<a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a>(<a href="../Geometry_and_Transformations/Vectors.html#Cross" class="code">Cross</a>(S, T)));
          }</div></div>
       &lt;&lt;<span class="fragmentname">Create triangle mesh from subdivision mesh</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-404" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-404"><i></i></a><div id="fragbit-404" class="collapse"><div class="fragmentcode">          {
          size_t ntris = f.size();
          std::unique_ptr&lt;int[]&gt; verts(new int[3*ntris]);
          int *vp = verts.get();
          size_t totVerts = v.size();
          std::map&lt;SDVertex *, int&gt; usedVerts;
          for (size_t i = 0; i &lt; totVerts; ++i)
              usedVerts[v[i]] = i;
          for (size_t i = 0; i &lt; ntris; ++i) {
              for (int j = 0; j &lt; 3; ++j) {
                  *vp = usedVerts[f[i]-&gt;v[j]];
                  ++vp;
              }
          }
          return CreateTriangleMesh(ObjectToWorld, WorldToObject, reverseOrientation, ntris, verts.get(),
              totVerts, pLimit.get(), nullptr, &amp;Ns[0], nullptr, nullptr);
          }</div></div></div></div>
}</div><p>


</p>
<p>

</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#MeshRepresentation"><i class="fas fa-link h3h4marginlink"></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span id="MeshRepresentation"></span><h3>3.8.1  Mesh Representation</h3><p>


</p>
<p>
    
The parameters to <tt>LoopSubdivide()</tt> specify a triangle mesh in exactly
the same format used in the <a href="../Shapes/Triangle_Meshes.html#TriangleMesh"><tt>TriangleMesh</tt></a> constructor
(Section&nbsp;<a href="../Shapes/Triangle_Meshes.html#sec:triangle-mesh">3.6</a>): each face is described by three integer
vertex indices, giving offsets into the vertex array <tt>p</tt> for the
face&rsquo;s three vertices.  We will need to process this data to determine
which faces are adjacent to each other, which faces are adjacent to which
vertices, and so on, in order to implement the subdivision algorithm.

</p>
<p>We will shortly define <a href="#SDVertex"><tt>SDVertex</tt></a> and <a href="#SDFace"><tt>SDFace</tt></a> structures, which
hold data for vertices and faces in the subdivision mesh.
<tt>LoopSubdivide()</tt> starts by allocating one instance of the
<a href="#SDVertex"><tt>SDVertex</tt></a> class for each vertex in the mesh and an <a href="#SDFace"><tt>SDFace</tt></a> for
each face. For now, these are mostly uninitialized.

</p>
<p></p>
<span class="anchor" id="fragment-AllocatemonoLoopSubdivverticesandfaces-0"></span><div class="fragmentname">&lt;&lt;Allocate <tt>LoopSubdiv</tt> vertices and faces&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">std::unique_ptr&lt;SDVertex[]&gt; verts(new SDVertex[nVertices]);
for (int i = 0; i &lt; nVertices; ++i) {
    verts[i] = SDVertex(p[i]);
    <a href="#LoopSubdiv::vertices" class="code">vertices</a>.push_back(&amp;verts[i]);
}
int nFaces = nIndices / 3;
std::unique_ptr&lt;SDFace[]&gt; fs(new SDFace[nFaces]);
for (int i = 0; i &lt; nFaces; ++i)
    <a href="#LoopSubdiv::faces" class="code">faces</a>.push_back(&amp;fs[i]);</div><p>


</p>
<p>The Loop subdivision scheme, like most other subdivision schemes, assumes that
the control mesh is <em>manifold</em>&mdash;no more than two faces share any
given edge.  Such a mesh may be closed or open: a <em>closed mesh</em> has no
boundary, and all faces have adjacent faces across each of their edges.  An
<em>open mesh</em> has some faces that do not have all three neighbors.  The
implementation here supports both closed and open meshes.

</p>
<p>In the interior of a triangle mesh, most vertices are adjacent to six faces
and have six neighbor vertices directly connected to them with edges.  On
the boundaries of an open mesh, most vertices are adjacent to three faces
and four vertices.  The number of vertices directly adjacent to a vertex is
called the vertex&rsquo;s <em>valence</em>.  Interior vertices with valence other
than six, or boundary vertices with valence other than four, are called
<em>extraordinary vertices</em>; otherwise, they are called
<em>regular</em>.<button style="button" data-toggle="tooltip" data-placement="right" data-html="true" class="btn footnote-button" title="These terms are commonly used in the modeling
literature, although <em>irregular</em> versus <em>regular</em> or
<em>extraordinary</em> versus <em>ordinary</em> might
be more intuitive.">
      <sup>&dagger;</sup>
    </button>
		  Loop subdivision surfaces
are smooth everywhere except at their extraordinary vertices.

</p>
<p>Each <a href="#SDVertex"><tt>SDVertex</tt></a> stores its position <tt>p</tt>, a Boolean that indicates
whether it is a regular or extraordinary vertex, and a Boolean that records
if it lies on the boundary of the mesh.  It also holds a pointer to an
arbitrary  face adjacent to it; this pointer gives a starting point for
 finding all of the adjacent faces.  Finally, there is a pointer
to store the corresponding <tt>SDVertex</tt> for the next level of subdivision, if any.

</p>
<p></p>
<span class="anchor" id="fragment-LoopSubdivLocalStructures-0"></span><div class="fragmentname">&lt;&lt;LoopSubdiv Local Structures&gt;&gt;=&nbsp;<a href="#fragment-LoopSubdivLocalStructures-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">struct <span class="anchor" id="SDVertex"></span>SDVertex {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-SDVertexConstructor-0">SDVertex Constructor</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-405" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-405"><i></i></a><div id="fragbit-405" class="collapse"><div class="fragmentcode">       SDVertex(const <a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a> &amp;p = <a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a>(0, 0, 0)) : p(p) { }</div></div>
    &lt;&lt;<span class="fragmentname">SDVertex Methods</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-406" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-406"><i></i></a><div id="fragbit-406" class="collapse"><div class="fragmentcode">       int valence();
       void oneRing(<a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a> *p);</div></div>
    <a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a> <span class="anchor" id="SDVertex::p"></span>p;
    SDFace *<span class="anchor" id="SDVertex::startFace"></span>startFace = nullptr;
    SDVertex *<span class="anchor" id="SDVertex::child"></span>child = nullptr;
    bool <span class="anchor" id="SDVertex::regular"></span>regular = false, <span class="anchor" id="SDVertex::boundary"></span>boundary = false;
};</div><p>


</p>
<p></p>
<span class="anchor" id="fragment-SDVertexConstructor-0"></span><div class="fragmentname">&lt;&lt;SDVertex Constructor&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">SDVertex(const <a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a> &amp;p = <a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a>(0, 0, 0)) : p(p) { }</div><p>


</p>
<p>The <tt>SDFace</tt> structure is where most of the topological
information about the mesh is maintained.  Because all faces are
triangular, faces
always store pointers to their three vertices and 
pointers to the adjacent faces across its three edges.  The
corresponding
face neighbor pointers will be <tt>nullptr</tt> if the face is on the boundary
of an open mesh.

</p>
<p>The face neighbor pointers are indexed such that if we label the edge from
<tt>v[i]</tt> to <tt>v[(i+1)%3]</tt> as the <tt>i</tt>th edge, then the neighbor face across
that edge is stored in <tt>f[i]</tt> (Figure&nbsp;<a href="#fig:sd-face">3.27</a>).  This
labeling convention is important to keep in mind. Later when we are
updating the topology of a newly subdivided mesh, we will make extensive
use of it to navigate around the mesh.  Similarly to the <tt>SDVertex</tt>
class, the <tt>SDFace</tt> also stores pointers to child faces at the next level of
subdivision.

</p>
<p>
</p>
<span class="anchor" id="fig:sd-face"></span><div class="card outerfigure"><div class="card-body figure"><p>



</p>
<div class="figure-row">
  <a href="Subdiv%20vert%20face%20pointers.svg" title=""><img src="Subdiv%20vert%20face%20pointers.svg" width=265 height=259 style="max-width: 100%;"></a>
</div>
<p>


</p>
<figcaption class="caption">Figure 3.27: <span class="legend"> Each triangular face stores three pointers to
<tt>SDVertex</tt> objects <tt>v[i]</tt> and three pointers to neighboring faces
<tt>f[i]</tt>.  Neighboring faces are indexed using the convention that the <tt>i</tt>th
edge is the edge from <tt>v[i]</tt> to <tt>v[(i+1)%3]</tt>, and the neighbor
across the <tt>i</tt>th edge is in <tt>f[i]</tt>.</span>
</figcaption><p>


</p>
</div></div><p>


</p>
<p></p>
<span class="anchor" id="fragment-LoopSubdivLocalStructures-1"></span><div class="fragmentname">&lt;&lt;LoopSubdiv Local Structures&gt;&gt;+=&nbsp;<a href="#fragment-LoopSubdivLocalStructures-0"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-LoopSubdivLocalStructures-2"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">struct <span class="anchor" id="SDFace"></span>SDFace {
    &lt;&lt;<span class="fragmentname">SDFace Constructor</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-407" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-407"><i></i></a><div id="fragbit-407" class="collapse"><div class="fragmentcode">       SDFace() {
           for (int i = 0; i &lt; 3; ++i) {
               v[i] = nullptr;
               f[i] = nullptr;
           }
           for (int i = 0; i &lt; 4; ++i)
               children[i] = nullptr;
       }</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-SDFaceMethods-0">SDFace Methods</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-408" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-408"><i></i></a><div id="fragbit-408" class="collapse"><div class="fragmentcode">       int <a href="#SDFace::vnum" class="code">vnum</a>(SDVertex *vert) const {
           for (int i = 0; i &lt; 3; ++i)
               if (<a href="#SDFace::v" class="code">v</a>[i] == vert) return i;
           <a href="../Utilities/Communicating_with_the_User.html#Severe" class="code">Severe</a>("Basic logic error in SDFace::<a href="#SDFace::vnum" class="code">vnum</a>()");
           return -1;
       }
       SDFace *nextFace(SDVertex *vert) {
           return <a href="#SDFace::f" class="code">f</a>[<a href="#SDFace::vnum" class="code">vnum</a>(vert)];
       }
       SDFace *prevFace(SDVertex *vert) {
           return <a href="#SDFace::f" class="code">f</a>[<a href="#PREV" class="code">PREV</a>(<a href="#SDFace::vnum" class="code">vnum</a>(vert))];
       }
       SDVertex *nextVert(SDVertex *vert) {
           return <a href="#SDFace::v" class="code">v</a>[<a href="#NEXT" class="code">NEXT</a>(<a href="#SDFace::vnum" class="code">vnum</a>(vert))];
       }
       SDVertex *prevVert(SDVertex *vert) {
           return <a href="#SDFace::v" class="code">v</a>[<a href="#PREV" class="code">PREV</a>(<a href="#SDFace::vnum" class="code">vnum</a>(vert))];
       }
       SDVertex *otherVert(SDVertex *v0, SDVertex *v1) {
           for (int i = 0; i &lt; 3; ++i)
               if (<a href="#SDFace::v" class="code">v</a>[i] != v0 &amp;&amp; <a href="#SDFace::v" class="code">v</a>[i] != v1)
                   return <a href="#SDFace::v" class="code">v</a>[i];
           <a href="../Utilities/Communicating_with_the_User.html#Severe" class="code">Severe</a>("Basic logic error in SDVertex::otherVert()");
           return nullptr;
       }</div></div>
    SDVertex *<span class="anchor" id="SDFace::v"></span>v[3];
    SDFace *<span class="anchor" id="SDFace::f"></span>f[3];
    SDFace *<span class="anchor" id="SDFace::children"></span>children[4];
};</div><p>


</p>
<p>The <tt>SDFace</tt> constructor is straightforward&mdash;it simply sets these
various pointers to <tt>nullptr</tt>&mdash;so it is not shown here.

</p>
<p>

</p>
<p>
In order to simplify navigation of the <a href="#SDFace"><tt>SDFace</tt></a> data structure, we&rsquo;ll
provide macros that make it easy to determine the vertex and face indices
before or after a particular index.  These macros add appropriate offsets and
compute the result modulo three to handle cycling around.

</p>
<p></p>
<span class="anchor" id="fragment-LoopSubdivMacros-0"></span><div class="fragmentname">&lt;&lt;LoopSubdiv Macros&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">#define <span class="anchor" id="NEXT"></span>NEXT(i) (((i) + 1) % 3)
#define <span class="anchor" id="PREV"></span>PREV(i) (((i) + 2) % 3)</div><p>


</p>
<p>In addition to requiring a manifold mesh, the subdivision code expects
that the control mesh specified by the user will be <em>consistently
ordered</em>&mdash;each <em>directed edge</em> in the mesh can be present only once.  An
edge that is shared by two faces should be specified in a different direction
by each face.  Consider two vertices, <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.282ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 982.4 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">normal v 0</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-76" d="M508 400c-66 -1 -83 -44 -92 -67l-131 -325c-4 -10 -8 -19 -21 -19s-15 5 -21 19l-144 355c-13 31 -17 37 -80 37v31c30 -2 70 -3 97 -3l109 3v-31c-18 0 -57 0 -57 -26c0 0 0 -4 6 -17l112 -279l102 255c4 11 6 15 6 24c0 19 -11 42 -48 43v31l87 -3c23 0 52 1 75 3v-31 Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-30" d="M460 320c0 -79 -5 -157 -37 -226c-44 -95 -120 -116 -174 -116c-49 0 -122 20 -165 101c-41 76 -45 166 -45 241c0 80 5 158 37 227c41 93 114 119 174 119c42 0 124 -16 170 -112c35 -74 40 -154 40 -234zM377 332c0 63 0 139 -10 195c-19 99 -85 117 -118 117 c-25 0 -100 -9 -119 -128c-8 -54 -8 -120 -8 -184c0 -59 0 -151 11 -211c18 -96 77 -121 116 -121c45 0 102 30 117 125c11 64 11 132 11 207Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-76" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-30" x="747" y="-213"></use>
</g>
</svg> and <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.282ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 982.4 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">normal v 1</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-76" d="M508 400c-66 -1 -83 -44 -92 -67l-131 -325c-4 -10 -8 -19 -21 -19s-15 5 -21 19l-144 355c-13 31 -17 37 -80 37v31c30 -2 70 -3 97 -3l109 3v-31c-18 0 -57 0 -57 -26c0 0 0 -4 6 -17l112 -279l102 255c4 11 6 15 6 24c0 19 -11 42 -48 43v31l87 -3c23 0 52 1 75 3v-31 Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-76" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-31" x="747" y="-213"></use>
</g>
</svg>, with an edge between
them.  We expect that one of the triangular faces that has this edge will
specify its three vertices so that <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.282ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 982.4 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">normal v 0</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-76" d="M508 400c-66 -1 -83 -44 -92 -67l-131 -325c-4 -10 -8 -19 -21 -19s-15 5 -21 19l-144 355c-13 31 -17 37 -80 37v31c30 -2 70 -3 97 -3l109 3v-31c-18 0 -57 0 -57 -26c0 0 0 -4 6 -17l112 -279l102 255c4 11 6 15 6 24c0 19 -11 42 -48 43v31l87 -3c23 0 52 1 75 3v-31 Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-30" d="M460 320c0 -79 -5 -157 -37 -226c-44 -95 -120 -116 -174 -116c-49 0 -122 20 -165 101c-41 76 -45 166 -45 241c0 80 5 158 37 227c41 93 114 119 174 119c42 0 124 -16 170 -112c35 -74 40 -154 40 -234zM377 332c0 63 0 139 -10 195c-19 99 -85 117 -118 117 c-25 0 -100 -9 -119 -128c-8 -54 -8 -120 -8 -184c0 -59 0 -151 11 -211c18 -96 77 -121 116 -121c45 0 102 30 117 125c11 64 11 132 11 207Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-76" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-30" x="747" y="-213"></use>
</g>
</svg> is before <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.282ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 982.4 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">normal v 1</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-76" d="M508 400c-66 -1 -83 -44 -92 -67l-131 -325c-4 -10 -8 -19 -21 -19s-15 5 -21 19l-144 355c-13 31 -17 37 -80 37v31c30 -2 70 -3 97 -3l109 3v-31c-18 0 -57 0 -57 -26c0 0 0 -4 6 -17l112 -279l102 255c4 11 6 15 6 24c0 19 -11 42 -48 43v31l87 -3c23 0 52 1 75 3v-31 Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-76" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-31" x="747" y="-213"></use>
</g>
</svg>,
and that the other 
face will specify its vertices so that <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.282ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 982.4 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">normal v 1</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-76" d="M508 400c-66 -1 -83 -44 -92 -67l-131 -325c-4 -10 -8 -19 -21 -19s-15 5 -21 19l-144 355c-13 31 -17 37 -80 37v31c30 -2 70 -3 97 -3l109 3v-31c-18 0 -57 0 -57 -26c0 0 0 -4 6 -17l112 -279l102 255c4 11 6 15 6 24c0 19 -11 42 -48 43v31l87 -3c23 0 52 1 75 3v-31 Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-76" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-31" x="747" y="-213"></use>
</g>
</svg> is before <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.282ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 982.4 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">normal v 0</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-76" d="M508 400c-66 -1 -83 -44 -92 -67l-131 -325c-4 -10 -8 -19 -21 -19s-15 5 -21 19l-144 355c-13 31 -17 37 -80 37v31c30 -2 70 -3 97 -3l109 3v-31c-18 0 -57 0 -57 -26c0 0 0 -4 6 -17l112 -279l102 255c4 11 6 15 6 24c0 19 -11 42 -48 43v31l87 -3c23 0 52 1 75 3v-31 Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-30" d="M460 320c0 -79 -5 -157 -37 -226c-44 -95 -120 -116 -174 -116c-49 0 -122 20 -165 101c-41 76 -45 166 -45 241c0 80 5 158 37 227c41 93 114 119 174 119c42 0 124 -16 170 -112c35 -74 40 -154 40 -234zM377 332c0 63 0 139 -10 195c-19 99 -85 117 -118 117 c-25 0 -100 -9 -119 -128c-8 -54 -8 -120 -8 -184c0 -59 0 -151 11 -211c18 -96 77 -121 116 -121c45 0 102 30 117 125c11 64 11 132 11 207Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-76" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-30" x="747" y="-213"></use>
</g>
</svg>
(Figure&nbsp;<a href="#fig:face-ordering">3.28</a>).  A M&ouml;bius strip is one example of a surface
that cannot be consistently ordered, but such surfaces come up rarely in
rendering so in practice this restriction is not a problem.  Poorly
formed mesh data from other programs that don&rsquo;t create consistently ordered
meshes can be troublesome, however.

</p>
<p></p>
<span class="anchor" id="fig:face-ordering"></span><div class="card outerfigure"><div class="card-body figure"><p>



</p>
<div class="figure-row">
  <a href="Subdiv%20face%20orientation.svg" title=""><img src="Subdiv%20face%20orientation.svg" width=341 height=255 style="max-width: 100%;"></a>
</div>
<p>


</p>
<figcaption class="caption">Figure 3.28: <span class="legend"> All of the faces in the input mesh must
be specified so that each shared edge is given no more than once in each 
direction.  Here, the edge from <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.282ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 982.4 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">normal v 0</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-76" d="M508 400c-66 -1 -83 -44 -92 -67l-131 -325c-4 -10 -8 -19 -21 -19s-15 5 -21 19l-144 355c-13 31 -17 37 -80 37v31c30 -2 70 -3 97 -3l109 3v-31c-18 0 -57 0 -57 -26c0 0 0 -4 6 -17l112 -279l102 255c4 11 6 15 6 24c0 19 -11 42 -48 43v31l87 -3c23 0 52 1 75 3v-31 Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-30" d="M460 320c0 -79 -5 -157 -37 -226c-44 -95 -120 -116 -174 -116c-49 0 -122 20 -165 101c-41 76 -45 166 -45 241c0 80 5 158 37 227c41 93 114 119 174 119c42 0 124 -16 170 -112c35 -74 40 -154 40 -234zM377 332c0 63 0 139 -10 195c-19 99 -85 117 -118 117 c-25 0 -100 -9 -119 -128c-8 -54 -8 -120 -8 -184c0 -59 0 -151 11 -211c18 -96 77 -121 116 -121c45 0 102 30 117 125c11 64 11 132 11 207Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-76" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-30" x="747" y="-213"></use>
</g>
</svg> to <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.282ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 982.4 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">normal v 1</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-76" d="M508 400c-66 -1 -83 -44 -92 -67l-131 -325c-4 -10 -8 -19 -21 -19s-15 5 -21 19l-144 355c-13 31 -17 37 -80 37v31c30 -2 70 -3 97 -3l109 3v-31c-18 0 -57 0 -57 -26c0 0 0 -4 6 -17l112 -279l102 255c4 11 6 15 6 24c0 19 -11 42 -48 43v31l87 -3c23 0 52 1 75 3v-31 Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-76" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-31" x="747" y="-213"></use>
</g>
</svg>
is traversed from <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.282ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 982.4 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">normal v 0</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-76" d="M508 400c-66 -1 -83 -44 -92 -67l-131 -325c-4 -10 -8 -19 -21 -19s-15 5 -21 19l-144 355c-13 31 -17 37 -80 37v31c30 -2 70 -3 97 -3l109 3v-31c-18 0 -57 0 -57 -26c0 0 0 -4 6 -17l112 -279l102 255c4 11 6 15 6 24c0 19 -11 42 -48 43v31l87 -3c23 0 52 1 75 3v-31 Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-30" d="M460 320c0 -79 -5 -157 -37 -226c-44 -95 -120 -116 -174 -116c-49 0 -122 20 -165 101c-41 76 -45 166 -45 241c0 80 5 158 37 227c41 93 114 119 174 119c42 0 124 -16 170 -112c35 -74 40 -154 40 -234zM377 332c0 63 0 139 -10 195c-19 99 -85 117 -118 117 c-25 0 -100 -9 -119 -128c-8 -54 -8 -120 -8 -184c0 -59 0 -151 11 -211c18 -96 77 -121 116 -121c45 0 102 30 117 125c11 64 11 132 11 207Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-76" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-30" x="747" y="-213"></use>
</g>
</svg> to <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.282ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 982.4 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">normal v 1</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-76" d="M508 400c-66 -1 -83 -44 -92 -67l-131 -325c-4 -10 -8 -19 -21 -19s-15 5 -21 19l-144 355c-13 31 -17 37 -80 37v31c30 -2 70 -3 97 -3l109 3v-31c-18 0 -57 0 -57 -26c0 0 0 -4 6 -17l112 -279l102 255c4 11 6 15 6 24c0 19 -11 42 -48 43v31l87 -3c23 0 52 1 75 3v-31 Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-76" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-31" x="747" y="-213"></use>
</g>
</svg> by one face and from <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.282ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 982.4 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">normal v 1</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-76" d="M508 400c-66 -1 -83 -44 -92 -67l-131 -325c-4 -10 -8 -19 -21 -19s-15 5 -21 19l-144 355c-13 31 -17 37 -80 37v31c30 -2 70 -3 97 -3l109 3v-31c-18 0 -57 0 -57 -26c0 0 0 -4 6 -17l112 -279l102 255c4 11 6 15 6 24c0 19 -11 42 -48 43v31l87 -3c23 0 52 1 75 3v-31 Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-76" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-31" x="747" y="-213"></use>
</g>
</svg> to
<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.282ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 982.4 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">normal v 0</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-76" d="M508 400c-66 -1 -83 -44 -92 -67l-131 -325c-4 -10 -8 -19 -21 -19s-15 5 -21 19l-144 355c-13 31 -17 37 -80 37v31c30 -2 70 -3 97 -3l109 3v-31c-18 0 -57 0 -57 -26c0 0 0 -4 6 -17l112 -279l102 255c4 11 6 15 6 24c0 19 -11 42 -48 43v31l87 -3c23 0 52 1 75 3v-31 Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-30" d="M460 320c0 -79 -5 -157 -37 -226c-44 -95 -120 -116 -174 -116c-49 0 -122 20 -165 101c-41 76 -45 166 -45 241c0 80 5 158 37 227c41 93 114 119 174 119c42 0 124 -16 170 -112c35 -74 40 -154 40 -234zM377 332c0 63 0 139 -10 195c-19 99 -85 117 -118 117 c-25 0 -100 -9 -119 -128c-8 -54 -8 -120 -8 -184c0 -59 0 -151 11 -211c18 -96 77 -121 116 -121c45 0 102 30 117 125c11 64 11 132 11 207Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-76" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-30" x="747" y="-213"></use>
</g>
</svg> by the other.  Another way to think of this is in terms of face
orientation: all faces&rsquo; vertices should be given consistently in either
clockwise or counterclockwise order, as seen from outside the mesh.</span>
</figcaption><p>
  

</p>
</div></div><p>


</p>
<p>Given this assumption about the input data, the <tt>LoopSubdivide()</tt> can now 
initialize the mesh&rsquo;s topological data structures.  It first loops over
all of the faces and sets their <tt>v</tt> pointers to point to their three
vertices.  It also sets each vertex&rsquo;s <a href="#SDVertex::startFace"><tt>SDVertex::startFace</tt></a> pointer to
point to one of the vertex&rsquo;s neighboring faces.  It doesn&rsquo;t matter which of
its adjacent faces is used, so the implementation just keeps resetting it
each time it
comes across another face that the vertex is incident to, thus ensuring that all vertices
have a non-<tt>nullptr</tt> face pointer by the time the loop is complete.

</p>
<p></p>
<span class="anchor" id="fragment-Setfacetovertexpointers-0"></span><div class="fragmentname">&lt;&lt;Set face to vertex pointers&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">const int *vp = vertexIndices;
for (int i = 0; i &lt; nFaces; ++i, vp += 3) {
    SDFace *f = faces[i];
    for (int j = 0; j &lt; 3; ++j) {
        SDVertex *<a href="#SDFace::v" class="code">v</a> = vertices[vp[j]];
        f-&gt;<a href="#SDFace::v" class="code">v</a>[j] = <a href="#SDFace::v" class="code">v</a>;
        <a href="#SDFace::v" class="code">v</a>-&gt;<a href="#SDVertex::startFace" class="code">startFace</a> = f;
    }
}</div><p>


</p>
<p>Now it is necessary to set each face&rsquo;s <tt>f</tt> pointer to point to its neighboring
faces.  This is a bit trickier, since face adjacency information isn&rsquo;t
directly specified in the data passed to <tt>LoopSubdivide()</tt>.
The implementation here loops over the faces and creates an
<tt>SDEdge</tt> object for each of their three edges. When it comes to another
face that shares the same edge, it can update both faces&rsquo; neighbor
pointers.

</p>
<p></p>
<span class="anchor" id="fragment-LoopSubdivLocalStructures-2"></span><div class="fragmentname">&lt;&lt;LoopSubdiv Local Structures&gt;&gt;+=&nbsp;<a href="#fragment-LoopSubdivLocalStructures-1"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode">struct <span class="anchor" id="SDEdge"></span>SDEdge {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-SDEdgeConstructor-0">SDEdge Constructor</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-409" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-409"><i></i></a><div id="fragbit-409" class="collapse"><div class="fragmentcode">       SDEdge(SDVertex *v0 = nullptr, SDVertex *v1 = nullptr) {
           v[0] = std::min(v0, v1);
           v[1] = std::max(v0, v1);
           f[0] = f[1] = nullptr;
           f0edgeNum = -1;
       }</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-SDEdgeComparisonFunction-0">SDEdge Comparison Function</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-410" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-410"><i></i></a><div id="fragbit-410" class="collapse"><div class="fragmentcode">       bool operator&lt;(const SDEdge &amp;e2) const {
           if (<a href="#SDEdge::v" class="code">v</a>[0] == e2.<a href="#SDEdge::v" class="code">v</a>[0]) return <a href="#SDEdge::v" class="code">v</a>[1] &lt; e2.<a href="#SDEdge::v" class="code">v</a>[1];
           return <a href="#SDEdge::v" class="code">v</a>[0] &lt; e2.<a href="#SDEdge::v" class="code">v</a>[0];
       }</div></div>
    SDVertex *<span class="anchor" id="SDEdge::v"></span>v[2];
    SDFace *<span class="anchor" id="SDEdge::f"></span>f[2];
    int <span class="anchor" id="SDEdge::f0edgeNum"></span>f0edgeNum;
};</div><p>


</p>
<p>The <a href="#SDEdge"><tt>SDEdge</tt></a> constructor takes pointers to the two vertices at each end
of the edge.  It orders them so that <tt>v[0]</tt> holds the one that is
first in memory. This code may seem strange, but it is simply relying on
the fact that pointers in C++ are effectively numbers that can be
manipulated like integers<button style="button" data-toggle="tooltip" data-placement="right" data-html="true" class="btn footnote-button" title="Segmented architectures
notwithstanding.">
      <sup>&dagger;</sup>
    </button>
		 and that the ordering of vertices on an edge is
arbitrary.  Sorting the two vertices based on the addresses of their
pointers guarantees that the edge (v<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.054ex" height="1.343ex" style="vertical-align: -0.671ex;" viewBox="0 -289 453.9 578.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">Subscript normal a</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-61" d="M483 89c0 -81 -61 -95 -82 -95c-47 0 -74 42 -78 82c-19 -47 -65 -87 -131 -87c-63 0 -160 25 -160 106c0 44 25 96 100 130c63 30 133 33 184 36v37c0 89 -57 128 -106 128c-32 0 -81 -11 -108 -46c46 -1 51 -34 51 -46c0 -26 -18 -46 -46 -46c-26 0 -46 17 -46 47 c0 66 69 113 151 113c48 0 98 -16 137 -55c36 -37 36 -76 36 -118v-200c0 -5 4 -50 37 -50c11 0 36 6 36 64v56h25v-56zM316 140v100c-165 -6 -207 -89 -207 -144c0 -50 41 -85 90 -85c45 0 117 34 117 129Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-61" x="0" y="-213"></use>
</g>
</svg>, v<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.146ex" height="1.676ex" style="vertical-align: -0.671ex;" viewBox="0 -432.6 493.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">Subscript normal b</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-62" d="M521 216c0 -129 -104 -227 -223 -227c-74 0 -116 50 -131 73l-36 -62h-25v596c0 49 -8 56 -78 56v31l144 11v-317c16 18 59 65 137 65c114 0 212 -99 212 -226zM438 217c0 41 -3 98 -29 139c-24 38 -60 64 -105 64c-24 0 -79 -8 -118 -64c-11 -16 -11 -17 -11 -36v-206 c0 -18 0 -21 14 -42c24 -37 60 -61 105 -61c54 0 92 33 113 64c29 45 31 105 31 142Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-62" x="0" y="-213"></use>
</g>
</svg>) is
correctly recognized as the same as the edge (v<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.146ex" height="1.676ex" style="vertical-align: -0.671ex;" viewBox="0 -432.6 493.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">Subscript normal b</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-62" d="M521 216c0 -129 -104 -227 -223 -227c-74 0 -116 50 -131 73l-36 -62h-25v596c0 49 -8 56 -78 56v31l144 11v-317c16 18 59 65 137 65c114 0 212 -99 212 -226zM438 217c0 41 -3 98 -29 139c-24 38 -60 64 -105 64c-24 0 -79 -8 -118 -64c-11 -16 -11 -17 -11 -36v-206 c0 -18 0 -21 14 -42c24 -37 60 -61 105 -61c54 0 92 33 113 64c29 45 31 105 31 142Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-62" x="0" y="-213"></use>
</g>
</svg>,
v<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.054ex" height="1.343ex" style="vertical-align: -0.671ex;" viewBox="0 -289 453.9 578.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">Subscript normal a</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-61" d="M483 89c0 -81 -61 -95 -82 -95c-47 0 -74 42 -78 82c-19 -47 -65 -87 -131 -87c-63 0 -160 25 -160 106c0 44 25 96 100 130c63 30 133 33 184 36v37c0 89 -57 128 -106 128c-32 0 -81 -11 -108 -46c46 -1 51 -34 51 -46c0 -26 -18 -46 -46 -46c-26 0 -46 17 -46 47 c0 66 69 113 151 113c48 0 98 -16 137 -55c36 -37 36 -76 36 -118v-200c0 -5 4 -50 37 -50c11 0 36 6 36 64v56h25v-56zM316 140v100c-165 -6 -207 -89 -207 -144c0 -50 41 -85 90 -85c45 0 117 34 117 129Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-61" x="0" y="-213"></use>
</g>
</svg>), regardless of what order the vertices are provided in.

</p>
<p></p>
<span class="anchor" id="fragment-SDEdgeConstructor-0"></span><div class="fragmentname">&lt;&lt;SDEdge Constructor&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">SDEdge(SDVertex *v0 = nullptr, SDVertex *v1 = nullptr) {
    v[0] = std::min(v0, v1);
    v[1] = std::max(v0, v1);
    f[0] = f[1] = nullptr;
    f0edgeNum = -1;
}</div><p>


</p>
<p>The class also defines an ordering operation for <a href="#SDEdge"><tt>SDEdge</tt></a> objects so
that they can be stored in other data structures that rely on ordering
being well defined.

</p>
<p></p>
<span class="anchor" id="fragment-SDEdgeComparisonFunction-0"></span><div class="fragmentname">&lt;&lt;SDEdge Comparison Function&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">bool operator&lt;(const SDEdge &amp;e2) const {
    if (<a href="#SDEdge::v" class="code">v</a>[0] == e2.<a href="#SDEdge::v" class="code">v</a>[0]) return <a href="#SDEdge::v" class="code">v</a>[1] &lt; e2.<a href="#SDEdge::v" class="code">v</a>[1];
    return <a href="#SDEdge::v" class="code">v</a>[0] &lt; e2.<a href="#SDEdge::v" class="code">v</a>[0];
}</div><p>


</p>
<p>Now the <tt>LoopSubdivide()</tt> function can get to work,
looping over the edges in all of the faces and
updating the neighbor pointers as it goes.  It uses a <tt>set</tt> to store
the edges that have only one adjacent face so far.  The <tt>set</tt> makes
it possible to search for a particular edge in <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="8.336ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 3589.2 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">upper O left-parenthesis log n right-parenthesis</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D442" d="M740 436c0 -239 -223 -458 -435 -458c-144 0 -256 101 -256 267c0 233 220 460 436 460c149 0 255 -108 255 -269zM651 475c0 149 -90 205 -172 205c-79 0 -177 -52 -246 -156c-77 -117 -91 -263 -91 -307c0 -132 70 -213 169 -213c84 0 166 59 214 120 c99 123 126 279 126 351Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-28" d="M332 -238c0 -5 -5 -10 -10 -10c-2 0 -4 1 -6 2c-110 83 -215 283 -215 454v84c0 171 105 371 215 454c2 1 4 2 6 2c5 0 10 -5 10 -10c0 -3 -2 -6 -4 -8c-104 -78 -173 -278 -173 -438v-84c0 -160 69 -360 173 -438c2 -2 4 -5 4 -8Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-6C" d="M255 0l-111 3l-111 -3v31c67 0 78 0 78 45v520c0 49 -8 56 -78 56v31l144 11v-618c0 -45 11 -45 78 -45v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-6F" d="M471 214c0 -127 -101 -225 -222 -225c-117 0 -221 96 -221 225c0 125 97 234 222 234c121 0 221 -106 221 -234zM388 222c0 38 0 96 -26 139s-69 65 -113 65c-40 0 -87 -21 -114 -67c-24 -44 -24 -98 -24 -137c0 -36 0 -97 25 -141c27 -46 71 -67 114 -67 c50 0 94 29 116 74c22 44 22 98 22 134Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-67" d="M485 404c0 -23 -19 -30 -29 -30c-16 0 -29 12 -29 29c0 12 5 23 16 27c-3 1 -10 1 -10 1c-18 0 -54 -5 -90 -39c25 -23 41 -60 41 -97c0 -77 -69 -146 -162 -146c-19 0 -60 3 -99 31c-17 -20 -17 -43 -17 -47c0 -32 21 -63 53 -67c7 -1 50 -1 75 -1c61 0 119 0 172 -28 c51 -28 65 -79 65 -114c0 -78 -104 -129 -222 -129c-122 0 -221 55 -221 127c0 40 32 83 92 100c-31 20 -44 58 -44 89c0 35 18 68 31 83c-25 21 -47 59 -47 103c0 77 69 146 162 146c22 0 64 -3 106 -36c42 41 86 47 106 47c39 0 51 -32 51 -49zM309 296 c0 23 0 123 -87 123c-40 0 -63 -28 -71 -40c-15 -25 -16 -57 -16 -84c0 -23 0 -123 87 -123c40 0 63 28 71 40c15 25 16 57 16 84zM419 -79c0 86 -112 86 -198 86h-59c-44 -3 -82 -40 -82 -86c0 -53 69 -104 170 -104c98 0 169 50 169 104Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D45B" d="M571 143c0 -8 -37 -154 -131 -154c-47 0 -82 35 -82 82c0 11 1 23 10 46c16 43 65 171 65 233c0 33 -9 70 -54 70c-95 0 -148 -91 -163 -122l-13 -50c-5 -23 -11 -45 -17 -67l-22 -90c-6 -25 -18 -72 -19 -74c-7 -20 -25 -28 -37 -28c-15 0 -29 9 -29 27c0 5 6 28 9 43 l58 231c13 52 16 63 16 84c0 33 -11 46 -31 46c-36 0 -56 -48 -73 -119c-6 -22 -7 -23 -17 -23c0 0 -12 0 -12 10c0 4 14 63 30 97c10 18 29 57 75 57s87 -31 92 -87c17 23 66 87 156 87c72 0 115 -40 115 -107c0 -57 -42 -167 -61 -220c-9 -22 -18 -46 -18 -71 c0 -23 7 -33 24 -33c49 0 82 56 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-29" d="M288 208c0 -171 -105 -371 -215 -454c-2 -1 -4 -2 -6 -2c-5 0 -10 5 -10 10c0 3 2 6 4 8c104 78 173 278 173 438v84c0 160 -69 360 -173 438c-2 2 -4 5 -4 8c0 5 5 10 10 10c2 0 4 -1 6 -2c110 -83 215 -283 215 -454v-84Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D442" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-28" x="763" y="0"></use>
<g transform="translate(1153,0)">
 <use xlink:href="#E1-LATINMODERNMAIN-6C"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-6F" x="278" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-67" x="779" y="0"></use>
</g>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D45B" x="2599" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-29" x="3199" y="0"></use>
</g>
</svg> time.

</p>
<p></p>
<span class="anchor" id="fragment-Setneighborpointersinmonofaces-0"></span><div class="fragmentname">&lt;&lt;Set neighbor pointers in <tt>faces</tt>&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">std::set&lt;SDEdge&gt; edges;
for (int i = 0; i &lt; nFaces; ++i) {
    SDFace *f = faces[i];
    for (int edgeNum = 0; edgeNum &lt; 3; ++edgeNum) {
        &lt;&lt;<span class="fragmentname"><a href="#fragment-UpdateneighborpointerformonoedgeNum-0">Update neighbor pointer for <tt>edgeNum</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-411" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-411"><i></i></a><div id="fragbit-411" class="collapse"><div class="fragmentcode">           int v0 = edgeNum, v1 = <a href="#NEXT" class="code">NEXT</a>(edgeNum);
           SDEdge e(f-&gt;v[v0], f-&gt;v[v1]);
           if (edges.find(e) == edges.end()) {
               &lt;&lt;<span class="fragmentname"><a href="#fragment-Handlenewedge-0">Handle new edge</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-412" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-412"><i></i></a><div id="fragbit-412" class="collapse"><div class="fragmentcode">                  e.<a href="#SDEdge::f" class="code">f</a>[0] = <a href="#SDEdge::f" class="code">f</a>;
                  e.<a href="#SDEdge::f0edgeNum" class="code">f0edgeNum</a> = edgeNum;
                  edges.insert(e);</div></div>
           } else {
               &lt;&lt;<span class="fragmentname"><a href="#fragment-Handlepreviouslyseenedge-0">Handle previously seen edge</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-413" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-413"><i></i></a><div id="fragbit-413" class="collapse"><div class="fragmentcode">                  e = *edges.find(e);
                  e.<a href="#SDEdge::f" class="code">f</a>[0]-&gt;<a href="#SDEdge::f" class="code">f</a>[e.<a href="#SDEdge::f0edgeNum" class="code">f0edgeNum</a>] = <a href="#SDEdge::f" class="code">f</a>;
                  <a href="#SDEdge::f" class="code">f</a>-&gt;<a href="#SDEdge::f" class="code">f</a>[edgeNum] = e.<a href="#SDEdge::f" class="code">f</a>[0];
                  edges.erase(e);</div></div>
           }</div></div>
    }
}</div><p>


</p>
<p>For each edge in each face, the loop body creates an edge object and sees if
the same edge has been seen previously.  If so, it initializes both faces&rsquo;
neighbor pointers across the edge.  If not, it adds the edge to the set of
edges.  The indices of the two vertices at the ends of the edge, <tt>v0</tt>
and <tt>v1</tt>, are equal to the edge index and the edge index plus one.

</p>
<p></p>
<span class="anchor" id="fragment-UpdateneighborpointerformonoedgeNum-0"></span><div class="fragmentname">&lt;&lt;Update neighbor pointer for <tt>edgeNum</tt>&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">int v0 = edgeNum, v1 = <a href="#NEXT" class="code">NEXT</a>(edgeNum);
SDEdge e(f-&gt;v[v0], f-&gt;v[v1]);
if (edges.find(e) == edges.end()) {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Handlenewedge-0">Handle new edge</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-414" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-414"><i></i></a><div id="fragbit-414" class="collapse"><div class="fragmentcode">       e.<a href="#SDEdge::f" class="code">f</a>[0] = <a href="#SDEdge::f" class="code">f</a>;
       e.<a href="#SDEdge::f0edgeNum" class="code">f0edgeNum</a> = edgeNum;
       edges.insert(e);</div></div>
} else {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Handlepreviouslyseenedge-0">Handle previously seen edge</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-415" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-415"><i></i></a><div id="fragbit-415" class="collapse"><div class="fragmentcode">       e = *edges.find(e);
       e.<a href="#SDEdge::f" class="code">f</a>[0]-&gt;<a href="#SDEdge::f" class="code">f</a>[e.<a href="#SDEdge::f0edgeNum" class="code">f0edgeNum</a>] = <a href="#SDEdge::f" class="code">f</a>;
       <a href="#SDEdge::f" class="code">f</a>-&gt;<a href="#SDEdge::f" class="code">f</a>[edgeNum] = e.<a href="#SDEdge::f" class="code">f</a>[0];
       edges.erase(e);</div></div>
}</div><p>


</p>
<p>
Given an edge that hasn&rsquo;t been encountered before, the current face&rsquo;s
pointer is stored in the edge object&rsquo;s <tt>f[0]</tt> member.  Because the
input mesh is assumed to be manifold, there can be at most one other face
that shares this edge. When such a face is discovered, it can be used to 
initialize the neighboring face field.
Storing the edge number of this edge in the
current face allows the neighboring face to initialize its corresponding
edge neighbor pointer. 

</p>
<p></p>
<span class="anchor" id="fragment-Handlenewedge-0"></span><div class="fragmentname">&lt;&lt;Handle new edge&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">e.<a href="#SDEdge::f" class="code">f</a>[0] = <a href="#SDEdge::f" class="code">f</a>;
e.<a href="#SDEdge::f0edgeNum" class="code">f0edgeNum</a> = edgeNum;
edges.insert(e);</div><p>


</p>
<p>When the second face on an edge is found,  the neighbor pointers for
each of the two faces are set.  The edge is then removed from the edge set, since 
no edge can be shared by more than two faces.

</p>
<p></p>
<span class="anchor" id="fragment-Handlepreviouslyseenedge-0"></span><div class="fragmentname">&lt;&lt;Handle previously seen edge&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">e = *edges.find(e);
e.<a href="#SDEdge::f" class="code">f</a>[0]-&gt;<a href="#SDEdge::f" class="code">f</a>[e.<a href="#SDEdge::f0edgeNum" class="code">f0edgeNum</a>] = <a href="#SDEdge::f" class="code">f</a>;
<a href="#SDEdge::f" class="code">f</a>-&gt;<a href="#SDEdge::f" class="code">f</a>[edgeNum] = e.<a href="#SDEdge::f" class="code">f</a>[0];
edges.erase(e);</div><p>


</p>
<p>Now that all faces have proper neighbor pointers,  the
<tt>boundary</tt> and <tt>regular</tt> flags in each of the vertices can be set.  In order
to determine if a vertex is a boundary vertex, we&rsquo;ll define an ordering of
faces around a vertex (Figure&nbsp;<a href="#fig:loop-prev-next-face">3.29</a>).  For a vertex
<tt>v[i]</tt> on a face <tt>f</tt>, we define the vertex&rsquo;s <em>next face</em> as
the face across the edge from <tt>v[i]</tt> to <tt>v[NEXT(i)]</tt> and the
<em>previous face</em> as the face across the edge from <tt>v[PREV(i)]</tt> to&nbsp;<tt>v[i]</tt>.

</p>
<p>
</p>
<span class="anchor" id="fig:loop-prev-next-face"></span><div class="card outerfigure"><div class="card-body figure"><p>



</p>
<div class="figure-row">
  <a href="Subdiv%20prev%20next%20face.svg" title=""><img src="Subdiv%20prev%20next%20face.svg" width=383 height=240 style="max-width: 100%;"></a>
</div>
<p>


</p>
<figcaption class="caption">Figure 3.29: <span class="legend"> Given a vertex <tt>v[i]</tt> and a face
that it is incident to, <tt>f</tt>, we define the <em>next face</em> as the face
adjacent to <tt>f</tt> across the edge from <tt>v[i]</tt> to <tt>v[NEXT(i)]</tt>.  The
previous face is defined analogously.</span>
</figcaption><p>


</p>
</div></div><p>


</p>
<p>


</p>
<p>By successively going to the next face around <tt>v</tt>,
we can iterate over the faces adjacent to it.  If we eventually return to
the face we started at, then we are at an interior vertex; if we come to an
edge with a <tt>nullptr</tt> neighbor pointer, then we&rsquo;re at a boundary vertex
(Figure&nbsp;<a href="#fig:loop-vert-boundary">3.30</a>).  Once the initialization routine has determined if 
this is a boundary vertex, it computes the valence of the vertex and sets the
<tt>regular</tt> flag if the valence is 6 for an interior vertex or 4 for a
boundary vertex; otherwise, it is an extraordinary vertex.

</p>
<p>
</p>
<span class="anchor" id="fig:loop-vert-boundary"></span><div class="card outerfigure"><div class="card-body figure"><p>



</p>
<div class="figure-row">
  <a href="Subdiv%20determine%20boundary.svg" title=""><img src="Subdiv%20determine%20boundary.svg" width=461 height=265 style="max-width: 100%;"></a>
</div>
<p>


</p>
<figcaption class="caption">Figure 3.30: <span class="legend"> We can determine if a vertex is a
boundary vertex by starting from the adjacent face <tt>startFace</tt> and
following next face pointers around the vertex.  If we come to a face that
has no next neighbor face, then the vertex is on a boundary.  If we return
to <tt>startFace</tt>, it&rsquo;s an interior vertex.</span>
</figcaption><p>


</p>
</div></div><p>


</p>
<p></p>
<span class="anchor" id="fragment-Finishvertexinitialization-0"></span><div class="fragmentname">&lt;&lt;Finish vertex initialization&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">for (int i = 0; i &lt; nVertices; ++i) {
    SDVertex *v = vertices[i];
    SDFace *f = v-&gt;<a href="#SDVertex::startFace" class="code">startFace</a>;
    do {
        f = f-&gt;<a href="#SDFace::nextFace" class="code">nextFace</a>(v);
    } while (f &amp;&amp; f != v-&gt;<a href="#SDVertex::startFace" class="code">startFace</a>);
    v-&gt;<a href="#SDVertex::boundary" class="code">boundary</a> = (f == nullptr);
    if (!v-&gt;<a href="#SDVertex::boundary" class="code">boundary</a> &amp;&amp; v-&gt;valence() == 6)
        v-&gt;<a href="#SDVertex::regular" class="code">regular</a> = true;
    else if (v-&gt;<a href="#SDVertex::boundary" class="code">boundary</a> &amp;&amp; v-&gt;valence() == 4)
        v-&gt;<a href="#SDVertex::regular" class="code">regular</a> = true;
    else
        v-&gt;<a href="#SDVertex::regular" class="code">regular</a> = false;
}</div><p>


</p>
<p>
Because the valence of a vertex is frequently needed, 
we provide the method <a href="#SDVertex::valence"><tt>SDVertex::valence()</tt></a>.

</p>
<p></p>
<span class="anchor" id="fragment-LoopSubdivInlineFunctions-0"></span><div class="fragmentname">&lt;&lt;LoopSubdiv Inline Functions&gt;&gt;=&nbsp;<a href="#fragment-LoopSubdivInlineFunctions-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">inline int SDVertex::<span class="anchor" id="SDVertex::valence"></span>valence() {
    SDFace *f = <a href="#SDVertex::startFace" class="code">startFace</a>;
    if (!<a href="#SDVertex::boundary" class="code">boundary</a>) {
        &lt;&lt;<span class="fragmentname"><a href="#fragment-Computevalenceofinteriorvertex-0">Compute valence of interior vertex</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-416" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-416"><i></i></a><div id="fragbit-416" class="collapse"><div class="fragmentcode">           int nf = 1;
           while ((f = f-&gt;<a href="#SDFace::nextFace" class="code">nextFace</a>(this)) != startFace)
               ++nf;
           return nf;</div></div>
    } else {
        &lt;&lt;<span class="fragmentname"><a href="#fragment-Computevalenceofboundaryvertex-0">Compute valence of boundary vertex</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-417" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-417"><i></i></a><div id="fragbit-417" class="collapse"><div class="fragmentcode">           int nf = 1;
           while ((f = f-&gt;<a href="#SDFace::nextFace" class="code">nextFace</a>(this)) != nullptr)
               ++nf;
           f = startFace;
           while ((f = f-&gt;<a href="#SDFace::prevFace" class="code">prevFace</a>(this)) != nullptr)
               ++nf;
           return nf + 1;</div></div> 
    }
}</div><p>


</p>
<p>To&nbsp;compute the valence of a nonboundary vertex, this method counts the number of the
adjacent faces starting by following each face&rsquo;s neighbor pointers around the
vertex until it reaches the starting face.  The valence is equal to the number of
faces visited.

</p>
<p></p>
<span class="anchor" id="fragment-Computevalenceofinteriorvertex-0"></span><div class="fragmentname">&lt;&lt;Compute valence of interior vertex&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">int nf = 1;
while ((f = f-&gt;<a href="#SDFace::nextFace" class="code">nextFace</a>(this)) != startFace)
    ++nf;
return nf;</div><p>


</p>
<p>For boundary vertices we can use the same approach, although in this case, the
valence is one more than the number of adjacent faces.  The loop over adjacent
faces is slightly more complicated here: it follows pointers to the next face
around the vertex until it reaches the boundary, counting the number of faces
seen.  It then starts again at <tt>startFace</tt> and follows previous face
pointers until it encounters the boundary in the other direction.

</p>
<p></p>
<span class="anchor" id="fragment-Computevalenceofboundaryvertex-0"></span><div class="fragmentname">&lt;&lt;Compute valence of boundary vertex&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">int nf = 1;
while ((f = f-&gt;<a href="#SDFace::nextFace" class="code">nextFace</a>(this)) != nullptr)
    ++nf;
f = startFace;
while ((f = f-&gt;<a href="#SDFace::prevFace" class="code">prevFace</a>(this)) != nullptr)
    ++nf;
return nf + 1;</div><p>


</p>
<p><a href="#SDFace::vnum"><tt>SDFace::vnum()</tt></a> is a utility function that finds the index of a given
vertex pointer.
 It is a fatal error to pass
a pointer to a vertex that isn&rsquo;t part of the current face&mdash;this
case would represent a bug elsewhere in the subdivision code.

</p>
<p></p>
<span class="anchor" id="fragment-SDFaceMethods-0"></span><div class="fragmentname">&lt;&lt;SDFace Methods&gt;&gt;=&nbsp;<a href="#fragment-SDFaceMethods-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">int <span class="anchor" id="SDFace::vnum"></span>vnum(SDVertex *vert) const {
    for (int i = 0; i &lt; 3; ++i)
        if (<a href="#SDFace::v" class="code">v</a>[i] == vert) return i;
    <a href="../Utilities/Communicating_with_the_User.html#Severe" class="code">Severe</a>("Basic logic error in SDFace::vnum()");
    return -1;
}</div><p>


</p>
<p>Since the next face for a vertex <tt>v[i]</tt> on a face <tt>f</tt> is over the
<tt>i</tt>th edge (recall the mapping of edge neighbor pointers from
Figure&nbsp;<a href="#fig:sd-face">3.27</a>), we can find the appropriate face neighbor
pointer easily given the index <tt>i</tt> for the vertex, which the
<tt>vnum()</tt> utility function provides.  The previous face is across the
edge from <tt>PREV(i)</tt> to <tt>i</tt>, so the method returns
<tt>f[PREV(i)]</tt> for the previous face.

</p>
<p></p>
<span class="anchor" id="fragment-SDFaceMethods-1"></span><div class="fragmentname">&lt;&lt;SDFace Methods&gt;&gt;+=&nbsp;<a href="#fragment-SDFaceMethods-0"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-SDFaceMethods-2"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">SDFace *<span class="anchor" id="SDFace::nextFace"></span>nextFace(SDVertex *vert) {
    return <a href="#SDFace::f" class="code">f</a>[<a href="#SDFace::vnum" class="code">vnum</a>(vert)];
}</div><p>


</p>
<p></p>
<span class="anchor" id="fragment-SDFaceMethods-2"></span><div class="fragmentname">&lt;&lt;SDFace Methods&gt;&gt;+=&nbsp;<a href="#fragment-SDFaceMethods-1"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-SDFaceMethods-3"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">SDFace *<span class="anchor" id="SDFace::prevFace"></span>prevFace(SDVertex *vert) {
    return <a href="#SDFace::f" class="code">f</a>[<a href="#PREV" class="code">PREV</a>(<a href="#SDFace::vnum" class="code">vnum</a>(vert))];
}</div><p>


</p>
<p>It is also useful to be able to get the next and previous vertices around
a face starting at any vertex.  The <a href="#SDFace::nextVert"><tt>SDFace::nextVert()</tt></a> and
<a href="#SDFace::prevVert"><tt>SDFace::prevVert()</tt></a> methods do just that
(Figure&nbsp;<a href="#fig:loop-prevvert-nextvert">3.31</a>).

</p>
<p></p>
<span class="anchor" id="fig:loop-prevvert-nextvert"></span><div class="card outerfigure"><div class="card-body figure"><p>



</p>
<div class="figure-row">
  <a href="Subdiv%20prev%20next%20vert.svg" title=""><img src="Subdiv%20prev%20next%20vert.svg" width=327 height=218 style="max-width: 100%;"></a>
</div>
<p>


</p>
<figcaption class="caption">Figure 3.31: <span class="legend"> Given a vertex <tt>v</tt> on a face
<tt>f</tt>, the method <tt>f-&gt;prevVert(v)</tt> returns the previous vertex around the
face from <tt>v</tt>, and <tt>f-&gt;nextVert(v)</tt> returns the next vertex, where
&ldquo;next&rdquo; and &ldquo;previous&rdquo; are defined by the original ordering of vertices
when this face was defined.</span>
</figcaption><p>

</p>
</div></div><p>


</p>
<p></p>
<span class="anchor" id="fragment-SDFaceMethods-3"></span><div class="fragmentname">&lt;&lt;SDFace Methods&gt;&gt;+=&nbsp;<a href="#fragment-SDFaceMethods-2"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-SDFaceMethods-4"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">SDVertex *<span class="anchor" id="SDFace::nextVert"></span>nextVert(SDVertex *vert) {
    return <a href="#SDFace::v" class="code">v</a>[<a href="#NEXT" class="code">NEXT</a>(<a href="#SDFace::vnum" class="code">vnum</a>(vert))];
}</div><p>


</p>
<p></p>
<span class="anchor" id="fragment-SDFaceMethods-4"></span><div class="fragmentname">&lt;&lt;SDFace Methods&gt;&gt;+=&nbsp;<a href="#fragment-SDFaceMethods-3"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-SDFaceMethods-5"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">SDVertex *<span class="anchor" id="SDFace::prevVert"></span>prevVert(SDVertex *vert) {
    return <a href="#SDFace::v" class="code">v</a>[<a href="#PREV" class="code">PREV</a>(<a href="#SDFace::vnum" class="code">vnum</a>(vert))];
}</div><p>


</p>
<p>


</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#Subdivision"><i class="fas fa-link h3h4marginlink"></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span class="anchor" id="sec:loop-refine"></span><span id="Subdivision"></span><h3>3.8.2  Subdivision</h3><p>



</p>
<p>Now we can show how subdivision proceeds with the modified Loop rules.  The
implementation here applies subdivision a fixed number of times to generate a
triangle mesh for rendering; Exercise&nbsp;<a href="../Shapes/Exercises.html#ex:shapes-exercise-adaptive-subdiv">3.9.7</a>
at the end of the chapter discusses adaptive subdivision, where each original
face is subdivided enough times so that the result looks smooth from a
particular viewpoint rather than just using a fixed number of levels of
subdivision, which may over-subdivide some areas while simultaneously
under-subdividing others.

</p>
<p>The &lt;&lt;<span class="fragmentname"><a href="#fragment-Refinesubdivisionmeshintotriangles-0">Refine subdivision mesh into triangles</a></span>&gt;&gt; fragment repeatedly
applies the subdivision rules to the mesh, each time generating a new mesh
to be used as the input to the next step.  After each subdivision step, the
<tt>f</tt> and <tt>v</tt> arrays are updated to
point to the faces and vertices from the level of subdivision just
computed.  When it&rsquo;s done subdividing, a triangle mesh representation of
the surface is returned.

</p>
<p>An instance of the <a href="../Utilities/Memory_Management.html#MemoryArena"><tt>MemoryArena</tt></a> class is used to allocate temporary
storage through this process.  This class, defined in
Section&nbsp;<a href="../Utilities/Memory_Management.html#sec:arena-alloc">A.4.3</a>, provides a custom memory
allocation method that quickly allocates memory, automatically freeing the
memory when it goes out of scope.

</p>
<p></p>
<span class="anchor" id="fragment-Refinesubdivisionmeshintotriangles-0"></span><div class="fragmentname">&lt;&lt;Refine subdivision mesh into triangles&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">std::vector&lt;SDFace *&gt; f = <a href="#LoopSubdiv::faces" class="code">faces</a>;
std::vector&lt;SDVertex *&gt; v = <a href="#LoopSubdiv::vertices" class="code">vertices</a>;
<a href="../Utilities/Memory_Management.html#MemoryArena" class="code">MemoryArena</a> arena;
for (int i = 0; i &lt; nLevels; ++i) {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Updatemonofandmonovfornextlevelofsubdivision-0">Update <tt>f</tt> and <tt>v</tt> for next level of subdivision</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-418" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-418"><i></i></a><div id="fragbit-418" class="collapse"><div class="fragmentcode">       std::vector&lt;SDFace *&gt; newFaces;
       std::vector&lt;SDVertex *&gt; newVertices;
       &lt;&lt;<span class="fragmentname"><a href="#fragment-Allocatenextlevelofchildreninmeshtree-0">Allocate next level of children in mesh tree</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-419" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-419"><i></i></a><div id="fragbit-419" class="collapse"><div class="fragmentcode">          for (SDVertex *vertex : v) {
              vertex-&gt;child = arena.<a href="../Utilities/Memory_Management.html#MemoryArena::Alloc" class="code">Alloc</a>&lt;SDVertex&gt;();
              vertex-&gt;child-&gt;<a href="#SDVertex::regular" class="code">regular</a> = vertex-&gt;<a href="#SDVertex::regular" class="code">regular</a>;
              vertex-&gt;child-&gt;<a href="#SDVertex::boundary" class="code">boundary</a> = vertex-&gt;<a href="#SDVertex::boundary" class="code">boundary</a>;
              newVertices.push_back(vertex-&gt;child);
          }
          for (SDFace *face : f) {
              for (int k = 0; k &lt; 4; ++k) {
                  face-&gt;<a href="#SDFace::children" class="code">children</a>[k] = arena.<a href="../Utilities/Memory_Management.html#MemoryArena::Alloc" class="code">Alloc</a>&lt;SDFace&gt;();
                  newFaces.push_back(face-&gt;<a href="#SDFace::children" class="code">children</a>[k]);
              }
          }</div></div>
       &lt;&lt;<span class="fragmentname"><a href="#fragment-Updatevertexpositionsandcreatenewedgevertices-0">Update vertex positions and create new edge vertices</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-420" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-420"><i></i></a><div id="fragbit-420" class="collapse"><div class="fragmentcode">          &lt;&lt;<span class="fragmentname"><a href="#fragment-Updatevertexpositionsforevenvertices-0">Update vertex positions for even vertices</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-421" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-421"><i></i></a><div id="fragbit-421" class="collapse"><div class="fragmentcode">             for (SDVertex *vertex : v) {
                 if (!vertex-&gt;<a href="#SDVertex::boundary" class="code">boundary</a>) {
                     &lt;&lt;<span class="fragmentname"><a href="#fragment-Applyone-ringruleforevenvertex-0">Apply one-ring rule for even vertex</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-422" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-422"><i></i></a><div id="fragbit-422" class="collapse"><div class="fragmentcode">                        if (vertex-&gt;<a href="#SDVertex::regular" class="code">regular</a>)
                            vertex-&gt;<a href="#SDVertex::child" class="code">child</a>-&gt;<a href="#SDVertex::p" class="code">p</a> = <a href="#LoopSubdiv::weightOneRing" class="code">weightOneRing</a>(vertex, 1.f / 16.f);
                        else
                            vertex-&gt;<a href="#SDVertex::child" class="code">child</a>-&gt;<a href="#SDVertex::p" class="code">p</a> = <a href="#LoopSubdiv::weightOneRing" class="code">weightOneRing</a>(vertex, <a href="#LoopSubdiv::beta" class="code">beta</a>(vertex-&gt;<a href="#SDVertex::valence" class="code">valence</a>()));</div></div>
                 } else {
                     &lt;&lt;<span class="fragmentname"><a href="#fragment-Applyboundaryruleforevenvertex-0">Apply boundary rule for even vertex</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-423" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-423"><i></i></a><div id="fragbit-423" class="collapse"><div class="fragmentcode">                        vertex-&gt;<a href="#SDVertex::child" class="code">child</a>-&gt;<a href="#SDVertex::p" class="code">p</a> = <a href="#LoopSubdiv::weightBoundary" class="code">weightBoundary</a>(vertex, 1.f / 8.f);</div></div>
                 }
             }</div></div>
          &lt;&lt;<span class="fragmentname"><a href="#fragment-Computenewoddedgevertices-0">Compute new odd edge vertices</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-424" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-424"><i></i></a><div id="fragbit-424" class="collapse"><div class="fragmentcode">             std::map&lt;SDEdge, SDVertex *&gt; edgeVerts;
             for (SDFace *face : f) {
                 for (int k = 0; k &lt; 3; ++k) {
                     &lt;&lt;<span class="fragmentname"><a href="#fragment-Computeoddvertexonmonokthedge-0">Compute odd vertex on <tt>k</tt>th edge</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-425" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-425"><i></i></a><div id="fragbit-425" class="collapse"><div class="fragmentcode">                        SDEdge edge(face-&gt;<a href="#SDFace::v" class="code">v</a>[k], face-&gt;<a href="#SDFace::v" class="code">v</a>[<a href="#NEXT" class="code">NEXT</a>(k)]);
                        SDVertex *vert = edgeVerts[edge];
                        if (!vert) {
                            &lt;&lt;<span class="fragmentname"><a href="#fragment-Createandinitializenewoddvertex-0">Create and initialize new odd vertex</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-426" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-426"><i></i></a><div id="fragbit-426" class="collapse"><div class="fragmentcode">                               vert = arena.<a href="../Utilities/Memory_Management.html#MemoryArena::Alloc" class="code">Alloc</a>&lt;SDVertex&gt;();
                               newVertices.push_back(vert);
                               vert-&gt;<a href="#SDVertex::regular" class="code">regular</a> = true;
                               vert-&gt;<a href="#SDVertex::boundary" class="code">boundary</a> = (face-&gt;<a href="#SDFace::f" class="code">f</a>[k] == nullptr);
                               vert-&gt;<a href="#SDVertex::startFace" class="code">startFace</a> = face-&gt;<a href="#SDFace::children" class="code">children</a>[3];</div></div>
                            &lt;&lt;<span class="fragmentname"><a href="#fragment-Applyedgerulestocomputenewvertexposition-0">Apply edge rules to compute new vertex position</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-427" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-427"><i></i></a><div id="fragbit-427" class="collapse"><div class="fragmentcode">                               if (vert-&gt;<a href="#SDVertex::boundary" class="code">boundary</a>) {
                                   vert-&gt;<a href="#SDVertex::p" class="code">p</a> =  0.5f * edge.<a href="#SDEdge::v" class="code">v</a>[0]-&gt;<a href="#SDVertex::p" class="code">p</a>;
                                   vert-&gt;<a href="#SDVertex::p" class="code">p</a> += 0.5f * edge.<a href="#SDEdge::v" class="code">v</a>[1]-&gt;<a href="#SDVertex::p" class="code">p</a>;
                               } else {
                                   vert-&gt;<a href="#SDVertex::p" class="code">p</a> =  3.f/8.f * edge.<a href="#SDEdge::v" class="code">v</a>[0]-&gt;<a href="#SDVertex::p" class="code">p</a>;
                                   vert-&gt;<a href="#SDVertex::p" class="code">p</a> += 3.f/8.f * edge.<a href="#SDEdge::v" class="code">v</a>[1]-&gt;<a href="#SDVertex::p" class="code">p</a>;
                                   vert-&gt;<a href="#SDVertex::p" class="code">p</a> += 1.f/8.f * face-&gt;<a href="#SDFace::otherVert" class="code">otherVert</a>(edge.<a href="#SDEdge::v" class="code">v</a>[0], edge.<a href="#SDEdge::v" class="code">v</a>[1])-&gt;<a href="#SDVertex::p" class="code">p</a>;
                                   vert-&gt;<a href="#SDVertex::p" class="code">p</a> += 1.f/8.f *
                                       face-&gt;f[k]-&gt;<a href="#SDFace::otherVert" class="code">otherVert</a>(edge.<a href="#SDEdge::v" class="code">v</a>[0], edge.<a href="#SDEdge::v" class="code">v</a>[1])-&gt;<a href="#SDVertex::p" class="code">p</a>;
                               }</div></div>
                            edgeVerts[edge] = vert;
                        }</div></div>
                 }
             }</div></div></div></div>
       &lt;&lt;<span class="fragmentname"><a href="#fragment-Updatenewmeshtopology-0">Update new mesh topology</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-428" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-428"><i></i></a><div id="fragbit-428" class="collapse"><div class="fragmentcode">          &lt;&lt;<span class="fragmentname"><a href="#fragment-Updateevenvertexfacepointers-0">Update even vertex face pointers</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-429" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-429"><i></i></a><div id="fragbit-429" class="collapse"><div class="fragmentcode">             for (SDVertex *vertex : v) {
                 int vertNum = vertex-&gt;<a href="#SDVertex::startFace" class="code">startFace</a>-&gt;<a href="#SDFace::vnum" class="code">vnum</a>(vertex);
                 vertex-&gt;child-&gt;<a href="#SDVertex::startFace" class="code">startFace</a> = 
                     vertex-&gt;<a href="#SDVertex::startFace" class="code">startFace</a>-&gt;<a href="#SDFace::children" class="code">children</a>[vertNum];
             }</div></div>
          &lt;&lt;<span class="fragmentname"><a href="#fragment-Updatefaceneighborpointers-0">Update face neighbor pointers</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-430" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-430"><i></i></a><div id="fragbit-430" class="collapse"><div class="fragmentcode">             for (SDFace *face : f) {
                 for (int j = 0; j &lt; 3; ++j) {
                     &lt;&lt;<span class="fragmentname"><a href="#fragment-Updatechildrenmonofpointersforsiblings-0">Update children <tt>f</tt> pointers for siblings</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-431" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-431"><i></i></a><div id="fragbit-431" class="collapse"><div class="fragmentcode">                        face-&gt;<a href="#SDFace::children" class="code">children</a>[3]-&gt;<a href="#SDFace::f" class="code">f</a>[j] = face-&gt;<a href="#SDFace::children" class="code">children</a>[<a href="#NEXT" class="code">NEXT</a>(j)];
                        face-&gt;<a href="#SDFace::children" class="code">children</a>[j]-&gt;<a href="#SDFace::f" class="code">f</a>[<a href="#NEXT" class="code">NEXT</a>(j)] = face-&gt;<a href="#SDFace::children" class="code">children</a>[3];</div></div>
                     &lt;&lt;<span class="fragmentname"><a href="#fragment-Updatechildrenmonofpointersforneighborchildren-0">Update children <tt>f</tt> pointers for neighbor children</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-432" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-432"><i></i></a><div id="fragbit-432" class="collapse"><div class="fragmentcode">                        SDFace *f2 = face-&gt;<a href="#SDFace::f" class="code">f</a>[j];
                        face-&gt;<a href="#SDFace::children" class="code">children</a>[j]-&gt;<a href="#SDFace::f" class="code">f</a>[j] =
                            f2 ? f2-&gt;<a href="#SDFace::children" class="code">children</a>[f2-&gt;<a href="#SDFace::vnum" class="code">vnum</a>(face-&gt;v[j])] : nullptr;
                        f2 = face-&gt;<a href="#SDFace::f" class="code">f</a>[<a href="#PREV" class="code">PREV</a>(j)];
                        face-&gt;<a href="#SDFace::children" class="code">children</a>[j]-&gt;<a href="#SDFace::f" class="code">f</a>[<a href="#PREV" class="code">PREV</a>(j)] = 
                            f2 ? f2-&gt;<a href="#SDFace::children" class="code">children</a>[f2-&gt;<a href="#SDFace::vnum" class="code">vnum</a>(face-&gt;v[j])] : nullptr;</div></div>
                 }
             }</div></div>
          &lt;&lt;<span class="fragmentname"><a href="#fragment-Updatefacevertexpointers-0">Update face vertex pointers</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-433" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-433"><i></i></a><div id="fragbit-433" class="collapse"><div class="fragmentcode">             for (SDFace *face : f) {
                 for (int j = 0; j &lt; 3; ++j) {
                     &lt;&lt;<span class="fragmentname"><a href="#fragment-Updatechildvertexpointertonewevenvertex-0">Update child vertex pointer to new even vertex</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-434" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-434"><i></i></a><div id="fragbit-434" class="collapse"><div class="fragmentcode">                        face-&gt;<a href="#SDFace::children" class="code">children</a>[j]-&gt;<a href="#SDFace::v" class="code">v</a>[j] = face-&gt;<a href="#SDFace::v" class="code">v</a>[j]-&gt;<a href="#SDVertex::child" class="code">child</a>;</div></div>
                     &lt;&lt;<span class="fragmentname"><a href="#fragment-Updatechildvertexpointertonewoddvertex-0">Update child vertex pointer to new odd vertex</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-435" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-435"><i></i></a><div id="fragbit-435" class="collapse"><div class="fragmentcode">                        SDVertex *vert = edgeVerts[SDEdge(face-&gt;<a href="#SDFace::v" class="code">v</a>[j], face-&gt;<a href="#SDFace::v" class="code">v</a>[<a href="#NEXT" class="code">NEXT</a>(j)])];
                        face-&gt;<a href="#SDFace::children" class="code">children</a>[j]-&gt;<a href="#SDFace::v" class="code">v</a>[<a href="#NEXT" class="code">NEXT</a>(j)] = vert;
                        face-&gt;<a href="#SDFace::children" class="code">children</a>[<a href="#NEXT" class="code">NEXT</a>(j)]-&gt;<a href="#SDFace::v" class="code">v</a>[j] = vert;
                        face-&gt;<a href="#SDFace::children" class="code">children</a>[3]-&gt;<a href="#SDFace::v" class="code">v</a>[j] = vert;</div></div>
                 }
             }</div></div></div></div>
       &lt;&lt;<span class="fragmentname"><a href="#fragment-Preparefornextlevelofsubdivision-0">Prepare for next level of subdivision</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-436" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-436"><i></i></a><div id="fragbit-436" class="collapse"><div class="fragmentcode">          f = newFaces;
          v = newVertices;</div></div></div></div>
}
&lt;&lt;<span class="fragmentname"><a href="#fragment-Pushverticestolimitsurface-0">Push vertices to limit surface</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-437" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-437"><i></i></a><div id="fragbit-437" class="collapse"><div class="fragmentcode">   std::unique_ptr&lt;<a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a>[]&gt; pLimit(new <a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a>[v.size()]);
   for (size_t i = 0; i &lt; v.size(); ++i) {
       if (v[i]-&gt;<a href="#SDVertex::boundary" class="code">boundary</a>)
           pLimit[i] =  <a href="#LoopSubdiv::weightBoundary" class="code">weightBoundary</a>(v[i], 1.f / 5.f);
       else
           pLimit[i] =  <a href="#LoopSubdiv::weightOneRing" class="code">weightOneRing</a>(v[i], <a href="#LoopSubdiv::loopGamma" class="code">loopGamma</a>(v[i]-&gt;<a href="#SDVertex::valence" class="code">valence</a>()));
   }
   for (size_t i = 0; i &lt; v.size(); ++i)
       v[i]-&gt;p = pLimit[i];</div></div>
&lt;&lt;<span class="fragmentname"><a href="#fragment-Computevertextangentsonlimitsurface-0">Compute vertex tangents on limit surface</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-438" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-438"><i></i></a><div id="fragbit-438" class="collapse"><div class="fragmentcode">   std::vector&lt;<a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a>&gt; Ns;
   Ns.reserve(v.size());
   std::vector&lt;<a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a>&gt; pRing(16, <a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a>());
   for (SDVertex *vertex : v) {
       <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> S(0,0,0), T(0,0,0);
       int <a href="#SDVertex::valence" class="code">valence</a> = vertex-&gt;<a href="#SDVertex::valence" class="code">valence</a>();
       if (<a href="#SDVertex::valence" class="code">valence</a> &gt; (int)pRing.size())
           pRing.resize(<a href="#SDVertex::valence" class="code">valence</a>);
       vertex-&gt;<a href="#SDVertex::oneRing" class="code">oneRing</a>(&amp;pRing[0]);
       if (!vertex-&gt;<a href="#SDVertex::boundary" class="code">boundary</a>) {
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Computetangentsofinteriorface-0">Compute tangents of interior face</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-439" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-439"><i></i></a><div id="fragbit-439" class="collapse"><div class="fragmentcode">              for (int j = 0; j &lt; valence; ++j) {
                  S += std::cos(2 * <a href="../Utilities/Main_Include_File.html#Pi" class="code">Pi</a> * j / valence) * <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a>(pRing[j]);
                  T += std::sin(2 * <a href="../Utilities/Main_Include_File.html#Pi" class="code">Pi</a> * j / valence) * <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a>(pRing[j]);
              }</div></div>
       } else {
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Computetangentsofboundaryface-0">Compute tangents of boundary face</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-440" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-440"><i></i></a><div id="fragbit-440" class="collapse"><div class="fragmentcode">              S = pRing[valence - 1] - pRing[0];
              if (valence == 2)
                  T = <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a>(pRing[0] + pRing[1] - 2 * vertex-&gt;p);
              else if (valence == 3)
                  T = pRing[1] - vertex-&gt;p;
              else if (valence == 4) // regular
                  T = <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a>(-1 * pRing[0] +  2 * pRing[1] + 2 * pRing[2] + 
                               -1 * pRing[3] + -2 * vertex-&gt;p);
              else {
                  Float theta = <a href="../Utilities/Main_Include_File.html#Pi" class="code">Pi</a> / float(valence - 1);
                  T = <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a>(std::sin(theta) * (pRing[0] + pRing[valence - 1]));
                  for (int k = 1; k &lt; valence - 1; ++k) {
                      Float wt = (2 * std::cos(theta) - 2) * std::sin((k) * theta);
                      T += <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a>(wt * pRing[k]);
                  }
                  T = -T;
              }</div></div>
       }
       Ns.push_back(<a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a>(<a href="../Geometry_and_Transformations/Vectors.html#Cross" class="code">Cross</a>(S, T)));
   }</div></div>
&lt;&lt;<span class="fragmentname">Create triangle mesh from subdivision mesh</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-441" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-441"><i></i></a><div id="fragbit-441" class="collapse"><div class="fragmentcode">   {
   size_t ntris = f.size();
   std::unique_ptr&lt;int[]&gt; verts(new int[3*ntris]);
   int *vp = verts.get();
   size_t totVerts = v.size();
   std::map&lt;SDVertex *, int&gt; usedVerts;
   for (size_t i = 0; i &lt; totVerts; ++i)
       usedVerts[v[i]] = i;
   for (size_t i = 0; i &lt; ntris; ++i) {
       for (int j = 0; j &lt; 3; ++j) {
           *vp = usedVerts[f[i]-&gt;v[j]];
           ++vp;
       }
   }
   return CreateTriangleMesh(ObjectToWorld, WorldToObject, reverseOrientation, ntris, verts.get(),
       totVerts, pLimit.get(), nullptr, &amp;Ns[0], nullptr, nullptr);
   }</div></div></div><p>


</p>
<p>The main loop of a subdivision step proceeds as follows: it creates
<tt>vector</tt>s to store the vertices and faces at the current level of
subdivision and then proceeds to compute new vertex positions and update
the topological representation for the refined mesh.
Figure&nbsp;<a href="#fig:tri-subdiv">3.32</a> shows the basic refinement rules for faces in
the mesh.  Each face is split into four child faces, such that the
<tt>i</tt>th child face is next to the <tt>i</tt>th vertex of the input face
and the final face is in the center.  Three new vertices are then computed
along the split edges of the original face.

</p>
<p> </p>
<span class="anchor" id="fig:tri-subdiv"></span><div class="card outerfigure"><div class="card-body figure"><p>



</p>
<div class="figure-row">
  <a href="Subdiv%20refinement%20naming.svg" title=""><img src="Subdiv%20refinement%20naming.svg" width=550 height=212 style="max-width: 100%;"></a>
</div>
<p>


</p>
<figcaption class="caption">Figure 3.32: Basic Subdivision of a Single Triangular Face. <span class="legend">
Four child faces are created, ordered such that the <tt>i</tt>th child face is
adjacent to the <tt>i</tt>th vertex of the original face and the fourth child face
is in the center of the subdivided face.  Three edge vertices need to be
computed; they are numbered so that the <tt>i</tt>th edge vertex is along the
<tt>i</tt>th edge of the original face.</span>
</figcaption><p>


</p>
</div></div><p>


</p>
<p></p>
<span class="anchor" id="fragment-Updatemonofandmonovfornextlevelofsubdivision-0"></span><div class="fragmentname">&lt;&lt;Update <tt>f</tt> and <tt>v</tt> for next level of subdivision&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">std::vector&lt;SDFace *&gt; newFaces;
std::vector&lt;SDVertex *&gt; newVertices;
&lt;&lt;<span class="fragmentname"><a href="#fragment-Allocatenextlevelofchildreninmeshtree-0">Allocate next level of children in mesh tree</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-442" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-442"><i></i></a><div id="fragbit-442" class="collapse"><div class="fragmentcode">   for (SDVertex *vertex : v) {
       vertex-&gt;child = arena.<a href="../Utilities/Memory_Management.html#MemoryArena::Alloc" class="code">Alloc</a>&lt;SDVertex&gt;();
       vertex-&gt;child-&gt;<a href="#SDVertex::regular" class="code">regular</a> = vertex-&gt;<a href="#SDVertex::regular" class="code">regular</a>;
       vertex-&gt;child-&gt;<a href="#SDVertex::boundary" class="code">boundary</a> = vertex-&gt;<a href="#SDVertex::boundary" class="code">boundary</a>;
       newVertices.push_back(vertex-&gt;child);
   }
   for (SDFace *face : f) {
       for (int k = 0; k &lt; 4; ++k) {
           face-&gt;<a href="#SDFace::children" class="code">children</a>[k] = arena.<a href="../Utilities/Memory_Management.html#MemoryArena::Alloc" class="code">Alloc</a>&lt;SDFace&gt;();
           newFaces.push_back(face-&gt;<a href="#SDFace::children" class="code">children</a>[k]);
       }
   }</div></div>
&lt;&lt;<span class="fragmentname"><a href="#fragment-Updatevertexpositionsandcreatenewedgevertices-0">Update vertex positions and create new edge vertices</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-443" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-443"><i></i></a><div id="fragbit-443" class="collapse"><div class="fragmentcode">   &lt;&lt;<span class="fragmentname"><a href="#fragment-Updatevertexpositionsforevenvertices-0">Update vertex positions for even vertices</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-444" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-444"><i></i></a><div id="fragbit-444" class="collapse"><div class="fragmentcode">      for (SDVertex *vertex : v) {
          if (!vertex-&gt;<a href="#SDVertex::boundary" class="code">boundary</a>) {
              &lt;&lt;<span class="fragmentname"><a href="#fragment-Applyone-ringruleforevenvertex-0">Apply one-ring rule for even vertex</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-445" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-445"><i></i></a><div id="fragbit-445" class="collapse"><div class="fragmentcode">                 if (vertex-&gt;<a href="#SDVertex::regular" class="code">regular</a>)
                     vertex-&gt;<a href="#SDVertex::child" class="code">child</a>-&gt;<a href="#SDVertex::p" class="code">p</a> = <a href="#LoopSubdiv::weightOneRing" class="code">weightOneRing</a>(vertex, 1.f / 16.f);
                 else
                     vertex-&gt;<a href="#SDVertex::child" class="code">child</a>-&gt;<a href="#SDVertex::p" class="code">p</a> = <a href="#LoopSubdiv::weightOneRing" class="code">weightOneRing</a>(vertex, <a href="#LoopSubdiv::beta" class="code">beta</a>(vertex-&gt;<a href="#SDVertex::valence" class="code">valence</a>()));</div></div>
          } else {
              &lt;&lt;<span class="fragmentname"><a href="#fragment-Applyboundaryruleforevenvertex-0">Apply boundary rule for even vertex</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-446" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-446"><i></i></a><div id="fragbit-446" class="collapse"><div class="fragmentcode">                 vertex-&gt;<a href="#SDVertex::child" class="code">child</a>-&gt;<a href="#SDVertex::p" class="code">p</a> = <a href="#LoopSubdiv::weightBoundary" class="code">weightBoundary</a>(vertex, 1.f / 8.f);</div></div>
          }
      }</div></div>
   &lt;&lt;<span class="fragmentname"><a href="#fragment-Computenewoddedgevertices-0">Compute new odd edge vertices</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-447" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-447"><i></i></a><div id="fragbit-447" class="collapse"><div class="fragmentcode">      std::map&lt;SDEdge, SDVertex *&gt; edgeVerts;
      for (SDFace *face : f) {
          for (int k = 0; k &lt; 3; ++k) {
              &lt;&lt;<span class="fragmentname"><a href="#fragment-Computeoddvertexonmonokthedge-0">Compute odd vertex on <tt>k</tt>th edge</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-448" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-448"><i></i></a><div id="fragbit-448" class="collapse"><div class="fragmentcode">                 SDEdge edge(face-&gt;<a href="#SDFace::v" class="code">v</a>[k], face-&gt;<a href="#SDFace::v" class="code">v</a>[<a href="#NEXT" class="code">NEXT</a>(k)]);
                 SDVertex *vert = edgeVerts[edge];
                 if (!vert) {
                     &lt;&lt;<span class="fragmentname"><a href="#fragment-Createandinitializenewoddvertex-0">Create and initialize new odd vertex</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-449" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-449"><i></i></a><div id="fragbit-449" class="collapse"><div class="fragmentcode">                        vert = arena.<a href="../Utilities/Memory_Management.html#MemoryArena::Alloc" class="code">Alloc</a>&lt;SDVertex&gt;();
                        newVertices.push_back(vert);
                        vert-&gt;<a href="#SDVertex::regular" class="code">regular</a> = true;
                        vert-&gt;<a href="#SDVertex::boundary" class="code">boundary</a> = (face-&gt;<a href="#SDFace::f" class="code">f</a>[k] == nullptr);
                        vert-&gt;<a href="#SDVertex::startFace" class="code">startFace</a> = face-&gt;<a href="#SDFace::children" class="code">children</a>[3];</div></div>
                     &lt;&lt;<span class="fragmentname"><a href="#fragment-Applyedgerulestocomputenewvertexposition-0">Apply edge rules to compute new vertex position</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-450" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-450"><i></i></a><div id="fragbit-450" class="collapse"><div class="fragmentcode">                        if (vert-&gt;<a href="#SDVertex::boundary" class="code">boundary</a>) {
                            vert-&gt;<a href="#SDVertex::p" class="code">p</a> =  0.5f * edge.<a href="#SDEdge::v" class="code">v</a>[0]-&gt;<a href="#SDVertex::p" class="code">p</a>;
                            vert-&gt;<a href="#SDVertex::p" class="code">p</a> += 0.5f * edge.<a href="#SDEdge::v" class="code">v</a>[1]-&gt;<a href="#SDVertex::p" class="code">p</a>;
                        } else {
                            vert-&gt;<a href="#SDVertex::p" class="code">p</a> =  3.f/8.f * edge.<a href="#SDEdge::v" class="code">v</a>[0]-&gt;<a href="#SDVertex::p" class="code">p</a>;
                            vert-&gt;<a href="#SDVertex::p" class="code">p</a> += 3.f/8.f * edge.<a href="#SDEdge::v" class="code">v</a>[1]-&gt;<a href="#SDVertex::p" class="code">p</a>;
                            vert-&gt;<a href="#SDVertex::p" class="code">p</a> += 1.f/8.f * face-&gt;<a href="#SDFace::otherVert" class="code">otherVert</a>(edge.<a href="#SDEdge::v" class="code">v</a>[0], edge.<a href="#SDEdge::v" class="code">v</a>[1])-&gt;<a href="#SDVertex::p" class="code">p</a>;
                            vert-&gt;<a href="#SDVertex::p" class="code">p</a> += 1.f/8.f *
                                face-&gt;f[k]-&gt;<a href="#SDFace::otherVert" class="code">otherVert</a>(edge.<a href="#SDEdge::v" class="code">v</a>[0], edge.<a href="#SDEdge::v" class="code">v</a>[1])-&gt;<a href="#SDVertex::p" class="code">p</a>;
                        }</div></div>
                     edgeVerts[edge] = vert;
                 }</div></div>
          }
      }</div></div></div></div>
&lt;&lt;<span class="fragmentname"><a href="#fragment-Updatenewmeshtopology-0">Update new mesh topology</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-451" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-451"><i></i></a><div id="fragbit-451" class="collapse"><div class="fragmentcode">   &lt;&lt;<span class="fragmentname"><a href="#fragment-Updateevenvertexfacepointers-0">Update even vertex face pointers</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-452" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-452"><i></i></a><div id="fragbit-452" class="collapse"><div class="fragmentcode">      for (SDVertex *vertex : v) {
          int vertNum = vertex-&gt;<a href="#SDVertex::startFace" class="code">startFace</a>-&gt;<a href="#SDFace::vnum" class="code">vnum</a>(vertex);
          vertex-&gt;child-&gt;<a href="#SDVertex::startFace" class="code">startFace</a> = 
              vertex-&gt;<a href="#SDVertex::startFace" class="code">startFace</a>-&gt;<a href="#SDFace::children" class="code">children</a>[vertNum];
      }</div></div>
   &lt;&lt;<span class="fragmentname"><a href="#fragment-Updatefaceneighborpointers-0">Update face neighbor pointers</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-453" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-453"><i></i></a><div id="fragbit-453" class="collapse"><div class="fragmentcode">      for (SDFace *face : f) {
          for (int j = 0; j &lt; 3; ++j) {
              &lt;&lt;<span class="fragmentname"><a href="#fragment-Updatechildrenmonofpointersforsiblings-0">Update children <tt>f</tt> pointers for siblings</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-454" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-454"><i></i></a><div id="fragbit-454" class="collapse"><div class="fragmentcode">                 face-&gt;<a href="#SDFace::children" class="code">children</a>[3]-&gt;<a href="#SDFace::f" class="code">f</a>[j] = face-&gt;<a href="#SDFace::children" class="code">children</a>[<a href="#NEXT" class="code">NEXT</a>(j)];
                 face-&gt;<a href="#SDFace::children" class="code">children</a>[j]-&gt;<a href="#SDFace::f" class="code">f</a>[<a href="#NEXT" class="code">NEXT</a>(j)] = face-&gt;<a href="#SDFace::children" class="code">children</a>[3];</div></div>
              &lt;&lt;<span class="fragmentname"><a href="#fragment-Updatechildrenmonofpointersforneighborchildren-0">Update children <tt>f</tt> pointers for neighbor children</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-455" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-455"><i></i></a><div id="fragbit-455" class="collapse"><div class="fragmentcode">                 SDFace *f2 = face-&gt;<a href="#SDFace::f" class="code">f</a>[j];
                 face-&gt;<a href="#SDFace::children" class="code">children</a>[j]-&gt;<a href="#SDFace::f" class="code">f</a>[j] =
                     f2 ? f2-&gt;<a href="#SDFace::children" class="code">children</a>[f2-&gt;<a href="#SDFace::vnum" class="code">vnum</a>(face-&gt;v[j])] : nullptr;
                 f2 = face-&gt;<a href="#SDFace::f" class="code">f</a>[<a href="#PREV" class="code">PREV</a>(j)];
                 face-&gt;<a href="#SDFace::children" class="code">children</a>[j]-&gt;<a href="#SDFace::f" class="code">f</a>[<a href="#PREV" class="code">PREV</a>(j)] = 
                     f2 ? f2-&gt;<a href="#SDFace::children" class="code">children</a>[f2-&gt;<a href="#SDFace::vnum" class="code">vnum</a>(face-&gt;v[j])] : nullptr;</div></div>
          }
      }</div></div>
   &lt;&lt;<span class="fragmentname"><a href="#fragment-Updatefacevertexpointers-0">Update face vertex pointers</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-456" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-456"><i></i></a><div id="fragbit-456" class="collapse"><div class="fragmentcode">      for (SDFace *face : f) {
          for (int j = 0; j &lt; 3; ++j) {
              &lt;&lt;<span class="fragmentname"><a href="#fragment-Updatechildvertexpointertonewevenvertex-0">Update child vertex pointer to new even vertex</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-457" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-457"><i></i></a><div id="fragbit-457" class="collapse"><div class="fragmentcode">                 face-&gt;<a href="#SDFace::children" class="code">children</a>[j]-&gt;<a href="#SDFace::v" class="code">v</a>[j] = face-&gt;<a href="#SDFace::v" class="code">v</a>[j]-&gt;<a href="#SDVertex::child" class="code">child</a>;</div></div>
              &lt;&lt;<span class="fragmentname"><a href="#fragment-Updatechildvertexpointertonewoddvertex-0">Update child vertex pointer to new odd vertex</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-458" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-458"><i></i></a><div id="fragbit-458" class="collapse"><div class="fragmentcode">                 SDVertex *vert = edgeVerts[SDEdge(face-&gt;<a href="#SDFace::v" class="code">v</a>[j], face-&gt;<a href="#SDFace::v" class="code">v</a>[<a href="#NEXT" class="code">NEXT</a>(j)])];
                 face-&gt;<a href="#SDFace::children" class="code">children</a>[j]-&gt;<a href="#SDFace::v" class="code">v</a>[<a href="#NEXT" class="code">NEXT</a>(j)] = vert;
                 face-&gt;<a href="#SDFace::children" class="code">children</a>[<a href="#NEXT" class="code">NEXT</a>(j)]-&gt;<a href="#SDFace::v" class="code">v</a>[j] = vert;
                 face-&gt;<a href="#SDFace::children" class="code">children</a>[3]-&gt;<a href="#SDFace::v" class="code">v</a>[j] = vert;</div></div>
          }
      }</div></div></div></div>
&lt;&lt;<span class="fragmentname"><a href="#fragment-Preparefornextlevelofsubdivision-0">Prepare for next level of subdivision</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-459" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-459"><i></i></a><div id="fragbit-459" class="collapse"><div class="fragmentcode">   f = newFaces;
   v = newVertices;</div></div></div><p>


</p>
<p>First, storage is allocated for the updated values of the vertices already
present in the
input mesh.  The method also allocates storage for the child faces.  It
doesn&rsquo;t yet do any initialization of the new vertices and faces other than
setting the <tt>regular</tt> and <tt>boundary</tt> flags for the vertices since
subdivision leaves boundary vertices on the boundary and interior vertices
in the interior and it doesn&rsquo;t change the valence of vertices in the mesh.

</p>
<p></p>
<span class="anchor" id="fragment-Allocatenextlevelofchildreninmeshtree-0"></span><div class="fragmentname">&lt;&lt;Allocate next level of children in mesh tree&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">for (SDVertex *vertex : v) {
    vertex-&gt;child = arena.<a href="../Utilities/Memory_Management.html#MemoryArena::Alloc" class="code">Alloc</a>&lt;SDVertex&gt;();
    vertex-&gt;child-&gt;<a href="#SDVertex::regular" class="code">regular</a> = vertex-&gt;<a href="#SDVertex::regular" class="code">regular</a>;
    vertex-&gt;child-&gt;<a href="#SDVertex::boundary" class="code">boundary</a> = vertex-&gt;<a href="#SDVertex::boundary" class="code">boundary</a>;
    newVertices.push_back(vertex-&gt;child);
}
for (SDFace *face : f) {
    for (int k = 0; k &lt; 4; ++k) {
        face-&gt;<a href="#SDFace::children" class="code">children</a>[k] = arena.<a href="../Utilities/Memory_Management.html#MemoryArena::Alloc" class="code">Alloc</a>&lt;SDFace&gt;();
        newFaces.push_back(face-&gt;<a href="#SDFace::children" class="code">children</a>[k]);
    }
}</div><p>


</p>
<p>

</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#x2-ComputingNewVertexPositions"><i class="fas fa-link h3h4marginlink"></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span id="x2-ComputingNewVertexPositions"></span><h4>Computing New Vertex Positions</h4><p>


</p>
<p>Before worrying about initializing the topology of the subdivided mesh, the
refinement method computes positions for all of the vertices in the mesh.
First, it considers the problem of computing updated positions for all
of the vertices that were already present in the mesh; these vertices are
called <em>even vertices</em>.  It then computes the new vertices on the
split edges. These are called <em>odd vertices.</em>

</p>
<p></p>
<span class="anchor" id="fragment-Updatevertexpositionsandcreatenewedgevertices-0"></span><div class="fragmentname">&lt;&lt;Update vertex positions and create new edge vertices&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">&lt;&lt;<span class="fragmentname"><a href="#fragment-Updatevertexpositionsforevenvertices-0">Update vertex positions for even vertices</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-460" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-460"><i></i></a><div id="fragbit-460" class="collapse"><div class="fragmentcode">   for (SDVertex *vertex : v) {
       if (!vertex-&gt;<a href="#SDVertex::boundary" class="code">boundary</a>) {
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Applyone-ringruleforevenvertex-0">Apply one-ring rule for even vertex</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-461" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-461"><i></i></a><div id="fragbit-461" class="collapse"><div class="fragmentcode">              if (vertex-&gt;<a href="#SDVertex::regular" class="code">regular</a>)
                  vertex-&gt;<a href="#SDVertex::child" class="code">child</a>-&gt;<a href="#SDVertex::p" class="code">p</a> = <a href="#LoopSubdiv::weightOneRing" class="code">weightOneRing</a>(vertex, 1.f / 16.f);
              else
                  vertex-&gt;<a href="#SDVertex::child" class="code">child</a>-&gt;<a href="#SDVertex::p" class="code">p</a> = <a href="#LoopSubdiv::weightOneRing" class="code">weightOneRing</a>(vertex, <a href="#LoopSubdiv::beta" class="code">beta</a>(vertex-&gt;<a href="#SDVertex::valence" class="code">valence</a>()));</div></div>
       } else {
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Applyboundaryruleforevenvertex-0">Apply boundary rule for even vertex</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-462" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-462"><i></i></a><div id="fragbit-462" class="collapse"><div class="fragmentcode">              vertex-&gt;<a href="#SDVertex::child" class="code">child</a>-&gt;<a href="#SDVertex::p" class="code">p</a> = <a href="#LoopSubdiv::weightBoundary" class="code">weightBoundary</a>(vertex, 1.f / 8.f);</div></div>
       }
   }</div></div>
&lt;&lt;<span class="fragmentname"><a href="#fragment-Computenewoddedgevertices-0">Compute new odd edge vertices</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-463" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-463"><i></i></a><div id="fragbit-463" class="collapse"><div class="fragmentcode">   std::map&lt;SDEdge, SDVertex *&gt; edgeVerts;
   for (SDFace *face : f) {
       for (int k = 0; k &lt; 3; ++k) {
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Computeoddvertexonmonokthedge-0">Compute odd vertex on <tt>k</tt>th edge</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-464" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-464"><i></i></a><div id="fragbit-464" class="collapse"><div class="fragmentcode">              SDEdge edge(face-&gt;<a href="#SDFace::v" class="code">v</a>[k], face-&gt;<a href="#SDFace::v" class="code">v</a>[<a href="#NEXT" class="code">NEXT</a>(k)]);
              SDVertex *vert = edgeVerts[edge];
              if (!vert) {
                  &lt;&lt;<span class="fragmentname"><a href="#fragment-Createandinitializenewoddvertex-0">Create and initialize new odd vertex</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-465" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-465"><i></i></a><div id="fragbit-465" class="collapse"><div class="fragmentcode">                     vert = arena.<a href="../Utilities/Memory_Management.html#MemoryArena::Alloc" class="code">Alloc</a>&lt;SDVertex&gt;();
                     newVertices.push_back(vert);
                     vert-&gt;<a href="#SDVertex::regular" class="code">regular</a> = true;
                     vert-&gt;<a href="#SDVertex::boundary" class="code">boundary</a> = (face-&gt;<a href="#SDFace::f" class="code">f</a>[k] == nullptr);
                     vert-&gt;<a href="#SDVertex::startFace" class="code">startFace</a> = face-&gt;<a href="#SDFace::children" class="code">children</a>[3];</div></div>
                  &lt;&lt;<span class="fragmentname"><a href="#fragment-Applyedgerulestocomputenewvertexposition-0">Apply edge rules to compute new vertex position</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-466" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-466"><i></i></a><div id="fragbit-466" class="collapse"><div class="fragmentcode">                     if (vert-&gt;<a href="#SDVertex::boundary" class="code">boundary</a>) {
                         vert-&gt;<a href="#SDVertex::p" class="code">p</a> =  0.5f * edge.<a href="#SDEdge::v" class="code">v</a>[0]-&gt;<a href="#SDVertex::p" class="code">p</a>;
                         vert-&gt;<a href="#SDVertex::p" class="code">p</a> += 0.5f * edge.<a href="#SDEdge::v" class="code">v</a>[1]-&gt;<a href="#SDVertex::p" class="code">p</a>;
                     } else {
                         vert-&gt;<a href="#SDVertex::p" class="code">p</a> =  3.f/8.f * edge.<a href="#SDEdge::v" class="code">v</a>[0]-&gt;<a href="#SDVertex::p" class="code">p</a>;
                         vert-&gt;<a href="#SDVertex::p" class="code">p</a> += 3.f/8.f * edge.<a href="#SDEdge::v" class="code">v</a>[1]-&gt;<a href="#SDVertex::p" class="code">p</a>;
                         vert-&gt;<a href="#SDVertex::p" class="code">p</a> += 1.f/8.f * face-&gt;<a href="#SDFace::otherVert" class="code">otherVert</a>(edge.<a href="#SDEdge::v" class="code">v</a>[0], edge.<a href="#SDEdge::v" class="code">v</a>[1])-&gt;<a href="#SDVertex::p" class="code">p</a>;
                         vert-&gt;<a href="#SDVertex::p" class="code">p</a> += 1.f/8.f *
                             face-&gt;f[k]-&gt;<a href="#SDFace::otherVert" class="code">otherVert</a>(edge.<a href="#SDEdge::v" class="code">v</a>[0], edge.<a href="#SDEdge::v" class="code">v</a>[1])-&gt;<a href="#SDVertex::p" class="code">p</a>;
                     }</div></div>
                  edgeVerts[edge] = vert;
              }</div></div>
       }
   }</div></div></div><p>


</p>
<p>Different techniques are used to compute the updated positions for each of the
different types of even vertices&mdash;regular and extraordinary, boundary and
interior.  This gives four cases to handle.

</p>
<p></p>
<span class="anchor" id="fragment-Updatevertexpositionsforevenvertices-0"></span><div class="fragmentname">&lt;&lt;Update vertex positions for even vertices&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">for (SDVertex *vertex : v) {
    if (!vertex-&gt;<a href="#SDVertex::boundary" class="code">boundary</a>) {
        &lt;&lt;<span class="fragmentname"><a href="#fragment-Applyone-ringruleforevenvertex-0">Apply one-ring rule for even vertex</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-467" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-467"><i></i></a><div id="fragbit-467" class="collapse"><div class="fragmentcode">           if (vertex-&gt;<a href="#SDVertex::regular" class="code">regular</a>)
               vertex-&gt;<a href="#SDVertex::child" class="code">child</a>-&gt;<a href="#SDVertex::p" class="code">p</a> = <a href="#LoopSubdiv::weightOneRing" class="code">weightOneRing</a>(vertex, 1.f / 16.f);
           else
               vertex-&gt;<a href="#SDVertex::child" class="code">child</a>-&gt;<a href="#SDVertex::p" class="code">p</a> = <a href="#LoopSubdiv::weightOneRing" class="code">weightOneRing</a>(vertex, <a href="#LoopSubdiv::beta" class="code">beta</a>(vertex-&gt;<a href="#SDVertex::valence" class="code">valence</a>()));</div></div>
    } else {
        &lt;&lt;<span class="fragmentname"><a href="#fragment-Applyboundaryruleforevenvertex-0">Apply boundary rule for even vertex</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-468" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-468"><i></i></a><div id="fragbit-468" class="collapse"><div class="fragmentcode">           vertex-&gt;<a href="#SDVertex::child" class="code">child</a>-&gt;<a href="#SDVertex::p" class="code">p</a> = <a href="#LoopSubdiv::weightBoundary" class="code">weightBoundary</a>(vertex, 1.f / 8.f);</div></div>
    }
}</div><p>

For both types of interior vertices, we take the set of vertices adjacent to
each vertex (called the <em>one-ring</em> around it, reflecting the fact that
it&rsquo;s a ring of neighbors) and weight each of the neighbor vertices by a
weight <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.334ex" height="2.509ex" style="vertical-align: -0.671ex;" viewBox="0 -791.3 574.5 1080.4" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">beta</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D6FD" d="M574 574c0 -12 -2 -24 -5 -37c-11 -45 -41 -86 -81 -116c-10 -8 -20 -14 -30 -20c17 -11 31 -26 43 -43c20 -31 30 -68 30 -108c0 -20 -3 -42 -8 -64c-14 -53 -51 -104 -99 -140c-52 -38 -113 -57 -170 -57c-68 0 -114 40 -131 98l-68 -274c-1 -4 -5 -7 -10 -7h-5 c-6 0 -10 4 -10 12l154 615c34 136 125 273 245 273c47 0 89 -18 116 -50c18 -22 29 -51 29 -82zM518 592c0 19 -3 36 -12 51c-16 26 -44 40 -78 40c-110 0 -188 -129 -220 -255l-60 -242c-4 -17 -6 -33 -6 -49c0 -71 41 -126 113 -126c44 0 91 19 129 52 c39 35 61 82 73 128c7 29 12 59 12 87c0 25 -4 48 -14 69c-7 16 -17 29 -30 39c-25 -9 -50 -13 -75 -13c-35 0 -76 0 -76 24c0 0 0 5 1 7c7 27 49 27 85 27c24 0 47 -5 67 -13c9 5 18 12 26 19c31 29 49 67 58 105c5 17 7 34 7 50zM395 403c-11 3 -23 5 -36 5 c-24 0 -57 0 -60 -9c-1 -4 30 -4 52 -4c14 0 29 3 44 8Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D6FD" x="0" y="0"></use>
</g>
</svg>
(Figure&nbsp;<a href="#fig:loop-onering">3.33</a>).  The vertex we are updating, in the
center, is weighted by <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="6.732ex" height="2.509ex" style="vertical-align: -0.671ex;" viewBox="0 -791.3 2898.4 1080.4" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">1 minus n beta</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2212" d="M722 250c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D45B" d="M571 143c0 -8 -37 -154 -131 -154c-47 0 -82 35 -82 82c0 11 1 23 10 46c16 43 65 171 65 233c0 33 -9 70 -54 70c-95 0 -148 -91 -163 -122l-13 -50c-5 -23 -11 -45 -17 -67l-22 -90c-6 -25 -18 -72 -19 -74c-7 -20 -25 -28 -37 -28c-15 0 -29 9 -29 27c0 5 6 28 9 43 l58 231c13 52 16 63 16 84c0 33 -11 46 -31 46c-36 0 -56 -48 -73 -119c-6 -22 -7 -23 -17 -23c0 0 -12 0 -12 10c0 4 14 63 30 97c10 18 29 57 75 57s87 -31 92 -87c17 23 66 87 156 87c72 0 115 -40 115 -107c0 -57 -42 -167 -61 -220c-9 -22 -18 -46 -18 -71 c0 -23 7 -33 24 -33c49 0 82 56 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D6FD" d="M574 574c0 -12 -2 -24 -5 -37c-11 -45 -41 -86 -81 -116c-10 -8 -20 -14 -30 -20c17 -11 31 -26 43 -43c20 -31 30 -68 30 -108c0 -20 -3 -42 -8 -64c-14 -53 -51 -104 -99 -140c-52 -38 -113 -57 -170 -57c-68 0 -114 40 -131 98l-68 -274c-1 -4 -5 -7 -10 -7h-5 c-6 0 -10 4 -10 12l154 615c34 136 125 273 245 273c47 0 89 -18 116 -50c18 -22 29 -51 29 -82zM518 592c0 19 -3 36 -12 51c-16 26 -44 40 -78 40c-110 0 -188 -129 -220 -255l-60 -242c-4 -17 -6 -33 -6 -49c0 -71 41 -126 113 -126c44 0 91 19 129 52 c39 35 61 82 73 128c7 29 12 59 12 87c0 25 -4 48 -14 69c-7 16 -17 29 -30 39c-25 -9 -50 -13 -75 -13c-35 0 -76 0 -76 24c0 0 0 5 1 7c7 27 49 27 85 27c24 0 47 -5 67 -13c9 5 18 12 26 19c31 29 49 67 58 105c5 17 7 34 7 50zM395 403c-11 3 -23 5 -36 5 c-24 0 -57 0 -60 -9c-1 -4 30 -4 52 -4c14 0 29 3 44 8Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-31" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2212" x="722" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D45B" x="1723" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D6FD" x="2323" y="0"></use>
</g>
</svg>, where <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 600.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">n</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D45B" d="M571 143c0 -8 -37 -154 -131 -154c-47 0 -82 35 -82 82c0 11 1 23 10 46c16 43 65 171 65 233c0 33 -9 70 -54 70c-95 0 -148 -91 -163 -122l-13 -50c-5 -23 -11 -45 -17 -67l-22 -90c-6 -25 -18 -72 -19 -74c-7 -20 -25 -28 -37 -28c-15 0 -29 9 -29 27c0 5 6 28 9 43 l58 231c13 52 16 63 16 84c0 33 -11 46 -31 46c-36 0 -56 -48 -73 -119c-6 -22 -7 -23 -17 -23c0 0 -12 0 -12 10c0 4 14 63 30 97c10 18 29 57 75 57s87 -31 92 -87c17 23 66 87 156 87c72 0 115 -40 115 -107c0 -57 -42 -167 -61 -220c-9 -22 -18 -46 -18 -71 c0 -23 7 -33 24 -33c49 0 82 56 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D45B" x="0" y="0"></use>
</g>
</svg> is the valence of the vertex.
Thus, the new position v<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="0.902ex" height="2.176ex" style="vertical-align: -0.171ex;" viewBox="0 -863.1 388.1 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">prime</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNVARIANTS-2032" d="M340 496c0 -10 -3 -20 -8 -28l-227 -372h-38l171 424c6 15 26 29 48 29c30 0 54 -24 54 -53Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNVARIANTS-2032" x="0" y="513"></use>
</g>
</svg> for a vertex v&nbsp;is
</p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">

</div>
<div class="col-md-10 col-lg-8">
<div class="displaymath"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="25.587ex" height="7.343ex" style="vertical-align: -3.005ex;" viewBox="0 -1867.7 11016.6 3161.4" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">normal v prime equals left-parenthesis 1 minus n beta right-parenthesis normal v plus sigma-summation Underscript i equals 1 Overscript upper N Endscripts beta normal v Subscript i Baseline period</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-76" d="M508 400c-66 -1 -83 -44 -92 -67l-131 -325c-4 -10 -8 -19 -21 -19s-15 5 -21 19l-144 355c-13 31 -17 37 -80 37v31c30 -2 70 -3 97 -3l109 3v-31c-18 0 -57 0 -57 -26c0 0 0 -4 6 -17l112 -279l102 255c4 11 6 15 6 24c0 19 -11 42 -48 43v31l87 -3c23 0 52 1 75 3v-31 Z"></path>
<path stroke-width="1" id="E1-LATINMODERNVARIANTS-2032" d="M340 496c0 -10 -3 -20 -8 -28l-227 -372h-38l171 424c6 15 26 29 48 29c30 0 54 -24 54 -53Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-3D" d="M722 347c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20zM722 153c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-28" d="M332 -238c0 -5 -5 -10 -10 -10c-2 0 -4 1 -6 2c-110 83 -215 283 -215 454v84c0 171 105 371 215 454c2 1 4 2 6 2c5 0 10 -5 10 -10c0 -3 -2 -6 -4 -8c-104 -78 -173 -278 -173 -438v-84c0 -160 69 -360 173 -438c2 -2 4 -5 4 -8Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2212" d="M722 250c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D45B" d="M571 143c0 -8 -37 -154 -131 -154c-47 0 -82 35 -82 82c0 11 1 23 10 46c16 43 65 171 65 233c0 33 -9 70 -54 70c-95 0 -148 -91 -163 -122l-13 -50c-5 -23 -11 -45 -17 -67l-22 -90c-6 -25 -18 -72 -19 -74c-7 -20 -25 -28 -37 -28c-15 0 -29 9 -29 27c0 5 6 28 9 43 l58 231c13 52 16 63 16 84c0 33 -11 46 -31 46c-36 0 -56 -48 -73 -119c-6 -22 -7 -23 -17 -23c0 0 -12 0 -12 10c0 4 14 63 30 97c10 18 29 57 75 57s87 -31 92 -87c17 23 66 87 156 87c72 0 115 -40 115 -107c0 -57 -42 -167 -61 -220c-9 -22 -18 -46 -18 -71 c0 -23 7 -33 24 -33c49 0 82 56 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D6FD" d="M574 574c0 -12 -2 -24 -5 -37c-11 -45 -41 -86 -81 -116c-10 -8 -20 -14 -30 -20c17 -11 31 -26 43 -43c20 -31 30 -68 30 -108c0 -20 -3 -42 -8 -64c-14 -53 -51 -104 -99 -140c-52 -38 -113 -57 -170 -57c-68 0 -114 40 -131 98l-68 -274c-1 -4 -5 -7 -10 -7h-5 c-6 0 -10 4 -10 12l154 615c34 136 125 273 245 273c47 0 89 -18 116 -50c18 -22 29 -51 29 -82zM518 592c0 19 -3 36 -12 51c-16 26 -44 40 -78 40c-110 0 -188 -129 -220 -255l-60 -242c-4 -17 -6 -33 -6 -49c0 -71 41 -126 113 -126c44 0 91 19 129 52 c39 35 61 82 73 128c7 29 12 59 12 87c0 25 -4 48 -14 69c-7 16 -17 29 -30 39c-25 -9 -50 -13 -75 -13c-35 0 -76 0 -76 24c0 0 0 5 1 7c7 27 49 27 85 27c24 0 47 -5 67 -13c9 5 18 12 26 19c31 29 49 67 58 105c5 17 7 34 7 50zM395 403c-11 3 -23 5 -36 5 c-24 0 -57 0 -60 -9c-1 -4 30 -4 52 -4c14 0 29 3 44 8Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-29" d="M288 208c0 -171 -105 -371 -215 -454c-2 -1 -4 -2 -6 -2c-5 0 -10 5 -10 10c0 3 2 6 4 8c104 78 173 278 173 438v84c0 160 -69 360 -173 438c-2 2 -4 5 -4 8c0 5 5 10 10 10c2 0 4 -1 6 -2c110 -83 215 -283 215 -454v-84Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2B" d="M722 250c0 -11 -9 -20 -20 -20h-293v-293c0 -11 -9 -20 -20 -20s-20 9 -20 20v293h-293c-11 0 -20 9 -20 20s9 20 20 20h293v293c0 11 9 20 20 20s20 -9 20 -20v-293h293c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNSIZE1-2211" d="M1387 -130l-121 -320h-1182c-18 0 -27 0 -27 11c0 0 0 6 10 18l518 607l-529 724c0 11 0 30 1 33c3 6 4 7 27 7h1182l121 -281h-25c-34 81 -102 126 -127 142c-79 50 -166 67 -220 75c-9 2 -100 16 -234 16h-548l466 -637c7 -10 7 -15 7 -15c0 -5 -2 -8 -9 -16l-509 -597 h603c192 0 290 26 311 31c115 30 221 98 260 202h25Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D456" d="M284 625c0 -30 -30 -53 -53 -53c-24 0 -38 17 -38 36c0 27 27 53 54 53c23 0 37 -16 37 -36zM293 143c0 -9 -37 -154 -131 -154c-48 0 -82 35 -82 82c0 21 13 54 23 80c16 43 61 159 69 185c4 10 11 31 11 52c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124 c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 38 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -13 -53c-10 -27 -10 -29 -22 -58l-39 -105c-23 -61 -29 -75 -29 -100c0 -23 7 -33 24 -33c51 0 84 61 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D441" d="M881 672c0 -19 -12 -20 -17 -20c-80 -3 -98 -34 -108 -74l-140 -557c-5 -18 -5 -21 -16 -21c-9 0 -12 2 -19 19l-249 589c-5 10 -5 12 -9 18l-132 -528c-3 -11 -4 -16 -4 -23c0 -20 8 -42 66 -44c11 0 20 -1 20 -11c0 -20 -13 -20 -18 -20c-33 0 -69 3 -103 3 c-33 0 -68 -3 -100 -3c-8 0 -13 4 -13 11c0 19 11 20 17 20c81 3 98 35 108 75l134 537c0 9 -63 9 -68 9c-19 0 -28 0 -28 11c0 20 9 20 29 20h134c23 0 24 -1 32 -19l221 -522l112 445c1 3 3 18 3 21c0 22 -11 43 -68 44c-8 0 -18 0 -18 11c0 20 12 20 18 20 c33 0 68 -3 102 -3c33 0 68 3 101 3c13 0 13 -11 13 -11Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2E" d="M192 53c0 -29 -24 -53 -53 -53s-53 24 -53 53s24 53 53 53s53 -24 53 -53Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-76" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNVARIANTS-2032" x="747" y="583"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-3D" x="1194" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-28" x="2250" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-31" x="2640" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2212" x="3362" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D45B" x="4363" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D6FD" x="4964" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-29" x="5538" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-76" x="5928" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2B" x="6678" y="0"></use>
<g transform="translate(7679,0)">
 <use xlink:href="#E1-LATINMODERNSIZE1-2211" x="0" y="0"></use>
<g transform="translate(147,-1090)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D456" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-3D" x="345" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-31" x="1124" y="0"></use>
</g>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D441" x="580" y="1627"></use>
</g>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D6FD" x="9290" y="0"></use>
<g transform="translate(9865,0)">
 <use xlink:href="#E1-LATINMODERNMAIN-76" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D456" x="747" y="-213"></use>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-2E" x="10738" y="0"></use>
</g>
</svg>
</div>
<p>


</p>
<p> This formulation ensures that the sum of weights is one, which 
guarantees the convex hull property
of Loop subdivision surfaces, which ensures that the final
mesh is in the convex hull of the control mesh.
The position of the vertex being updated is only affected by vertices that
are nearby; this is known as <em>local support</em>.
Loop subdivision is particularly efficient because its
subdivision rules all have this property.

</p>
<p>
</p>
<span class="anchor" id="fig:loop-onering"></span><div class="card outerfigure"><div class="card-body figure"><p>



</p>
<div class="figure-row">
  <a href="Subdiv%20one%20ring%20weighting.svg" title=""><img src="Subdiv%20one%20ring%20weighting.svg" width=229 height=272 style="max-width: 100%;"></a>
</div>
<p>


</p>
<figcaption class="caption">Figure 3.33: <span class="legend"> The new position v<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="0.902ex" height="2.176ex" style="vertical-align: -0.171ex;" viewBox="0 -863.1 388.1 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">prime</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNVARIANTS-2032" d="M340 496c0 -10 -3 -20 -8 -28l-227 -372h-38l171 424c6 15 26 29 48 29c30 0 54 -24 54 -53Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNVARIANTS-2032" x="0" y="513"></use>
</g>
</svg> for a vertex v is
computed by weighting the adjacent vertices v<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="0.8ex" height="1.676ex" style="vertical-align: -0.671ex;" viewBox="0 -432.6 344.3 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">Subscript i</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D456" d="M284 625c0 -30 -30 -53 -53 -53c-24 0 -38 17 -38 36c0 27 27 53 54 53c23 0 37 -16 37 -36zM293 143c0 -9 -37 -154 -131 -154c-48 0 -82 35 -82 82c0 21 13 54 23 80c16 43 61 159 69 185c4 10 11 31 11 52c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124 c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 38 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -13 -53c-10 -27 -10 -29 -22 -58l-39 -105c-23 -61 -29 -75 -29 -100c0 -23 7 -33 24 -33c51 0 84 61 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D456" x="0" y="-213"></use>
</g>
</svg> by a weight <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.334ex" height="2.509ex" style="vertical-align: -0.671ex;" viewBox="0 -791.3 574.5 1080.4" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">beta</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D6FD" d="M574 574c0 -12 -2 -24 -5 -37c-11 -45 -41 -86 -81 -116c-10 -8 -20 -14 -30 -20c17 -11 31 -26 43 -43c20 -31 30 -68 30 -108c0 -20 -3 -42 -8 -64c-14 -53 -51 -104 -99 -140c-52 -38 -113 -57 -170 -57c-68 0 -114 40 -131 98l-68 -274c-1 -4 -5 -7 -10 -7h-5 c-6 0 -10 4 -10 12l154 615c34 136 125 273 245 273c47 0 89 -18 116 -50c18 -22 29 -51 29 -82zM518 592c0 19 -3 36 -12 51c-16 26 -44 40 -78 40c-110 0 -188 -129 -220 -255l-60 -242c-4 -17 -6 -33 -6 -49c0 -71 41 -126 113 -126c44 0 91 19 129 52 c39 35 61 82 73 128c7 29 12 59 12 87c0 25 -4 48 -14 69c-7 16 -17 29 -30 39c-25 -9 -50 -13 -75 -13c-35 0 -76 0 -76 24c0 0 0 5 1 7c7 27 49 27 85 27c24 0 47 -5 67 -13c9 5 18 12 26 19c31 29 49 67 58 105c5 17 7 34 7 50zM395 403c-11 3 -23 5 -36 5 c-24 0 -57 0 -60 -9c-1 -4 30 -4 52 -4c14 0 29 3 44 8Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D6FD" x="0" y="0"></use>
</g>
</svg> and
weighting v by <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="8.541ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 3677.4 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">left-parenthesis 1 minus n beta right-parenthesis</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-28" d="M332 -238c0 -5 -5 -10 -10 -10c-2 0 -4 1 -6 2c-110 83 -215 283 -215 454v84c0 171 105 371 215 454c2 1 4 2 6 2c5 0 10 -5 10 -10c0 -3 -2 -6 -4 -8c-104 -78 -173 -278 -173 -438v-84c0 -160 69 -360 173 -438c2 -2 4 -5 4 -8Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2212" d="M722 250c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D45B" d="M571 143c0 -8 -37 -154 -131 -154c-47 0 -82 35 -82 82c0 11 1 23 10 46c16 43 65 171 65 233c0 33 -9 70 -54 70c-95 0 -148 -91 -163 -122l-13 -50c-5 -23 -11 -45 -17 -67l-22 -90c-6 -25 -18 -72 -19 -74c-7 -20 -25 -28 -37 -28c-15 0 -29 9 -29 27c0 5 6 28 9 43 l58 231c13 52 16 63 16 84c0 33 -11 46 -31 46c-36 0 -56 -48 -73 -119c-6 -22 -7 -23 -17 -23c0 0 -12 0 -12 10c0 4 14 63 30 97c10 18 29 57 75 57s87 -31 92 -87c17 23 66 87 156 87c72 0 115 -40 115 -107c0 -57 -42 -167 -61 -220c-9 -22 -18 -46 -18 -71 c0 -23 7 -33 24 -33c49 0 82 56 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D6FD" d="M574 574c0 -12 -2 -24 -5 -37c-11 -45 -41 -86 -81 -116c-10 -8 -20 -14 -30 -20c17 -11 31 -26 43 -43c20 -31 30 -68 30 -108c0 -20 -3 -42 -8 -64c-14 -53 -51 -104 -99 -140c-52 -38 -113 -57 -170 -57c-68 0 -114 40 -131 98l-68 -274c-1 -4 -5 -7 -10 -7h-5 c-6 0 -10 4 -10 12l154 615c34 136 125 273 245 273c47 0 89 -18 116 -50c18 -22 29 -51 29 -82zM518 592c0 19 -3 36 -12 51c-16 26 -44 40 -78 40c-110 0 -188 -129 -220 -255l-60 -242c-4 -17 -6 -33 -6 -49c0 -71 41 -126 113 -126c44 0 91 19 129 52 c39 35 61 82 73 128c7 29 12 59 12 87c0 25 -4 48 -14 69c-7 16 -17 29 -30 39c-25 -9 -50 -13 -75 -13c-35 0 -76 0 -76 24c0 0 0 5 1 7c7 27 49 27 85 27c24 0 47 -5 67 -13c9 5 18 12 26 19c31 29 49 67 58 105c5 17 7 34 7 50zM395 403c-11 3 -23 5 -36 5 c-24 0 -57 0 -60 -9c-1 -4 30 -4 52 -4c14 0 29 3 44 8Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-29" d="M288 208c0 -171 -105 -371 -215 -454c-2 -1 -4 -2 -6 -2c-5 0 -10 5 -10 10c0 3 2 6 4 8c104 78 173 278 173 438v84c0 160 -69 360 -173 438c-2 2 -4 5 -4 8c0 5 5 10 10 10c2 0 4 -1 6 -2c110 -83 215 -283 215 -454v-84Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-28" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-31" x="389" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2212" x="1112" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D45B" x="2112" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D6FD" x="2713" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-29" x="3287" y="0"></use>
</g>
</svg>, where <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 600.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">n</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D45B" d="M571 143c0 -8 -37 -154 -131 -154c-47 0 -82 35 -82 82c0 11 1 23 10 46c16 43 65 171 65 233c0 33 -9 70 -54 70c-95 0 -148 -91 -163 -122l-13 -50c-5 -23 -11 -45 -17 -67l-22 -90c-6 -25 -18 -72 -19 -74c-7 -20 -25 -28 -37 -28c-15 0 -29 9 -29 27c0 5 6 28 9 43 l58 231c13 52 16 63 16 84c0 33 -11 46 -31 46c-36 0 -56 -48 -73 -119c-6 -22 -7 -23 -17 -23c0 0 -12 0 -12 10c0 4 14 63 30 97c10 18 29 57 75 57s87 -31 92 -87c17 23 66 87 156 87c72 0 115 -40 115 -107c0 -57 -42 -167 -61 -220c-9 -22 -18 -46 -18 -71 c0 -23 7 -33 24 -33c49 0 82 56 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D45B" x="0" y="0"></use>
</g>
</svg> is the valence of v.  The adjacent
vertices v<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="0.8ex" height="1.676ex" style="vertical-align: -0.671ex;" viewBox="0 -432.6 344.3 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">Subscript i</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D456" d="M284 625c0 -30 -30 -53 -53 -53c-24 0 -38 17 -38 36c0 27 27 53 54 53c23 0 37 -16 37 -36zM293 143c0 -9 -37 -154 -131 -154c-48 0 -82 35 -82 82c0 21 13 54 23 80c16 43 61 159 69 185c4 10 11 31 11 52c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124 c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 38 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -13 -53c-10 -27 -10 -29 -22 -58l-39 -105c-23 -61 -29 -75 -29 -100c0 -23 7 -33 24 -33c51 0 84 61 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D456" x="0" y="-213"></use>
</g>
</svg> are collectively referred to as the <em>one-ring</em> around v.</span>
</figcaption><p>


</p>
</div></div><p>


</p>
<p>The specific weight <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.334ex" height="2.509ex" style="vertical-align: -0.671ex;" viewBox="0 -791.3 574.5 1080.4" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">beta</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D6FD" d="M574 574c0 -12 -2 -24 -5 -37c-11 -45 -41 -86 -81 -116c-10 -8 -20 -14 -30 -20c17 -11 31 -26 43 -43c20 -31 30 -68 30 -108c0 -20 -3 -42 -8 -64c-14 -53 -51 -104 -99 -140c-52 -38 -113 -57 -170 -57c-68 0 -114 40 -131 98l-68 -274c-1 -4 -5 -7 -10 -7h-5 c-6 0 -10 4 -10 12l154 615c34 136 125 273 245 273c47 0 89 -18 116 -50c18 -22 29 -51 29 -82zM518 592c0 19 -3 36 -12 51c-16 26 -44 40 -78 40c-110 0 -188 -129 -220 -255l-60 -242c-4 -17 -6 -33 -6 -49c0 -71 41 -126 113 -126c44 0 91 19 129 52 c39 35 61 82 73 128c7 29 12 59 12 87c0 25 -4 48 -14 69c-7 16 -17 29 -30 39c-25 -9 -50 -13 -75 -13c-35 0 -76 0 -76 24c0 0 0 5 1 7c7 27 49 27 85 27c24 0 47 -5 67 -13c9 5 18 12 26 19c31 29 49 67 58 105c5 17 7 34 7 50zM395 403c-11 3 -23 5 -36 5 c-24 0 -57 0 -60 -9c-1 -4 30 -4 52 -4c14 0 29 3 44 8Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D6FD" x="0" y="0"></use>
</g>
</svg> used for this step is a key component of the
subdivision method and must be chosen carefully in order to ensure
smoothness of the limit surface, among other desirable
properties.<button style="button" data-toggle="tooltip" data-placement="right" data-html="true" class="btn footnote-button" title="Again, see the papers cited at the start of this
section and in the &ldquo;Further Reading&rdquo; section for information about how values like
β are derived.">
      <sup>&dagger;</sup>
    </button>
		  The <a href="#LoopSubdiv::beta"><tt>beta()</tt></a> function that follows
computes a&nbsp;<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.334ex" height="2.509ex" style="vertical-align: -0.671ex;" viewBox="0 -791.3 574.5 1080.4" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">beta</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D6FD" d="M574 574c0 -12 -2 -24 -5 -37c-11 -45 -41 -86 -81 -116c-10 -8 -20 -14 -30 -20c17 -11 31 -26 43 -43c20 -31 30 -68 30 -108c0 -20 -3 -42 -8 -64c-14 -53 -51 -104 -99 -140c-52 -38 -113 -57 -170 -57c-68 0 -114 40 -131 98l-68 -274c-1 -4 -5 -7 -10 -7h-5 c-6 0 -10 4 -10 12l154 615c34 136 125 273 245 273c47 0 89 -18 116 -50c18 -22 29 -51 29 -82zM518 592c0 19 -3 36 -12 51c-16 26 -44 40 -78 40c-110 0 -188 -129 -220 -255l-60 -242c-4 -17 -6 -33 -6 -49c0 -71 41 -126 113 -126c44 0 91 19 129 52 c39 35 61 82 73 128c7 29 12 59 12 87c0 25 -4 48 -14 69c-7 16 -17 29 -30 39c-25 -9 -50 -13 -75 -13c-35 0 -76 0 -76 24c0 0 0 5 1 7c7 27 49 27 85 27c24 0 47 -5 67 -13c9 5 18 12 26 19c31 29 49 67 58 105c5 17 7 34 7 50zM395 403c-11 3 -23 5 -36 5 c-24 0 -57 0 -60 -9c-1 -4 30 -4 52 -4c14 0 29 3 44 8Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D6FD" x="0" y="0"></use>
</g>
</svg> value based on the vertex&rsquo;s valence that ensures smoothness.  For
regular interior vertices, <a href="#LoopSubdiv::beta"><tt>beta()</tt></a> returns <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.65ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 2002 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">1 slash 16</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2F" d="M445 730c0 -2 0 -5 -1 -7l-349 -960c-3 -8 -10 -13 -19 -13c-11 0 -20 9 -20 20c0 2 0 5 1 7l349 960c3 8 10 13 19 13c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-36" d="M457 204c0 -132 -95 -226 -206 -226c-93 0 -209 71 -209 338c0 221 135 350 263 350c83 0 127 -48 127 -108c0 -39 -30 -48 -46 -48c-22 0 -46 15 -46 46c0 45 40 45 55 45c-22 34 -64 40 -88 40c-51 0 -175 -36 -175 -289v-24c20 48 57 99 125 99 c111 0 200 -96 200 -223zM367 205c0 49 0 100 -18 137c-31 62 -77 62 -93 62c-90 0 -122 -100 -122 -178c0 -18 0 -98 18 -145c6 -15 36 -75 99 -75c23 0 69 5 99 65c17 36 17 86 17 134Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-31" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2F" x="500" y="0"></use>
<g transform="translate(1001,0)">
 <use xlink:href="#E1-LATINMODERNMAIN-31"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-36" x="500" y="0"></use>
</g>
</g>
</svg>.  Since
this is a common case, the implementation uses <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.65ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 2002 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">1 slash 16</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2F" d="M445 730c0 -2 0 -5 -1 -7l-349 -960c-3 -8 -10 -13 -19 -13c-11 0 -20 9 -20 20c0 2 0 5 1 7l349 960c3 8 10 13 19 13c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-36" d="M457 204c0 -132 -95 -226 -206 -226c-93 0 -209 71 -209 338c0 221 135 350 263 350c83 0 127 -48 127 -108c0 -39 -30 -48 -46 -48c-22 0 -46 15 -46 46c0 45 40 45 55 45c-22 34 -64 40 -88 40c-51 0 -175 -36 -175 -289v-24c20 48 57 99 125 99 c111 0 200 -96 200 -223zM367 205c0 49 0 100 -18 137c-31 62 -77 62 -93 62c-90 0 -122 -100 -122 -178c0 -18 0 -98 18 -145c6 -15 36 -75 99 -75c23 0 69 5 99 65c17 36 17 86 17 134Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-31" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2F" x="500" y="0"></use>
<g transform="translate(1001,0)">
 <use xlink:href="#E1-LATINMODERNMAIN-31"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-36" x="500" y="0"></use>
</g>
</g>
</svg> directly instead of
calling <a href="#LoopSubdiv::beta"><tt>beta()</tt></a> every time.

</p>
<p></p>
<span class="anchor" id="fragment-Applyone-ringruleforevenvertex-0"></span><div class="fragmentname">&lt;&lt;Apply one-ring rule for even vertex&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">if (vertex-&gt;<a href="#SDVertex::regular" class="code">regular</a>)
    vertex-&gt;<a href="#SDVertex::child" class="code">child</a>-&gt;<a href="#SDVertex::p" class="code">p</a> = <a href="#LoopSubdiv::weightOneRing" class="code">weightOneRing</a>(vertex, 1.f / 16.f);
else
    vertex-&gt;<a href="#SDVertex::child" class="code">child</a>-&gt;<a href="#SDVertex::p" class="code">p</a> = <a href="#LoopSubdiv::weightOneRing" class="code">weightOneRing</a>(vertex, <a href="#LoopSubdiv::beta" class="code">beta</a>(vertex-&gt;<a href="#SDVertex::valence" class="code">valence</a>()));</div><p>


</p>
<p></p>
<span class="anchor" id="fragment-LoopSubdivInlineFunctions-1"></span><div class="fragmentname">&lt;&lt;LoopSubdiv Inline Functions&gt;&gt;+=&nbsp;<a href="#fragment-LoopSubdivInlineFunctions-0"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-LoopSubdivInlineFunctions-2"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">inline Float <span class="anchor" id="LoopSubdiv::beta"></span>beta(int valence) {
    if (valence == 3) return 3.f / 16.f;
    else return 3.f / (8.f * valence);
}</div><p>


</p>
<p>

</p>
<p>The <tt>weightOneRing()</tt> function loops over the one-ring of
adjacent vertices and applies the given weight to compute a new vertex
position.  It uses the <a href="#SDVertex::oneRing"><tt>SDVertex::oneRing()</tt></a> method, defined in the
following, which
returns the positions of the vertices around the vertex <tt>vert</tt>.

</p>
<p></p>
<span class="anchor" id="fragment-LoopSubdivFunctionDefinitions-1"></span><div class="fragmentname">&lt;&lt;LoopSubdiv Function Definitions&gt;&gt;+=&nbsp;<a href="#fragment-LoopSubdivFunctionDefinitions-0"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-LoopSubdivFunctionDefinitions-2"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">static <a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a> <span class="anchor" id="LoopSubdiv::weightOneRing"></span>weightOneRing(SDVertex *vert, Float beta) {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Putmonovertone-ringinmonopRing-0">Put <tt>vert</tt> one-ring in <tt>pRing</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-469" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-469"><i></i></a><div id="fragbit-469" class="collapse"><div class="fragmentcode">       int <a href="#SDVertex::valence" class="code">valence</a> = vert-&gt;<a href="#SDVertex::valence" class="code">valence</a>();
       <a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a> *pRing = <a href="../Utilities/Memory_Management.html#ALLOCA" class="code">ALLOCA</a>(<a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a>, <a href="#SDVertex::valence" class="code">valence</a>);
       vert-&gt;<a href="#SDVertex::oneRing" class="code">oneRing</a>(pRing);</div></div>
    <a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a> <a href="#SDVertex::p" class="code">p</a> = (1 - valence * beta) * vert-&gt;<a href="#SDVertex::p" class="code">p</a>;
    for (int i = 0; i &lt; valence; ++i)
        <a href="#SDVertex::p" class="code">p</a> += beta * pRing[i];
    return <a href="#SDVertex::p" class="code">p</a>;
}</div><p>


</p>
<p>Because a variable number of vertices are in the one-rings, we use the
<tt>ALLOCA()</tt> macro to efficiently allocate space to store their positions.

</p>
<p></p>
<span class="anchor" id="fragment-Putmonovertone-ringinmonopRing-0"></span><div class="fragmentname">&lt;&lt;Put <tt>vert</tt> one-ring in <tt>pRing</tt>&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">int <a href="#SDVertex::valence" class="code">valence</a> = vert-&gt;<a href="#SDVertex::valence" class="code">valence</a>();
<a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a> *pRing = <a href="../Utilities/Memory_Management.html#ALLOCA" class="code">ALLOCA</a>(<a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a>, <a href="#SDVertex::valence" class="code">valence</a>);
vert-&gt;<a href="#SDVertex::oneRing" class="code">oneRing</a>(pRing);</div><p>


</p>
<p>The <tt>oneRing()</tt> method assumes that the pointer passed in points to an
area of memory large enough to hold the one-ring around the vertex.


</p>
<p></p>
<span class="anchor" id="fragment-LoopSubdivFunctionDefinitions-2"></span><div class="fragmentname">&lt;&lt;LoopSubdiv Function Definitions&gt;&gt;+=&nbsp;<a href="#fragment-LoopSubdivFunctionDefinitions-1"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-LoopSubdivFunctionDefinitions-3"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">void SDVertex::<span class="anchor" id="SDVertex::oneRing"></span>oneRing(<a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a> *p) {
    if (!<a href="#SDVertex::boundary" class="code">boundary</a>) {
        &lt;&lt;<span class="fragmentname"><a href="#fragment-Getone-ringverticesforinteriorvertex-0">Get one-ring vertices for interior vertex</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-470" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-470"><i></i></a><div id="fragbit-470" class="collapse"><div class="fragmentcode">           SDFace *face = <a href="#SDVertex::startFace" class="code">startFace</a>;
           do {
               *<a href="#SDVertex::p" class="code">p</a>++ = face-&gt;<a href="#SDFace::nextVert" class="code">nextVert</a>(this)-&gt;<a href="#SDVertex::p" class="code">p</a>;
               face = face-&gt;<a href="#SDFace::nextFace" class="code">nextFace</a>(this);
           } while (face != <a href="#SDVertex::startFace" class="code">startFace</a>);</div></div>
    } else {
        &lt;&lt;<span class="fragmentname"><a href="#fragment-Getone-ringverticesforboundaryvertex-0">Get one-ring vertices for boundary vertex</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-471" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-471"><i></i></a><div id="fragbit-471" class="collapse"><div class="fragmentcode">           SDFace *face = <a href="#SDVertex::startFace" class="code">startFace</a>, *f2;
           while ((f2 = face-&gt;<a href="#SDFace::nextFace" class="code">nextFace</a>(this)) != nullptr)
               face = f2;
           *<a href="#SDVertex::p" class="code">p</a>++ = face-&gt;<a href="#SDFace::nextVert" class="code">nextVert</a>(this)-&gt;<a href="#SDVertex::p" class="code">p</a>;
           do {
               *<a href="#SDVertex::p" class="code">p</a>++ = face-&gt;<a href="#SDFace::prevVert" class="code">prevVert</a>(this)-&gt;<a href="#SDVertex::p" class="code">p</a>;
               face = face-&gt;<a href="#SDFace::prevFace" class="code">prevFace</a>(this);
           } while (face != nullptr);</div></div>
    }
}</div><p>


</p>
<p>It&rsquo;s relatively easy to get the one-ring around an interior vertex by
looping over the faces adjacent to the vertex and for each face retaining
the vertex after the center vertex. (Brief sketching with pencil and paper
should convince you that this process returns all of the vertices in the
one-ring.)

</p>
<p></p>
<span class="anchor" id="fragment-Getone-ringverticesforinteriorvertex-0"></span><div class="fragmentname">&lt;&lt;Get one-ring vertices for interior vertex&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">SDFace *face = <a href="#SDVertex::startFace" class="code">startFace</a>;
do {
    *<a href="#SDVertex::p" class="code">p</a>++ = face-&gt;<a href="#SDFace::nextVert" class="code">nextVert</a>(this)-&gt;<a href="#SDVertex::p" class="code">p</a>;
    face = face-&gt;<a href="#SDFace::nextFace" class="code">nextFace</a>(this);
} while (face != <a href="#SDVertex::startFace" class="code">startFace</a>);</div><p>


</p>
<p>The one-ring around a boundary vertex is a bit trickier.  The
implementation here 
carefully stores the one-ring in the given <tt>Point3f</tt> array so that the
first and last entries in the array are the two adjacent vertices along the
boundary.  This ordering is important because the adjacent boundary
vertices will often be weighted differently from the adjacent vertices that
are in the interior of the mesh.  Doing so requires that we first loop around
neighbor faces until we reach a face on the boundary and then loop around
the other way, storing vertices one by one.

</p>
<p></p>
<span class="anchor" id="fragment-Getone-ringverticesforboundaryvertex-0"></span><div class="fragmentname">&lt;&lt;Get one-ring vertices for boundary vertex&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">SDFace *face = <a href="#SDVertex::startFace" class="code">startFace</a>, *f2;
while ((f2 = face-&gt;<a href="#SDFace::nextFace" class="code">nextFace</a>(this)) != nullptr)
    face = f2;
*<a href="#SDVertex::p" class="code">p</a>++ = face-&gt;<a href="#SDFace::nextVert" class="code">nextVert</a>(this)-&gt;<a href="#SDVertex::p" class="code">p</a>;
do {
    *<a href="#SDVertex::p" class="code">p</a>++ = face-&gt;<a href="#SDFace::prevVert" class="code">prevVert</a>(this)-&gt;<a href="#SDVertex::p" class="code">p</a>;
    face = face-&gt;<a href="#SDFace::prevFace" class="code">prevFace</a>(this);
} while (face != nullptr);</div><p>


</p>
<p>For vertices on the boundary, the new vertex&rsquo;s position is based only on
the two neighboring boundary vertices (Figure&nbsp;<a href="#fig:loop-boundary-edge">3.34</a>). 
Not depending on interior
vertices ensures that two abutting surfaces that share the same vertices
on the boundary will have abutting limit surfaces.  The
<tt>weightBoundary()</tt> utility function applies the given weighting on the
two neighbor vertices v<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.054ex" height="1.676ex" style="vertical-align: -0.671ex;" viewBox="0 -432.6 453.9 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">Subscript 1</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-31" x="0" y="-213"></use>
</g>
</svg> and v<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.054ex" height="1.676ex" style="vertical-align: -0.671ex;" viewBox="0 -432.6 453.9 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">Subscript 2</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-32" d="M449 174l-28 -174h-371c0 24 0 26 11 37l192 214c55 62 105 141 105 221c0 82 -43 163 -134 163c-58 0 -112 -37 -135 -102c3 1 5 1 13 1c35 0 53 -26 53 -52c0 -41 -35 -53 -52 -53c-3 0 -53 0 -53 56c0 89 74 181 187 181c122 0 212 -80 212 -194 c0 -100 -60 -154 -216 -292l-106 -103h180c22 0 88 0 95 8c10 15 17 59 22 89h25Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-32" x="0" y="-213"></use>
</g>
</svg> to compute the new position v<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="0.902ex" height="2.176ex" style="vertical-align: -0.171ex;" viewBox="0 -863.1 388.1 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">prime</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNVARIANTS-2032" d="M340 496c0 -10 -3 -20 -8 -28l-227 -372h-38l171 424c6 15 26 29 48 29c30 0 54 -24 54 -53Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNVARIANTS-2032" x="0" y="513"></use>
</g>
</svg>&nbsp;as
</p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">

</div>
<div class="col-md-10 col-lg-8">
<div class="displaymath"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="28.324ex" height="3.009ex" style="vertical-align: -0.838ex;" viewBox="0 -934.9 12194.8 1295.7" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">normal v prime equals left-parenthesis 1 minus 2 beta right-parenthesis normal v plus beta normal v 1 plus beta normal v 2 period</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-76" d="M508 400c-66 -1 -83 -44 -92 -67l-131 -325c-4 -10 -8 -19 -21 -19s-15 5 -21 19l-144 355c-13 31 -17 37 -80 37v31c30 -2 70 -3 97 -3l109 3v-31c-18 0 -57 0 -57 -26c0 0 0 -4 6 -17l112 -279l102 255c4 11 6 15 6 24c0 19 -11 42 -48 43v31l87 -3c23 0 52 1 75 3v-31 Z"></path>
<path stroke-width="1" id="E1-LATINMODERNVARIANTS-2032" d="M340 496c0 -10 -3 -20 -8 -28l-227 -372h-38l171 424c6 15 26 29 48 29c30 0 54 -24 54 -53Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-3D" d="M722 347c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20zM722 153c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-28" d="M332 -238c0 -5 -5 -10 -10 -10c-2 0 -4 1 -6 2c-110 83 -215 283 -215 454v84c0 171 105 371 215 454c2 1 4 2 6 2c5 0 10 -5 10 -10c0 -3 -2 -6 -4 -8c-104 -78 -173 -278 -173 -438v-84c0 -160 69 -360 173 -438c2 -2 4 -5 4 -8Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2212" d="M722 250c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-32" d="M449 174l-28 -174h-371c0 24 0 26 11 37l192 214c55 62 105 141 105 221c0 82 -43 163 -134 163c-58 0 -112 -37 -135 -102c3 1 5 1 13 1c35 0 53 -26 53 -52c0 -41 -35 -53 -52 -53c-3 0 -53 0 -53 56c0 89 74 181 187 181c122 0 212 -80 212 -194 c0 -100 -60 -154 -216 -292l-106 -103h180c22 0 88 0 95 8c10 15 17 59 22 89h25Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D6FD" d="M574 574c0 -12 -2 -24 -5 -37c-11 -45 -41 -86 -81 -116c-10 -8 -20 -14 -30 -20c17 -11 31 -26 43 -43c20 -31 30 -68 30 -108c0 -20 -3 -42 -8 -64c-14 -53 -51 -104 -99 -140c-52 -38 -113 -57 -170 -57c-68 0 -114 40 -131 98l-68 -274c-1 -4 -5 -7 -10 -7h-5 c-6 0 -10 4 -10 12l154 615c34 136 125 273 245 273c47 0 89 -18 116 -50c18 -22 29 -51 29 -82zM518 592c0 19 -3 36 -12 51c-16 26 -44 40 -78 40c-110 0 -188 -129 -220 -255l-60 -242c-4 -17 -6 -33 -6 -49c0 -71 41 -126 113 -126c44 0 91 19 129 52 c39 35 61 82 73 128c7 29 12 59 12 87c0 25 -4 48 -14 69c-7 16 -17 29 -30 39c-25 -9 -50 -13 -75 -13c-35 0 -76 0 -76 24c0 0 0 5 1 7c7 27 49 27 85 27c24 0 47 -5 67 -13c9 5 18 12 26 19c31 29 49 67 58 105c5 17 7 34 7 50zM395 403c-11 3 -23 5 -36 5 c-24 0 -57 0 -60 -9c-1 -4 30 -4 52 -4c14 0 29 3 44 8Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-29" d="M288 208c0 -171 -105 -371 -215 -454c-2 -1 -4 -2 -6 -2c-5 0 -10 5 -10 10c0 3 2 6 4 8c104 78 173 278 173 438v84c0 160 -69 360 -173 438c-2 2 -4 5 -4 8c0 5 5 10 10 10c2 0 4 -1 6 -2c110 -83 215 -283 215 -454v-84Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2B" d="M722 250c0 -11 -9 -20 -20 -20h-293v-293c0 -11 -9 -20 -20 -20s-20 9 -20 20v293h-293c-11 0 -20 9 -20 20s9 20 20 20h293v293c0 11 9 20 20 20s20 -9 20 -20v-293h293c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2E" d="M192 53c0 -29 -24 -53 -53 -53s-53 24 -53 53s24 53 53 53s53 -24 53 -53Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-76" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNVARIANTS-2032" x="747" y="583"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-3D" x="1194" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-28" x="2250" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-31" x="2640" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2212" x="3362" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-32" x="4363" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D6FD" x="4864" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-29" x="5438" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-76" x="5828" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2B" x="6578" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D6FD" x="7579" y="0"></use>
<g transform="translate(8154,0)">
 <use xlink:href="#E1-LATINMODERNMAIN-76" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-31" x="747" y="-213"></use>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-2B" x="9358" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D6FD" x="10359" y="0"></use>
<g transform="translate(10933,0)">
 <use xlink:href="#E1-LATINMODERNMAIN-76" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-32" x="747" y="-213"></use>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-2E" x="11916" y="0"></use>
</g>
</svg>
</div>
<p>

The same weight of <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.487ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 1501.5 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">1 slash 8</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2F" d="M445 730c0 -2 0 -5 -1 -7l-349 -960c-3 -8 -10 -13 -19 -13c-11 0 -20 9 -20 20c0 2 0 5 1 7l349 960c3 8 10 13 19 13c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-38" d="M457 168c0 -107 -95 -190 -208 -190c-105 0 -207 67 -207 173c0 99 86 155 144 184c-25 17 -62 42 -73 54c-42 47 -44 92 -44 110c0 93 81 167 181 167c91 0 180 -57 180 -149c0 -66 -49 -118 -121 -155c64 -40 80 -50 99 -71c38 -42 49 -87 49 -123zM386 517 c0 72 -64 124 -137 124c-71 0 -136 -42 -136 -103c0 -17 4 -51 50 -81l124 -80c60 35 99 83 99 140zM407 132c0 61 -47 91 -75 110l-123 78c-85 -47 -117 -111 -117 -169c0 -83 72 -145 158 -145c82 0 157 52 157 126Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-31" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2F" x="500" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-38" x="1001" y="0"></use>
</g>
</svg> is used for both regular and extraordinary
vertices.

</p>
<p></p>
<span class="anchor" id="fig:loop-boundary-edge"></span><div class="card outerfigure"><div class="card-body figure"><p>



</p>
<div class="figure-row">
  <a href="Subdiv%20boundary%20weighting.svg" title=""><img src="Subdiv%20boundary%20weighting.svg" width=200 height=336 style="max-width: 100%;"></a>
</div>
<p>


</p>
<figcaption class="caption">Figure 3.34: Subdivision on a Boundary
Edge. <span class="legend"> The new position for the vertex in the center is computed by
weighting it and its two neighbor vertices by the weights shown.</span>
</figcaption><p>


</p>
</div></div><p>


</p>
<p></p>
<span class="anchor" id="fragment-Applyboundaryruleforevenvertex-0"></span><div class="fragmentname">&lt;&lt;Apply boundary rule for even vertex&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">vertex-&gt;<a href="#SDVertex::child" class="code">child</a>-&gt;<a href="#SDVertex::p" class="code">p</a> = <a href="#LoopSubdiv::weightBoundary" class="code">weightBoundary</a>(vertex, 1.f / 8.f);</div><p>


</p>
<p>The <tt>weightBoundary()</tt> utility function applies the given weights at a boundary
vertex.  Because the <a href="#SDVertex::oneRing"><tt>SDVertex::oneRing()</tt></a>
function orders the boundary vertex&rsquo;s
one-ring such that the first and last entries are the boundary neighbors,
the implementation here is particularly straightforward.

</p>
<p></p>
<span class="anchor" id="fragment-LoopSubdivFunctionDefinitions-3"></span><div class="fragmentname">&lt;&lt;LoopSubdiv Function Definitions&gt;&gt;+=&nbsp;<a href="#fragment-LoopSubdivFunctionDefinitions-2"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode">static <a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a> <span class="anchor" id="LoopSubdiv::weightBoundary"></span>weightBoundary(SDVertex *vert, Float beta) {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Putmonovertone-ringinmonopRing-0">Put <tt>vert</tt> one-ring in <tt>pRing</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-472" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-472"><i></i></a><div id="fragbit-472" class="collapse"><div class="fragmentcode">       int <a href="#SDVertex::valence" class="code">valence</a> = vert-&gt;<a href="#SDVertex::valence" class="code">valence</a>();
       <a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a> *pRing = <a href="../Utilities/Memory_Management.html#ALLOCA" class="code">ALLOCA</a>(<a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a>, <a href="#SDVertex::valence" class="code">valence</a>);
       vert-&gt;<a href="#SDVertex::oneRing" class="code">oneRing</a>(pRing);</div></div>
    <a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a> <a href="#SDVertex::p" class="code">p</a> = (1 - 2 * beta) * vert-&gt;<a href="#SDVertex::p" class="code">p</a>;
    <a href="#SDVertex::p" class="code">p</a> += beta * pRing[0];
    <a href="#SDVertex::p" class="code">p</a> += beta * pRing[valence - 1];
    return <a href="#SDVertex::p" class="code">p</a>;
}</div><p>


</p>
<p>
Now the refinement method computes the positions of the odd vertices&mdash;the
new vertices along the split edges of the mesh. It loops over each
edge of each face in the mesh, computing the new vertex that splits the
edge (Figure&nbsp;<a href="#fig:loop-edge-split">3.35</a>).  For interior edges, the new
vertex is found by weighting the two vertices at the ends of the edge
 and the two vertices across from the edge on the adjacent
faces.  It loops through all three edges of each face,
and each time it comes to an edge that hasn&rsquo;t been seen before it computes
and stores the new odd vertex for the edge in the <tt>edgeVerts</tt>
associative array.

</p>
<p>
</p>
<span class="anchor" id="fig:loop-edge-split"></span><div class="card outerfigure"><div class="card-body figure"><p>



</p>
<div class="figure-row">
  <a href="Subdiv%20edge%20split.svg" title=""><img src="Subdiv%20edge%20split.svg" width=703 height=270 style="max-width: 100%;"></a>
</div>
<p>


</p>
<figcaption class="caption">Figure 3.35: Subdivision Rule for Edge Split. <span class="legend"> The
position of the new odd vertex, marked with an open circle, is found by weighting
the two vertices at the ends of the edge and the two vertices opposite it on
the adjacent triangles.  (a) The weights for an interior
vertex; (b)&nbsp;the weights for a boundary vertex.</span>
</figcaption><p>


</p>
</div></div><p>


</p>
<p></p>
<span class="anchor" id="fragment-Computenewoddedgevertices-0"></span><div class="fragmentname">&lt;&lt;Compute new odd edge vertices&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">std::map&lt;SDEdge, SDVertex *&gt; edgeVerts;
for (SDFace *face : f) {
    for (int k = 0; k &lt; 3; ++k) {
        &lt;&lt;<span class="fragmentname"><a href="#fragment-Computeoddvertexonmonokthedge-0">Compute odd vertex on <tt>k</tt>th edge</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-473" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-473"><i></i></a><div id="fragbit-473" class="collapse"><div class="fragmentcode">           SDEdge edge(face-&gt;<a href="#SDFace::v" class="code">v</a>[k], face-&gt;<a href="#SDFace::v" class="code">v</a>[<a href="#NEXT" class="code">NEXT</a>(k)]);
           SDVertex *vert = edgeVerts[edge];
           if (!vert) {
               &lt;&lt;<span class="fragmentname"><a href="#fragment-Createandinitializenewoddvertex-0">Create and initialize new odd vertex</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-474" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-474"><i></i></a><div id="fragbit-474" class="collapse"><div class="fragmentcode">                  vert = arena.<a href="../Utilities/Memory_Management.html#MemoryArena::Alloc" class="code">Alloc</a>&lt;SDVertex&gt;();
                  newVertices.push_back(vert);
                  vert-&gt;<a href="#SDVertex::regular" class="code">regular</a> = true;
                  vert-&gt;<a href="#SDVertex::boundary" class="code">boundary</a> = (face-&gt;<a href="#SDFace::f" class="code">f</a>[k] == nullptr);
                  vert-&gt;<a href="#SDVertex::startFace" class="code">startFace</a> = face-&gt;<a href="#SDFace::children" class="code">children</a>[3];</div></div>
               &lt;&lt;<span class="fragmentname"><a href="#fragment-Applyedgerulestocomputenewvertexposition-0">Apply edge rules to compute new vertex position</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-475" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-475"><i></i></a><div id="fragbit-475" class="collapse"><div class="fragmentcode">                  if (vert-&gt;<a href="#SDVertex::boundary" class="code">boundary</a>) {
                      vert-&gt;<a href="#SDVertex::p" class="code">p</a> =  0.5f * edge.<a href="#SDEdge::v" class="code">v</a>[0]-&gt;<a href="#SDVertex::p" class="code">p</a>;
                      vert-&gt;<a href="#SDVertex::p" class="code">p</a> += 0.5f * edge.<a href="#SDEdge::v" class="code">v</a>[1]-&gt;<a href="#SDVertex::p" class="code">p</a>;
                  } else {
                      vert-&gt;<a href="#SDVertex::p" class="code">p</a> =  3.f/8.f * edge.<a href="#SDEdge::v" class="code">v</a>[0]-&gt;<a href="#SDVertex::p" class="code">p</a>;
                      vert-&gt;<a href="#SDVertex::p" class="code">p</a> += 3.f/8.f * edge.<a href="#SDEdge::v" class="code">v</a>[1]-&gt;<a href="#SDVertex::p" class="code">p</a>;
                      vert-&gt;<a href="#SDVertex::p" class="code">p</a> += 1.f/8.f * face-&gt;<a href="#SDFace::otherVert" class="code">otherVert</a>(edge.<a href="#SDEdge::v" class="code">v</a>[0], edge.<a href="#SDEdge::v" class="code">v</a>[1])-&gt;<a href="#SDVertex::p" class="code">p</a>;
                      vert-&gt;<a href="#SDVertex::p" class="code">p</a> += 1.f/8.f *
                          face-&gt;f[k]-&gt;<a href="#SDFace::otherVert" class="code">otherVert</a>(edge.<a href="#SDEdge::v" class="code">v</a>[0], edge.<a href="#SDEdge::v" class="code">v</a>[1])-&gt;<a href="#SDVertex::p" class="code">p</a>;
                  }</div></div>
               edgeVerts[edge] = vert;
           }</div></div>
    }
}</div><p>


</p>
<p>As was done when setting the face neighbor pointers in the original
mesh, an <tt>SDEdge</tt> object is created for the edge and checked to see if
it is in the set of edges that have already been visited.  If it isn&rsquo;t, the new
vertex on this edge is computed and added to the <tt>map</tt>, which is an
associative array structure that performs efficient lookups.

</p>
<p></p>
<span class="anchor" id="fragment-Computeoddvertexonmonokthedge-0"></span><div class="fragmentname">&lt;&lt;Compute odd vertex on <tt>k</tt>th edge&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">SDEdge edge(face-&gt;<a href="#SDFace::v" class="code">v</a>[k], face-&gt;<a href="#SDFace::v" class="code">v</a>[<a href="#NEXT" class="code">NEXT</a>(k)]);
SDVertex *vert = edgeVerts[edge];
if (!vert) {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Createandinitializenewoddvertex-0">Create and initialize new odd vertex</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-476" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-476"><i></i></a><div id="fragbit-476" class="collapse"><div class="fragmentcode">       vert = arena.<a href="../Utilities/Memory_Management.html#MemoryArena::Alloc" class="code">Alloc</a>&lt;SDVertex&gt;();
       newVertices.push_back(vert);
       vert-&gt;<a href="#SDVertex::regular" class="code">regular</a> = true;
       vert-&gt;<a href="#SDVertex::boundary" class="code">boundary</a> = (face-&gt;<a href="#SDFace::f" class="code">f</a>[k] == nullptr);
       vert-&gt;<a href="#SDVertex::startFace" class="code">startFace</a> = face-&gt;<a href="#SDFace::children" class="code">children</a>[3];</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Applyedgerulestocomputenewvertexposition-0">Apply edge rules to compute new vertex position</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-477" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-477"><i></i></a><div id="fragbit-477" class="collapse"><div class="fragmentcode">       if (vert-&gt;<a href="#SDVertex::boundary" class="code">boundary</a>) {
           vert-&gt;<a href="#SDVertex::p" class="code">p</a> =  0.5f * edge.<a href="#SDEdge::v" class="code">v</a>[0]-&gt;<a href="#SDVertex::p" class="code">p</a>;
           vert-&gt;<a href="#SDVertex::p" class="code">p</a> += 0.5f * edge.<a href="#SDEdge::v" class="code">v</a>[1]-&gt;<a href="#SDVertex::p" class="code">p</a>;
       } else {
           vert-&gt;<a href="#SDVertex::p" class="code">p</a> =  3.f/8.f * edge.<a href="#SDEdge::v" class="code">v</a>[0]-&gt;<a href="#SDVertex::p" class="code">p</a>;
           vert-&gt;<a href="#SDVertex::p" class="code">p</a> += 3.f/8.f * edge.<a href="#SDEdge::v" class="code">v</a>[1]-&gt;<a href="#SDVertex::p" class="code">p</a>;
           vert-&gt;<a href="#SDVertex::p" class="code">p</a> += 1.f/8.f * face-&gt;<a href="#SDFace::otherVert" class="code">otherVert</a>(edge.<a href="#SDEdge::v" class="code">v</a>[0], edge.<a href="#SDEdge::v" class="code">v</a>[1])-&gt;<a href="#SDVertex::p" class="code">p</a>;
           vert-&gt;<a href="#SDVertex::p" class="code">p</a> += 1.f/8.f *
               face-&gt;f[k]-&gt;<a href="#SDFace::otherVert" class="code">otherVert</a>(edge.<a href="#SDEdge::v" class="code">v</a>[0], edge.<a href="#SDEdge::v" class="code">v</a>[1])-&gt;<a href="#SDVertex::p" class="code">p</a>;
       }</div></div>
    edgeVerts[edge] = vert;
}</div><p>


</p>
<p>In Loop subdivision, the new vertices added by subdivision are always
regular.  (This means that the proportion of extraordinary vertices with
respect to
regular vertices will decrease with each level of subdivision.)  Therefore,
the <tt>regular</tt> member of the new vertex can immediately be set to
<tt>true</tt>.  The <tt>boundary</tt> member can also be easily initialized, by
checking to see if there is a neighbor face across the edge that is being
split.  Finally,  the new vertex&rsquo;s <tt>startFace</tt>
pointer can also be set here.  For any odd vertex on the edge of a face, the center
child (child face number three) is guaranteed to be adjacent to the new
vertex.
 
</p>
<span class="anchor" id="fragment-Createandinitializenewoddvertex-0"></span><div class="fragmentname">&lt;&lt;Create and initialize new odd vertex&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">vert = arena.<a href="../Utilities/Memory_Management.html#MemoryArena::Alloc" class="code">Alloc</a>&lt;SDVertex&gt;();
newVertices.push_back(vert);
vert-&gt;<a href="#SDVertex::regular" class="code">regular</a> = true;
vert-&gt;<a href="#SDVertex::boundary" class="code">boundary</a> = (face-&gt;<a href="#SDFace::f" class="code">f</a>[k] == nullptr);
vert-&gt;<a href="#SDVertex::startFace" class="code">startFace</a> = face-&gt;<a href="#SDFace::children" class="code">children</a>[3];</div><p>


</p>
<p>For odd boundary vertices, the new vertex is just the average of the two
adjacent vertices.  For odd interior vertices, the two vertices at the ends
of the edge are given weight <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.487ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 1501.5 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">3 slash 8</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-33" d="M457 171c0 -102 -91 -193 -213 -193c-109 0 -202 66 -202 157c0 44 32 58 56 58c29 0 56 -20 56 -56c0 -38 -31 -60 -66 -55c35 -59 110 -76 153 -76c44 0 113 29 113 165c0 98 -37 166 -119 166h-44c-17 0 -24 0 -24 11c0 10 7 11 15 12c7 0 31 2 39 3c25 1 59 4 89 52 c26 44 28 102 28 114c0 90 -55 112 -96 112c-36 0 -102 -13 -133 -62c15 0 62 0 62 -50c0 -29 -20 -51 -51 -51c-29 0 -51 19 -51 52c0 76 76 136 177 136c96 0 184 -56 184 -138c0 -79 -58 -149 -140 -176c104 -21 167 -99 167 -181Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2F" d="M445 730c0 -2 0 -5 -1 -7l-349 -960c-3 -8 -10 -13 -19 -13c-11 0 -20 9 -20 20c0 2 0 5 1 7l349 960c3 8 10 13 19 13c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-38" d="M457 168c0 -107 -95 -190 -208 -190c-105 0 -207 67 -207 173c0 99 86 155 144 184c-25 17 -62 42 -73 54c-42 47 -44 92 -44 110c0 93 81 167 181 167c91 0 180 -57 180 -149c0 -66 -49 -118 -121 -155c64 -40 80 -50 99 -71c38 -42 49 -87 49 -123zM386 517 c0 72 -64 124 -137 124c-71 0 -136 -42 -136 -103c0 -17 4 -51 50 -81l124 -80c60 35 99 83 99 140zM407 132c0 61 -47 91 -75 110l-123 78c-85 -47 -117 -111 -117 -169c0 -83 72 -145 158 -145c82 0 157 52 157 126Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-33" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2F" x="500" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-38" x="1001" y="0"></use>
</g>
</svg>, and the two vertices opposite the edge
are given weight <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.487ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 1501.5 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">1 slash 8</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2F" d="M445 730c0 -2 0 -5 -1 -7l-349 -960c-3 -8 -10 -13 -19 -13c-11 0 -20 9 -20 20c0 2 0 5 1 7l349 960c3 8 10 13 19 13c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-38" d="M457 168c0 -107 -95 -190 -208 -190c-105 0 -207 67 -207 173c0 99 86 155 144 184c-25 17 -62 42 -73 54c-42 47 -44 92 -44 110c0 93 81 167 181 167c91 0 180 -57 180 -149c0 -66 -49 -118 -121 -155c64 -40 80 -50 99 -71c38 -42 49 -87 49 -123zM386 517 c0 72 -64 124 -137 124c-71 0 -136 -42 -136 -103c0 -17 4 -51 50 -81l124 -80c60 35 99 83 99 140zM407 132c0 61 -47 91 -75 110l-123 78c-85 -47 -117 -111 -117 -169c0 -83 72 -145 158 -145c82 0 157 52 157 126Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-31" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2F" x="500" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-38" x="1001" y="0"></use>
</g>
</svg> (Figure&nbsp;<a href="#fig:loop-edge-split">3.35</a>).  These last two
vertices can be found using the <a href="#SDFace::otherVert"><tt>SDFace::otherVert()</tt></a> utility function, which
returns the vertex opposite a given edge of a face.

</p>
<p></p>
<span class="anchor" id="fragment-Applyedgerulestocomputenewvertexposition-0"></span><div class="fragmentname">&lt;&lt;Apply edge rules to compute new vertex position&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">if (vert-&gt;<a href="#SDVertex::boundary" class="code">boundary</a>) {
    vert-&gt;<a href="#SDVertex::p" class="code">p</a> =  0.5f * edge.<a href="#SDEdge::v" class="code">v</a>[0]-&gt;<a href="#SDVertex::p" class="code">p</a>;
    vert-&gt;<a href="#SDVertex::p" class="code">p</a> += 0.5f * edge.<a href="#SDEdge::v" class="code">v</a>[1]-&gt;<a href="#SDVertex::p" class="code">p</a>;
} else {
    vert-&gt;<a href="#SDVertex::p" class="code">p</a> =  3.f/8.f * edge.<a href="#SDEdge::v" class="code">v</a>[0]-&gt;<a href="#SDVertex::p" class="code">p</a>;
    vert-&gt;<a href="#SDVertex::p" class="code">p</a> += 3.f/8.f * edge.<a href="#SDEdge::v" class="code">v</a>[1]-&gt;<a href="#SDVertex::p" class="code">p</a>;
    vert-&gt;<a href="#SDVertex::p" class="code">p</a> += 1.f/8.f * face-&gt;<a href="#SDFace::otherVert" class="code">otherVert</a>(edge.<a href="#SDEdge::v" class="code">v</a>[0], edge.<a href="#SDEdge::v" class="code">v</a>[1])-&gt;<a href="#SDVertex::p" class="code">p</a>;
    vert-&gt;<a href="#SDVertex::p" class="code">p</a> += 1.f/8.f *
        face-&gt;f[k]-&gt;<a href="#SDFace::otherVert" class="code">otherVert</a>(edge.<a href="#SDEdge::v" class="code">v</a>[0], edge.<a href="#SDEdge::v" class="code">v</a>[1])-&gt;<a href="#SDVertex::p" class="code">p</a>;
}</div><p>


</p>
<p>
The <a href="#SDFace::otherVert"><tt>SDFace::otherVert()</tt></a> method is self-explanatory:

</p>
<p></p>
<span class="anchor" id="fragment-SDFaceMethods-5"></span><div class="fragmentname">&lt;&lt;SDFace Methods&gt;&gt;+=&nbsp;<a href="#fragment-SDFaceMethods-4"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode">SDVertex *<span class="anchor" id="SDFace::otherVert"></span>otherVert(SDVertex *v0, SDVertex *v1) {
    for (int i = 0; i &lt; 3; ++i)
        if (<a href="#SDFace::v" class="code">v</a>[i] != v0 &amp;&amp; <a href="#SDFace::v" class="code">v</a>[i] != v1)
            return <a href="#SDFace::v" class="code">v</a>[i];
    <a href="../Utilities/Communicating_with_the_User.html#Severe" class="code">Severe</a>("Basic logic error in SDVertex::otherVert()");
    return nullptr;
}</div><p>


</p>
<p>

</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#x2-UpdatingMeshTopology"><i class="fas fa-link h3h4marginlink"></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span id="x2-UpdatingMeshTopology"></span><h4>Updating Mesh Topology</h4><p>


</p>
<p>In order to keep the details of the topology update as straightforward as
possible, the numbering scheme for the subdivided faces and their vertices
has been chosen carefully (Figure&nbsp;<a href="#fig:tri-face-split">3.36</a>).
Review the figure carefully; the conventions shown are key to
the next few pages.

</p>
<p> </p>
<span class="anchor" id="fig:tri-face-split"></span><div class="card outerfigure"><div class="card-body figure"><p>



</p>
<div class="figure-row">
  <a href="Subdiv%20vert%20face%20pointer%20update.svg" title=""><img src="Subdiv%20vert%20face%20pointer%20update.svg" width=876 height=461 style="max-width: 100%;"></a>
</div>
<p>


</p>
<figcaption class="caption">Figure 3.36: <span class="legend"> Each face is split into four child faces, such that the <tt>i</tt>th
child is adjacent to the <tt>i</tt>th vertex of the original face, and such that
the <tt>i</tt>th child face&rsquo;s <tt>i</tt>th vertex is the child of the <tt>i</tt>th vertex of the
original face.  The vertices of the center child are oriented such that the
<tt>i</tt>th vertex is the odd vertex along the <tt>i</tt>th edge of the parent face.</span>
</figcaption><p>


</p>
</div></div><p>


</p>
<p>There are four main tasks required to update the topological pointers of the
refined mesh:
</p>
<ol>
<li> The odd vertices&rsquo; <a href="#SDVertex::startFace"><tt>SDVertex::startFace</tt></a> pointers need to store
a pointer to one of their adjacent faces.
<li> Similarly, the even vertices&rsquo; <a href="#SDVertex::startFace"><tt>SDVertex::startFace</tt></a> pointers
must be set.
<li> The new faces&rsquo; neighbor <tt>f[i]</tt> pointers need to be set to point
to the neighboring faces.
<li> The new faces&rsquo; <tt>v[i]</tt> pointers need to point to the appropriate
vertices.
</ol><p>


</p>
<p>The <tt>startFace</tt> pointers of the odd vertices were already initialized
when they were
first created. We&rsquo;ll handle the other three tasks in order here.

</p>
<p></p>
<span class="anchor" id="fragment-Updatenewmeshtopology-0"></span><div class="fragmentname">&lt;&lt;Update new mesh topology&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">&lt;&lt;<span class="fragmentname"><a href="#fragment-Updateevenvertexfacepointers-0">Update even vertex face pointers</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-478" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-478"><i></i></a><div id="fragbit-478" class="collapse"><div class="fragmentcode">   for (SDVertex *vertex : v) {
       int vertNum = vertex-&gt;<a href="#SDVertex::startFace" class="code">startFace</a>-&gt;<a href="#SDFace::vnum" class="code">vnum</a>(vertex);
       vertex-&gt;child-&gt;<a href="#SDVertex::startFace" class="code">startFace</a> = 
           vertex-&gt;<a href="#SDVertex::startFace" class="code">startFace</a>-&gt;<a href="#SDFace::children" class="code">children</a>[vertNum];
   }</div></div>
&lt;&lt;<span class="fragmentname"><a href="#fragment-Updatefaceneighborpointers-0">Update face neighbor pointers</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-479" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-479"><i></i></a><div id="fragbit-479" class="collapse"><div class="fragmentcode">   for (SDFace *face : f) {
       for (int j = 0; j &lt; 3; ++j) {
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Updatechildrenmonofpointersforsiblings-0">Update children <tt>f</tt> pointers for siblings</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-480" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-480"><i></i></a><div id="fragbit-480" class="collapse"><div class="fragmentcode">              face-&gt;<a href="#SDFace::children" class="code">children</a>[3]-&gt;<a href="#SDFace::f" class="code">f</a>[j] = face-&gt;<a href="#SDFace::children" class="code">children</a>[<a href="#NEXT" class="code">NEXT</a>(j)];
              face-&gt;<a href="#SDFace::children" class="code">children</a>[j]-&gt;<a href="#SDFace::f" class="code">f</a>[<a href="#NEXT" class="code">NEXT</a>(j)] = face-&gt;<a href="#SDFace::children" class="code">children</a>[3];</div></div>
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Updatechildrenmonofpointersforneighborchildren-0">Update children <tt>f</tt> pointers for neighbor children</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-481" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-481"><i></i></a><div id="fragbit-481" class="collapse"><div class="fragmentcode">              SDFace *f2 = face-&gt;<a href="#SDFace::f" class="code">f</a>[j];
              face-&gt;<a href="#SDFace::children" class="code">children</a>[j]-&gt;<a href="#SDFace::f" class="code">f</a>[j] =
                  f2 ? f2-&gt;<a href="#SDFace::children" class="code">children</a>[f2-&gt;<a href="#SDFace::vnum" class="code">vnum</a>(face-&gt;v[j])] : nullptr;
              f2 = face-&gt;<a href="#SDFace::f" class="code">f</a>[<a href="#PREV" class="code">PREV</a>(j)];
              face-&gt;<a href="#SDFace::children" class="code">children</a>[j]-&gt;<a href="#SDFace::f" class="code">f</a>[<a href="#PREV" class="code">PREV</a>(j)] = 
                  f2 ? f2-&gt;<a href="#SDFace::children" class="code">children</a>[f2-&gt;<a href="#SDFace::vnum" class="code">vnum</a>(face-&gt;v[j])] : nullptr;</div></div>
       }
   }</div></div>
&lt;&lt;<span class="fragmentname"><a href="#fragment-Updatefacevertexpointers-0">Update face vertex pointers</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-482" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-482"><i></i></a><div id="fragbit-482" class="collapse"><div class="fragmentcode">   for (SDFace *face : f) {
       for (int j = 0; j &lt; 3; ++j) {
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Updatechildvertexpointertonewevenvertex-0">Update child vertex pointer to new even vertex</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-483" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-483"><i></i></a><div id="fragbit-483" class="collapse"><div class="fragmentcode">              face-&gt;<a href="#SDFace::children" class="code">children</a>[j]-&gt;<a href="#SDFace::v" class="code">v</a>[j] = face-&gt;<a href="#SDFace::v" class="code">v</a>[j]-&gt;<a href="#SDVertex::child" class="code">child</a>;</div></div>
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Updatechildvertexpointertonewoddvertex-0">Update child vertex pointer to new odd vertex</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-484" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-484"><i></i></a><div id="fragbit-484" class="collapse"><div class="fragmentcode">              SDVertex *vert = edgeVerts[SDEdge(face-&gt;<a href="#SDFace::v" class="code">v</a>[j], face-&gt;<a href="#SDFace::v" class="code">v</a>[<a href="#NEXT" class="code">NEXT</a>(j)])];
              face-&gt;<a href="#SDFace::children" class="code">children</a>[j]-&gt;<a href="#SDFace::v" class="code">v</a>[<a href="#NEXT" class="code">NEXT</a>(j)] = vert;
              face-&gt;<a href="#SDFace::children" class="code">children</a>[<a href="#NEXT" class="code">NEXT</a>(j)]-&gt;<a href="#SDFace::v" class="code">v</a>[j] = vert;
              face-&gt;<a href="#SDFace::children" class="code">children</a>[3]-&gt;<a href="#SDFace::v" class="code">v</a>[j] = vert;</div></div>
       }
   }</div></div></div><p>


</p>
<p>If a vertex is the <tt>i</tt>th vertex of its <tt>startFace</tt>, then it is
guaranteed that it will be adjacent to the <tt>i</tt>th child face of
<tt>startFace</tt>.  Therefore, it is just necessary to loop through all the parent
vertices in the mesh, and for each one find its vertex index in its
<tt>startFace</tt>.  This index can then be used to find the child face adjacent
to the new even vertex.

</p>
<p></p>
<span class="anchor" id="fragment-Updateevenvertexfacepointers-0"></span><div class="fragmentname">&lt;&lt;Update even vertex face pointers&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">for (SDVertex *vertex : v) {
    int vertNum = vertex-&gt;<a href="#SDVertex::startFace" class="code">startFace</a>-&gt;<a href="#SDFace::vnum" class="code">vnum</a>(vertex);
    vertex-&gt;child-&gt;<a href="#SDVertex::startFace" class="code">startFace</a> = 
        vertex-&gt;<a href="#SDVertex::startFace" class="code">startFace</a>-&gt;<a href="#SDFace::children" class="code">children</a>[vertNum];
}</div><p>


</p>
<p>Next, the face neighbor pointers for the newly created faces are updated.  We
break this into two steps: one to update neighbors among children of the
same parent, and one to do neighbors across children of different parents.
This involves some tricky pointer manipulation.

</p>
<p></p>
<span class="anchor" id="fragment-Updatefaceneighborpointers-0"></span><div class="fragmentname">&lt;&lt;Update face neighbor pointers&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">for (SDFace *face : f) {
    for (int j = 0; j &lt; 3; ++j) {
        &lt;&lt;<span class="fragmentname"><a href="#fragment-Updatechildrenmonofpointersforsiblings-0">Update children <tt>f</tt> pointers for siblings</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-485" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-485"><i></i></a><div id="fragbit-485" class="collapse"><div class="fragmentcode">           face-&gt;<a href="#SDFace::children" class="code">children</a>[3]-&gt;<a href="#SDFace::f" class="code">f</a>[j] = face-&gt;<a href="#SDFace::children" class="code">children</a>[<a href="#NEXT" class="code">NEXT</a>(j)];
           face-&gt;<a href="#SDFace::children" class="code">children</a>[j]-&gt;<a href="#SDFace::f" class="code">f</a>[<a href="#NEXT" class="code">NEXT</a>(j)] = face-&gt;<a href="#SDFace::children" class="code">children</a>[3];</div></div>
        &lt;&lt;<span class="fragmentname"><a href="#fragment-Updatechildrenmonofpointersforneighborchildren-0">Update children <tt>f</tt> pointers for neighbor children</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-486" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-486"><i></i></a><div id="fragbit-486" class="collapse"><div class="fragmentcode">           SDFace *f2 = face-&gt;<a href="#SDFace::f" class="code">f</a>[j];
           face-&gt;<a href="#SDFace::children" class="code">children</a>[j]-&gt;<a href="#SDFace::f" class="code">f</a>[j] =
               f2 ? f2-&gt;<a href="#SDFace::children" class="code">children</a>[f2-&gt;<a href="#SDFace::vnum" class="code">vnum</a>(face-&gt;v[j])] : nullptr;
           f2 = face-&gt;<a href="#SDFace::f" class="code">f</a>[<a href="#PREV" class="code">PREV</a>(j)];
           face-&gt;<a href="#SDFace::children" class="code">children</a>[j]-&gt;<a href="#SDFace::f" class="code">f</a>[<a href="#PREV" class="code">PREV</a>(j)] = 
               f2 ? f2-&gt;<a href="#SDFace::children" class="code">children</a>[f2-&gt;<a href="#SDFace::vnum" class="code">vnum</a>(face-&gt;v[j])] : nullptr;</div></div>
    }
}</div><p>


</p>
<p>For the first step, recall that the interior child face is
always stored in <tt>children[3]</tt>.  Furthermore, the <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.223ex" height="2.343ex" style="vertical-align: -0.505ex;" viewBox="0 -791.3 2248.9 1008.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">monospace k plus 1</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMONOSPACE-1D694" d="M508 30c0 -30 -26 -30 -41 -30h-118c-15 0 -40 0 -40 30c0 31 20 31 56 31l-119 155l-80 -74v-81h49c16 0 40 0 40 -31c0 -30 -25 -30 -40 -30h-154c-16 0 -40 0 -40 31c0 30 25 30 40 30h49v489h-49c-16 0 -40 0 -40 31c0 30 25 30 40 30h65c34 0 40 -10 40 -41v-352 l162 152h-37c-15 0 -40 0 -40 30c0 31 24 31 40 31h154c15 0 41 0 41 -31c0 -30 -26 -30 -41 -30h-35l-123 -115l149 -194h31c15 0 41 0 41 -31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2B" d="M722 250c0 -11 -9 -20 -20 -20h-293v-293c0 -11 -9 -20 -20 -20s-20 9 -20 20v293h-293c-11 0 -20 9 -20 20s9 20 20 20h293v293c0 11 9 20 20 20s20 -9 20 -20v-293h293c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMONOSPACE-1D694" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2B" x="747" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-31" x="1748" y="0"></use>
</g>
</svg>st child face (for
<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="9.874ex" height="2.509ex" style="vertical-align: -0.671ex;" viewBox="0 -791.3 4251.4 1080.4" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">monospace k equals 0 comma 1 comma 2</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMONOSPACE-1D694" d="M508 30c0 -30 -26 -30 -41 -30h-118c-15 0 -40 0 -40 30c0 31 20 31 56 31l-119 155l-80 -74v-81h49c16 0 40 0 40 -31c0 -30 -25 -30 -40 -30h-154c-16 0 -40 0 -40 31c0 30 25 30 40 30h49v489h-49c-16 0 -40 0 -40 31c0 30 25 30 40 30h65c34 0 40 -10 40 -41v-352 l162 152h-37c-15 0 -40 0 -40 30c0 31 24 31 40 31h154c15 0 41 0 41 -31c0 -30 -26 -30 -41 -30h-35l-123 -115l149 -194h31c15 0 41 0 41 -31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-3D" d="M722 347c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20zM722 153c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-30" d="M460 320c0 -79 -5 -157 -37 -226c-44 -95 -120 -116 -174 -116c-49 0 -122 20 -165 101c-41 76 -45 166 -45 241c0 80 5 158 37 227c41 93 114 119 174 119c42 0 124 -16 170 -112c35 -74 40 -154 40 -234zM377 332c0 63 0 139 -10 195c-19 99 -85 117 -118 117 c-25 0 -100 -9 -119 -128c-8 -54 -8 -120 -8 -184c0 -59 0 -151 11 -211c18 -96 77 -121 116 -121c45 0 102 30 117 125c11 64 11 132 11 207Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2C" d="M203 1c0 -117 -80 -194 -91 -194c-5 0 -10 4 -10 11c0 3 0 5 11 16c33 33 68 93 68 167c0 14 -2 15 -2 15s-2 -1 -5 -3c-10 -9 -23 -13 -35 -13c-33 0 -53 26 -53 53c0 28 20 53 53 53c39 0 64 -39 64 -105Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-32" d="M449 174l-28 -174h-371c0 24 0 26 11 37l192 214c55 62 105 141 105 221c0 82 -43 163 -134 163c-58 0 -112 -37 -135 -102c3 1 5 1 13 1c35 0 53 -26 53 -52c0 -41 -35 -53 -52 -53c-3 0 -53 0 -53 56c0 89 74 181 187 181c122 0 212 -80 212 -194 c0 -100 -60 -154 -216 -292l-106 -103h180c22 0 88 0 95 8c10 15 17 59 22 89h25Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMONOSPACE-1D694" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-3D" x="803" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-30" x="1859" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="2360" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-31" x="2805" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="3305" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-32" x="3750" y="0"></use>
</g>
</svg>) is across the <tt>k</tt>th edge of the interior face, and the interior
face is across the <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.223ex" height="2.343ex" style="vertical-align: -0.505ex;" viewBox="0 -791.3 2248.9 1008.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">monospace k plus 1</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMONOSPACE-1D694" d="M508 30c0 -30 -26 -30 -41 -30h-118c-15 0 -40 0 -40 30c0 31 20 31 56 31l-119 155l-80 -74v-81h49c16 0 40 0 40 -31c0 -30 -25 -30 -40 -30h-154c-16 0 -40 0 -40 31c0 30 25 30 40 30h49v489h-49c-16 0 -40 0 -40 31c0 30 25 30 40 30h65c34 0 40 -10 40 -41v-352 l162 152h-37c-15 0 -40 0 -40 30c0 31 24 31 40 31h154c15 0 41 0 41 -31c0 -30 -26 -30 -41 -30h-35l-123 -115l149 -194h31c15 0 41 0 41 -31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2B" d="M722 250c0 -11 -9 -20 -20 -20h-293v-293c0 -11 -9 -20 -20 -20s-20 9 -20 20v293h-293c-11 0 -20 9 -20 20s9 20 20 20h293v293c0 11 9 20 20 20s20 -9 20 -20v-293h293c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMONOSPACE-1D694" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2B" x="747" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-31" x="1748" y="0"></use>
</g>
</svg>st edge of the <tt>k</tt>th face.

</p>
<p></p>
<span class="anchor" id="fragment-Updatechildrenmonofpointersforsiblings-0"></span><div class="fragmentname">&lt;&lt;Update children <tt>f</tt> pointers for siblings&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">face-&gt;<a href="#SDFace::children" class="code">children</a>[3]-&gt;<a href="#SDFace::f" class="code">f</a>[j] = face-&gt;<a href="#SDFace::children" class="code">children</a>[<a href="#NEXT" class="code">NEXT</a>(j)];
face-&gt;<a href="#SDFace::children" class="code">children</a>[j]-&gt;<a href="#SDFace::f" class="code">f</a>[<a href="#NEXT" class="code">NEXT</a>(j)] = face-&gt;<a href="#SDFace::children" class="code">children</a>[3];</div><p>


</p>
<p>We&rsquo;ll now update the children&rsquo;s face neighbor pointers that point to children
of other parents.  Only the first three children need to be addressed here; the
interior child&rsquo;s neighbor pointers have already been fully initialized.
Inspection of Figure&nbsp;<a href="#fig:tri-face-split">3.36</a> reveals that the <tt>k</tt>th and
<tt>PREV(k)</tt>th edges of the <tt>k</tt>th child need to be set.  To set the <tt>k</tt>th
edge of the <tt>k</tt>th child, we first find the <tt>k</tt>th edge of the parent face, then
the neighbor parent <tt>f2</tt> across that edge.  If <tt>f2</tt> exists (meaning
we aren&rsquo;t on a boundary), the neighbor parent index for the vertex
<tt>v[k]</tt> is found.  That index is equal to the index of the neighbor child we are
searching for.  This process is then repeated to find the child across the
<tt>PREV(k)</tt>th edge.

</p>
<p></p>
<span class="anchor" id="fragment-Updatechildrenmonofpointersforneighborchildren-0"></span><div class="fragmentname">&lt;&lt;Update children <tt>f</tt> pointers for neighbor children&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">SDFace *f2 = face-&gt;<a href="#SDFace::f" class="code">f</a>[j];
face-&gt;<a href="#SDFace::children" class="code">children</a>[j]-&gt;<a href="#SDFace::f" class="code">f</a>[j] =
    f2 ? f2-&gt;<a href="#SDFace::children" class="code">children</a>[f2-&gt;<a href="#SDFace::vnum" class="code">vnum</a>(face-&gt;v[j])] : nullptr;
f2 = face-&gt;<a href="#SDFace::f" class="code">f</a>[<a href="#PREV" class="code">PREV</a>(j)];
face-&gt;<a href="#SDFace::children" class="code">children</a>[j]-&gt;<a href="#SDFace::f" class="code">f</a>[<a href="#PREV" class="code">PREV</a>(j)] = 
    f2 ? f2-&gt;<a href="#SDFace::children" class="code">children</a>[f2-&gt;<a href="#SDFace::vnum" class="code">vnum</a>(face-&gt;v[j])] : nullptr;</div><p>


</p>
<p>Finally, we handle the fourth step in the topological updates: setting the
children faces&rsquo;  vertex pointers.

</p>
<p></p>
<span class="anchor" id="fragment-Updatefacevertexpointers-0"></span><div class="fragmentname">&lt;&lt;Update face vertex pointers&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">for (SDFace *face : f) {
    for (int j = 0; j &lt; 3; ++j) {
        &lt;&lt;<span class="fragmentname"><a href="#fragment-Updatechildvertexpointertonewevenvertex-0">Update child vertex pointer to new even vertex</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-487" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-487"><i></i></a><div id="fragbit-487" class="collapse"><div class="fragmentcode">           face-&gt;<a href="#SDFace::children" class="code">children</a>[j]-&gt;<a href="#SDFace::v" class="code">v</a>[j] = face-&gt;<a href="#SDFace::v" class="code">v</a>[j]-&gt;<a href="#SDVertex::child" class="code">child</a>;</div></div>
        &lt;&lt;<span class="fragmentname"><a href="#fragment-Updatechildvertexpointertonewoddvertex-0">Update child vertex pointer to new odd vertex</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-488" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-488"><i></i></a><div id="fragbit-488" class="collapse"><div class="fragmentcode">           SDVertex *vert = edgeVerts[SDEdge(face-&gt;<a href="#SDFace::v" class="code">v</a>[j], face-&gt;<a href="#SDFace::v" class="code">v</a>[<a href="#NEXT" class="code">NEXT</a>(j)])];
           face-&gt;<a href="#SDFace::children" class="code">children</a>[j]-&gt;<a href="#SDFace::v" class="code">v</a>[<a href="#NEXT" class="code">NEXT</a>(j)] = vert;
           face-&gt;<a href="#SDFace::children" class="code">children</a>[<a href="#NEXT" class="code">NEXT</a>(j)]-&gt;<a href="#SDFace::v" class="code">v</a>[j] = vert;
           face-&gt;<a href="#SDFace::children" class="code">children</a>[3]-&gt;<a href="#SDFace::v" class="code">v</a>[j] = vert;</div></div>
    }
}</div><p>


</p>
<p>


</p>
<p>For the <tt>k</tt>th child face (for <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="9.874ex" height="2.509ex" style="vertical-align: -0.671ex;" viewBox="0 -791.3 4251.4 1080.4" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">monospace k equals 0 comma 1 comma 2</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMONOSPACE-1D694" d="M508 30c0 -30 -26 -30 -41 -30h-118c-15 0 -40 0 -40 30c0 31 20 31 56 31l-119 155l-80 -74v-81h49c16 0 40 0 40 -31c0 -30 -25 -30 -40 -30h-154c-16 0 -40 0 -40 31c0 30 25 30 40 30h49v489h-49c-16 0 -40 0 -40 31c0 30 25 30 40 30h65c34 0 40 -10 40 -41v-352 l162 152h-37c-15 0 -40 0 -40 30c0 31 24 31 40 31h154c15 0 41 0 41 -31c0 -30 -26 -30 -41 -30h-35l-123 -115l149 -194h31c15 0 41 0 41 -31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-3D" d="M722 347c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20zM722 153c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-30" d="M460 320c0 -79 -5 -157 -37 -226c-44 -95 -120 -116 -174 -116c-49 0 -122 20 -165 101c-41 76 -45 166 -45 241c0 80 5 158 37 227c41 93 114 119 174 119c42 0 124 -16 170 -112c35 -74 40 -154 40 -234zM377 332c0 63 0 139 -10 195c-19 99 -85 117 -118 117 c-25 0 -100 -9 -119 -128c-8 -54 -8 -120 -8 -184c0 -59 0 -151 11 -211c18 -96 77 -121 116 -121c45 0 102 30 117 125c11 64 11 132 11 207Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2C" d="M203 1c0 -117 -80 -194 -91 -194c-5 0 -10 4 -10 11c0 3 0 5 11 16c33 33 68 93 68 167c0 14 -2 15 -2 15s-2 -1 -5 -3c-10 -9 -23 -13 -35 -13c-33 0 -53 26 -53 53c0 28 20 53 53 53c39 0 64 -39 64 -105Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-32" d="M449 174l-28 -174h-371c0 24 0 26 11 37l192 214c55 62 105 141 105 221c0 82 -43 163 -134 163c-58 0 -112 -37 -135 -102c3 1 5 1 13 1c35 0 53 -26 53 -52c0 -41 -35 -53 -52 -53c-3 0 -53 0 -53 56c0 89 74 181 187 181c122 0 212 -80 212 -194 c0 -100 -60 -154 -216 -292l-106 -103h180c22 0 88 0 95 8c10 15 17 59 22 89h25Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMONOSPACE-1D694" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-3D" x="803" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-30" x="1859" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="2360" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-31" x="2805" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="3305" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-32" x="3750" y="0"></use>
</g>
</svg>), the <tt>k</tt>th
vertex corresponds to the even vertex
that is adjacent to the child face. For the noninterior child faces, there is one
even vertex and two odd vertices; for the interior child face, there are
three odd vertices. This vertex can be found by following the
child pointer of the parent vertex, available from the parent face.

</p>
<p></p>
<span class="anchor" id="fragment-Updatechildvertexpointertonewevenvertex-0"></span><div class="fragmentname">&lt;&lt;Update child vertex pointer to new even vertex&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">face-&gt;<a href="#SDFace::children" class="code">children</a>[j]-&gt;<a href="#SDFace::v" class="code">v</a>[j] = face-&gt;<a href="#SDFace::v" class="code">v</a>[j]-&gt;<a href="#SDVertex::child" class="code">child</a>;</div><p>


</p>
<p>To update the rest of the vertex pointers, the
<tt>edgeVerts</tt> associative array is reused to find the odd vertex for each split edge
of the parent face.  Three child faces have that vertex as an incident
vertex.  The vertex indices for the three faces are easily
found, again based on the numbering scheme established in
Figure&nbsp;<a href="#fig:tri-face-split">3.36</a>.

</p>
<p></p>
<span class="anchor" id="fragment-Updatechildvertexpointertonewoddvertex-0"></span><div class="fragmentname">&lt;&lt;Update child vertex pointer to new odd vertex&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">SDVertex *vert = edgeVerts[SDEdge(face-&gt;<a href="#SDFace::v" class="code">v</a>[j], face-&gt;<a href="#SDFace::v" class="code">v</a>[<a href="#NEXT" class="code">NEXT</a>(j)])];
face-&gt;<a href="#SDFace::children" class="code">children</a>[j]-&gt;<a href="#SDFace::v" class="code">v</a>[<a href="#NEXT" class="code">NEXT</a>(j)] = vert;
face-&gt;<a href="#SDFace::children" class="code">children</a>[<a href="#NEXT" class="code">NEXT</a>(j)]-&gt;<a href="#SDFace::v" class="code">v</a>[j] = vert;
face-&gt;<a href="#SDFace::children" class="code">children</a>[3]-&gt;<a href="#SDFace::v" class="code">v</a>[j] = vert;</div><p>


</p>
<p>After the geometric and topological work has been done for a subdivision
step, the newly created vertices and faces are moved into the <tt>v</tt> and
<tt>f</tt> arrays:

</p>
<p></p>
<span class="anchor" id="fragment-Preparefornextlevelofsubdivision-0"></span><div class="fragmentname">&lt;&lt;Prepare for next level of subdivision&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">f = newFaces;
v = newVertices;</div><p>


</p>
<p>

</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#x2-TotheLimitSurfaceandOutput"><i class="fas fa-link h3h4marginlink"></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span id="x2-TotheLimitSurfaceandOutput"></span><h4>To the Limit Surface and Output</h4><p>


</p>
<p>One of the remarkable properties of subdivision surfaces is that there are
special subdivision rules that give the positions that the vertices
of the mesh would have if we continued subdividing forever.  We apply these
rules here to initialize an array of limit surface positions, <tt>pLimit</tt>.
Note that it&rsquo;s important to temporarily store the limit surface positions
somewhere other than in the vertices while the computation is taking place.
Because the limit surface position of each vertex depends on the original
positions of its surrounding vertices, the original positions of all vertices
must remain unchanged until the computation is complete.

</p>
<p>The limit rule for a boundary vertex weights the
two neighbor vertices by <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.487ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 1501.5 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">1 slash 5</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2F" d="M445 730c0 -2 0 -5 -1 -7l-349 -960c-3 -8 -10 -13 -19 -13c-11 0 -20 9 -20 20c0 2 0 5 1 7l349 960c3 8 10 13 19 13c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-35" d="M449 201c0 -127 -102 -223 -218 -223c-112 0 -181 97 -181 183c0 46 35 53 49 53c33 0 50 -25 50 -49s-17 -49 -50 -49c-11 0 -14 1 -17 2c17 -59 74 -112 147 -112c46 0 83 26 107 65c24 42 24 102 24 137c0 50 -2 89 -18 126c-8 18 -33 64 -85 64 c-81 0 -118 -54 -129 -70c-4 -6 -6 -9 -13 -9c-14 0 -14 8 -14 26v296c0 16 0 24 10 24c0 0 4 0 12 -3c47 -21 93 -28 133 -28c67 0 116 20 136 29c5 3 8 3 8 3c7 0 10 -5 10 -11c0 -13 -70 -104 -193 -104c-32 0 -65 7 -85 13v-195c36 35 79 51 127 51 c108 0 190 -100 190 -219Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-31" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2F" x="500" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-35" x="1001" y="0"></use>
</g>
</svg> and the center vertex by <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.487ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 1501.5 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">3 slash 5</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-33" d="M457 171c0 -102 -91 -193 -213 -193c-109 0 -202 66 -202 157c0 44 32 58 56 58c29 0 56 -20 56 -56c0 -38 -31 -60 -66 -55c35 -59 110 -76 153 -76c44 0 113 29 113 165c0 98 -37 166 -119 166h-44c-17 0 -24 0 -24 11c0 10 7 11 15 12c7 0 31 2 39 3c25 1 59 4 89 52 c26 44 28 102 28 114c0 90 -55 112 -96 112c-36 0 -102 -13 -133 -62c15 0 62 0 62 -50c0 -29 -20 -51 -51 -51c-29 0 -51 19 -51 52c0 76 76 136 177 136c96 0 184 -56 184 -138c0 -79 -58 -149 -140 -176c104 -21 167 -99 167 -181Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2F" d="M445 730c0 -2 0 -5 -1 -7l-349 -960c-3 -8 -10 -13 -19 -13c-11 0 -20 9 -20 20c0 2 0 5 1 7l349 960c3 8 10 13 19 13c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-35" d="M449 201c0 -127 -102 -223 -218 -223c-112 0 -181 97 -181 183c0 46 35 53 49 53c33 0 50 -25 50 -49s-17 -49 -50 -49c-11 0 -14 1 -17 2c17 -59 74 -112 147 -112c46 0 83 26 107 65c24 42 24 102 24 137c0 50 -2 89 -18 126c-8 18 -33 64 -85 64 c-81 0 -118 -54 -129 -70c-4 -6 -6 -9 -13 -9c-14 0 -14 8 -14 26v296c0 16 0 24 10 24c0 0 4 0 12 -3c47 -21 93 -28 133 -28c67 0 116 20 136 29c5 3 8 3 8 3c7 0 10 -5 10 -11c0 -13 -70 -104 -193 -104c-32 0 -65 7 -85 13v-195c36 35 79 51 127 51 c108 0 190 -100 190 -219Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-33" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2F" x="500" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-35" x="1001" y="0"></use>
</g>
</svg>. The rule for
interior vertices is based on a function <tt>loopGamma()</tt>, which computes
appropriate vertex weights based on the valence of the vertex.

</p>
<p></p>
<span class="anchor" id="fragment-Pushverticestolimitsurface-0"></span><div class="fragmentname">&lt;&lt;Push vertices to limit surface&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">std::unique_ptr&lt;<a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a>[]&gt; pLimit(new <a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a>[v.size()]);
for (size_t i = 0; i &lt; v.size(); ++i) {
    if (v[i]-&gt;<a href="#SDVertex::boundary" class="code">boundary</a>)
        pLimit[i] =  <a href="#LoopSubdiv::weightBoundary" class="code">weightBoundary</a>(v[i], 1.f / 5.f);
    else
        pLimit[i] =  <a href="#LoopSubdiv::weightOneRing" class="code">weightOneRing</a>(v[i], <a href="#LoopSubdiv::loopGamma" class="code">loopGamma</a>(v[i]-&gt;<a href="#SDVertex::valence" class="code">valence</a>()));
}
for (size_t i = 0; i &lt; v.size(); ++i)
    v[i]-&gt;p = pLimit[i];</div><p>


</p>
<p></p>
<span class="anchor" id="fragment-LoopSubdivInlineFunctions-2"></span><div class="fragmentname">&lt;&lt;LoopSubdiv Inline Functions&gt;&gt;+=&nbsp;<a href="#fragment-LoopSubdivInlineFunctions-1"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode">inline Float <span class="anchor" id="LoopSubdiv::loopGamma"></span>loopGamma(int valence) {
    return 1.f / (valence + 3.f / (8.f * <a href="#LoopSubdiv::beta" class="code">beta</a>(valence)));
}</div><p>


</p>
<p>In order to generate a smooth-looking triangle mesh with per-vertex surface
normals, a pair of nonparallel tangent vectors to the limit surface is
computed at each
vertex.  As with the limit rule for positions, this is an analytic
computation that gives the precise tangents on the actual limit surface.

</p>
<p>
</p>
<span class="anchor" id="fragment-Computevertextangentsonlimitsurface-0"></span><div class="fragmentname">&lt;&lt;Compute vertex tangents on limit surface&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">std::vector&lt;<a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a>&gt; Ns;
Ns.reserve(v.size());
std::vector&lt;<a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a>&gt; pRing(16, <a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a>());
for (SDVertex *vertex : v) {
    <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> S(0,0,0), T(0,0,0);
    int <a href="#SDVertex::valence" class="code">valence</a> = vertex-&gt;<a href="#SDVertex::valence" class="code">valence</a>();
    if (<a href="#SDVertex::valence" class="code">valence</a> &gt; (int)pRing.size())
        pRing.resize(<a href="#SDVertex::valence" class="code">valence</a>);
    vertex-&gt;<a href="#SDVertex::oneRing" class="code">oneRing</a>(&amp;pRing[0]);
    if (!vertex-&gt;<a href="#SDVertex::boundary" class="code">boundary</a>) {
        &lt;&lt;<span class="fragmentname"><a href="#fragment-Computetangentsofinteriorface-0">Compute tangents of interior face</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-489" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-489"><i></i></a><div id="fragbit-489" class="collapse"><div class="fragmentcode">           for (int j = 0; j &lt; valence; ++j) {
               S += std::cos(2 * <a href="../Utilities/Main_Include_File.html#Pi" class="code">Pi</a> * j / valence) * <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a>(pRing[j]);
               T += std::sin(2 * <a href="../Utilities/Main_Include_File.html#Pi" class="code">Pi</a> * j / valence) * <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a>(pRing[j]);
           }</div></div>
    } else {
        &lt;&lt;<span class="fragmentname"><a href="#fragment-Computetangentsofboundaryface-0">Compute tangents of boundary face</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-490" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-490"><i></i></a><div id="fragbit-490" class="collapse"><div class="fragmentcode">           S = pRing[valence - 1] - pRing[0];
           if (valence == 2)
               T = <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a>(pRing[0] + pRing[1] - 2 * vertex-&gt;p);
           else if (valence == 3)
               T = pRing[1] - vertex-&gt;p;
           else if (valence == 4) // regular
               T = <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a>(-1 * pRing[0] +  2 * pRing[1] + 2 * pRing[2] + 
                            -1 * pRing[3] + -2 * vertex-&gt;p);
           else {
               Float theta = <a href="../Utilities/Main_Include_File.html#Pi" class="code">Pi</a> / float(valence - 1);
               T = <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a>(std::sin(theta) * (pRing[0] + pRing[valence - 1]));
               for (int k = 1; k &lt; valence - 1; ++k) {
                   Float wt = (2 * std::cos(theta) - 2) * std::sin((k) * theta);
                   T += <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a>(wt * pRing[k]);
               }
               T = -T;
           }</div></div>
    }
    Ns.push_back(<a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a>(<a href="../Geometry_and_Transformations/Vectors.html#Cross" class="code">Cross</a>(S, T)));
}</div><p>


</p>
<p>
Figure&nbsp;<a href="#fig:loop-interior-tangent">3.37</a> shows the setting for computing
tangents in the mesh interior.  The center vertex is given a weight of zero,
and the neighbors are given weights <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.464ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 1060.8 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">w Subscript i</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D464" d="M691 372c0 -48 -32 -182 -66 -260c-26 -60 -70 -123 -145 -123c-30 0 -99 6 -125 70c-40 -70 -87 -70 -104 -70c-75 0 -142 35 -142 126c0 38 12 84 56 202c7 17 18 45 18 70c0 32 -16 33 -25 33c-35 0 -74 -31 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10 c0 9 37 154 132 154c49 0 82 -37 82 -82c0 -20 -6 -34 -17 -64c-47 -123 -52 -162 -52 -194c0 -17 0 -91 80 -91c39 0 69 31 92 84c-1 5 -1 7 -1 18c0 18 2 36 9 66c7 26 54 217 57 224c7 20 25 28 37 28c15 0 29 -9 29 -27c0 -6 -10 -43 -15 -65l-42 -168 c-4 -14 -11 -45 -11 -73c0 -57 27 -87 74 -87c49 0 84 35 110 88c26 51 55 149 55 183c0 48 -25 74 -36 85c-9 8 -15 14 -15 27c0 22 25 48 50 48c17 0 44 -15 44 -70Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D456" d="M284 625c0 -30 -30 -53 -53 -53c-24 0 -38 17 -38 36c0 27 27 53 54 53c23 0 37 -16 37 -36zM293 143c0 -9 -37 -154 -131 -154c-48 0 -82 35 -82 82c0 21 13 54 23 80c16 43 61 159 69 185c4 10 11 31 11 52c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124 c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 38 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -13 -53c-10 -27 -10 -29 -22 -58l-39 -105c-23 -61 -29 -75 -29 -100c0 -23 7 -33 24 -33c51 0 84 61 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D464" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D456" x="1013" y="-213"></use>
</g>
</svg>.

</p>
<p> </p>
<span class="anchor" id="fig:loop-interior-tangent"></span><div class="card outerfigure"><div class="card-body figure"><p>



</p>
<div class="figure-row">
  <a href="Subdiv%20tangents.svg" title=""><img src="Subdiv%20tangents.svg" width=237 height=273 style="max-width: 100%;"></a>
</div>
<p>


</p>
<figcaption class="caption">Figure 3.37: <span class="legend"> To&nbsp;compute tangents for interior
vertices, the one-ring vertices are weighted with weights <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.464ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 1060.8 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">w Subscript i</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D464" d="M691 372c0 -48 -32 -182 -66 -260c-26 -60 -70 -123 -145 -123c-30 0 -99 6 -125 70c-40 -70 -87 -70 -104 -70c-75 0 -142 35 -142 126c0 38 12 84 56 202c7 17 18 45 18 70c0 32 -16 33 -25 33c-35 0 -74 -31 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10 c0 9 37 154 132 154c49 0 82 -37 82 -82c0 -20 -6 -34 -17 -64c-47 -123 -52 -162 -52 -194c0 -17 0 -91 80 -91c39 0 69 31 92 84c-1 5 -1 7 -1 18c0 18 2 36 9 66c7 26 54 217 57 224c7 20 25 28 37 28c15 0 29 -9 29 -27c0 -6 -10 -43 -15 -65l-42 -168 c-4 -14 -11 -45 -11 -73c0 -57 27 -87 74 -87c49 0 84 35 110 88c26 51 55 149 55 183c0 48 -25 74 -36 85c-9 8 -15 14 -15 27c0 22 25 48 50 48c17 0 44 -15 44 -70Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D456" d="M284 625c0 -30 -30 -53 -53 -53c-24 0 -38 17 -38 36c0 27 27 53 54 53c23 0 37 -16 37 -36zM293 143c0 -9 -37 -154 -131 -154c-48 0 -82 35 -82 82c0 21 13 54 23 80c16 43 61 159 69 185c4 10 11 31 11 52c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124 c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 38 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -13 -53c-10 -27 -10 -29 -22 -58l-39 -105c-23 -61 -29 -75 -29 -100c0 -23 7 -33 24 -33c51 0 84 61 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D464" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D456" x="1013" y="-213"></use>
</g>
</svg>.  The
center vertex, where the tangent is being computed, always has a weight of
0.</span>
</figcaption><p>


</p>
</div></div><p>


</p>
<p>To&nbsp;compute the first tangent
vector <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.056ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 454.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">bold s</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D42C" d="M415 140c0 -146 -154 -146 -185 -146c-20 0 -72 0 -118 32l-26 -17c-21 -15 -23 -15 -30 -15c-18 0 -18 9 -18 28v109c0 23 0 29 24 29c14 0 19 0 24 -14c12 -43 38 -116 144 -116c22 0 114 0 114 75c0 59 -75 72 -111 78c-77 14 -115 20 -155 55c-20 17 -40 44 -40 84 c0 131 154 131 184 131c40 0 75 -6 101 -19c39 19 41 19 45 19c18 0 18 -9 18 -28v-80c0 -23 0 -28 -24 -28c-21 0 -22 5 -23 20c-5 55 -43 84 -118 84c-19 0 -112 0 -112 -62c0 -47 65 -58 102 -65c78 -13 110 -19 149 -48c35 -28 55 -63 55 -106Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D42C" x="0" y="0"></use>
</g>
</svg>, the weights are
</p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">

</div>
<div class="col-md-10 col-lg-8">
<div class="displaymath"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="16.528ex" height="5.509ex" style="vertical-align: -2.171ex;" viewBox="0 -1437.2 7116.4 2372" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">w Subscript i Baseline equals cosine left-parenthesis StartFraction 2 pi i Over n EndFraction right-parenthesis comma</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D464" d="M691 372c0 -48 -32 -182 -66 -260c-26 -60 -70 -123 -145 -123c-30 0 -99 6 -125 70c-40 -70 -87 -70 -104 -70c-75 0 -142 35 -142 126c0 38 12 84 56 202c7 17 18 45 18 70c0 32 -16 33 -25 33c-35 0 -74 -31 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10 c0 9 37 154 132 154c49 0 82 -37 82 -82c0 -20 -6 -34 -17 -64c-47 -123 -52 -162 -52 -194c0 -17 0 -91 80 -91c39 0 69 31 92 84c-1 5 -1 7 -1 18c0 18 2 36 9 66c7 26 54 217 57 224c7 20 25 28 37 28c15 0 29 -9 29 -27c0 -6 -10 -43 -15 -65l-42 -168 c-4 -14 -11 -45 -11 -73c0 -57 27 -87 74 -87c49 0 84 35 110 88c26 51 55 149 55 183c0 48 -25 74 -36 85c-9 8 -15 14 -15 27c0 22 25 48 50 48c17 0 44 -15 44 -70Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D456" d="M284 625c0 -30 -30 -53 -53 -53c-24 0 -38 17 -38 36c0 27 27 53 54 53c23 0 37 -16 37 -36zM293 143c0 -9 -37 -154 -131 -154c-48 0 -82 35 -82 82c0 21 13 54 23 80c16 43 61 159 69 185c4 10 11 31 11 52c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124 c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 38 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -13 -53c-10 -27 -10 -29 -22 -58l-39 -105c-23 -61 -29 -75 -29 -100c0 -23 7 -33 24 -33c51 0 84 61 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-3D" d="M722 347c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20zM722 153c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-63" d="M415 119c0 -10 -32 -130 -166 -130c-116 0 -215 99 -215 227c0 124 92 232 217 232c77 0 153 -39 153 -107c0 -30 -20 -47 -46 -47c-28 0 -46 20 -46 46c0 13 6 43 47 46c-35 36 -98 37 -107 37c-53 0 -135 -42 -135 -205c0 -161 88 -204 141 -204c37 0 102 12 131 105 c2 6 4 10 13 10c3 0 13 0 13 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-6F" d="M471 214c0 -127 -101 -225 -222 -225c-117 0 -221 96 -221 225c0 125 97 234 222 234c121 0 221 -106 221 -234zM388 222c0 38 0 96 -26 139s-69 65 -113 65c-40 0 -87 -21 -114 -67c-24 -44 -24 -98 -24 -137c0 -36 0 -97 25 -141c27 -46 71 -67 114 -67 c50 0 94 29 116 74c22 44 22 98 22 134Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-73" d="M360 128c0 -72 -46 -139 -161 -139c-21 0 -66 1 -110 43c-18 -19 -18 -21 -20 -23c-19 -19 -20 -20 -25 -20c-11 0 -11 7 -11 24v132c0 18 0 25 13 25c10 0 11 -4 14 -17c19 -85 55 -142 139 -142c78 0 113 40 113 91c0 72 -82 88 -104 92c-72 14 -100 20 -132 46 c-27 22 -43 50 -43 85c0 56 38 123 160 123c15 0 56 0 94 -28c4 3 14 12 17 16c13 12 15 12 20 12c11 0 11 -7 11 -24v-101c0 -19 0 -24 -13 -24c0 0 -11 0 -12 9c-2 31 -7 121 -117 121c-86 0 -112 -41 -112 -76c0 -58 67 -71 123 -82c42 -8 81 -16 114 -48 c12 -12 42 -42 42 -95Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-28" d="M332 -238c0 -5 -5 -10 -10 -10c-2 0 -4 1 -6 2c-110 83 -215 283 -215 454v84c0 171 105 371 215 454c2 1 4 2 6 2c5 0 10 -5 10 -10c0 -3 -2 -6 -4 -8c-104 -78 -173 -278 -173 -438v-84c0 -160 69 -360 173 -438c2 -2 4 -5 4 -8Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-32" d="M449 174l-28 -174h-371c0 24 0 26 11 37l192 214c55 62 105 141 105 221c0 82 -43 163 -134 163c-58 0 -112 -37 -135 -102c3 1 5 1 13 1c35 0 53 -26 53 -52c0 -41 -35 -53 -52 -53c-3 0 -53 0 -53 56c0 89 74 181 187 181c122 0 212 -80 212 -194 c0 -100 -60 -154 -216 -292l-106 -103h180c22 0 88 0 95 8c10 15 17 59 22 89h25Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D70B" d="M567 407c0 -34 -36 -34 -49 -34h-114c-11 -52 -18 -106 -18 -159c0 -28 0 -93 29 -165c6 -14 6 -16 6 -22c0 -20 -21 -38 -41 -38c-15 0 -26 6 -36 50c-8 34 -8 61 -8 76c0 67 9 110 42 258h-113l-56 -221c-13 -50 -13 -52 -27 -98c-12 -37 -20 -65 -50 -65 c-13 0 -29 8 -29 27c0 7 0 9 8 24c42 91 96 212 128 333h-57c-20 0 -78 0 -127 -77c-6 -8 -8 -12 -16 -12c-12 0 -12 10 -12 10c0 5 26 51 61 90c44 47 82 47 104 47h335c19 0 40 0 40 -24Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D45B" d="M571 143c0 -8 -37 -154 -131 -154c-47 0 -82 35 -82 82c0 11 1 23 10 46c16 43 65 171 65 233c0 33 -9 70 -54 70c-95 0 -148 -91 -163 -122l-13 -50c-5 -23 -11 -45 -17 -67l-22 -90c-6 -25 -18 -72 -19 -74c-7 -20 -25 -28 -37 -28c-15 0 -29 9 -29 27c0 5 6 28 9 43 l58 231c13 52 16 63 16 84c0 33 -11 46 -31 46c-36 0 -56 -48 -73 -119c-6 -22 -7 -23 -17 -23c0 0 -12 0 -12 10c0 4 14 63 30 97c10 18 29 57 75 57s87 -31 92 -87c17 23 66 87 156 87c72 0 115 -40 115 -107c0 -57 -42 -167 -61 -220c-9 -22 -18 -46 -18 -71 c0 -23 7 -33 24 -33c49 0 82 56 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-29" d="M288 208c0 -171 -105 -371 -215 -454c-2 -1 -4 -2 -6 -2c-5 0 -10 5 -10 10c0 3 2 6 4 8c104 78 173 278 173 438v84c0 160 -69 360 -173 438c-2 2 -4 5 -4 8c0 5 5 10 10 10c2 0 4 -1 6 -2c110 -83 215 -283 215 -454v-84Z"></path>
<path stroke-width="1" id="E1-LATINMODERNSIZE5-28" d="M608 -780c0 -9 -7 -16 -16 -16c-4 0 -7 1 -10 3c-199 150 -381 545 -381 893v300c0 348 182 743 381 893c3 2 6 3 10 3c9 0 16 -7 16 -16c0 -5 -3 -10 -6 -13c-190 -142 -323 -535 -323 -867v-300c0 -332 133 -725 323 -867c3 -3 6 -8 6 -13Z"></path>
<path stroke-width="1" id="E1-LATINMODERNSIZE5-29" d="M462 100c0 -348 -182 -743 -382 -893c-2 -2 -6 -3 -9 -3c-9 0 -16 7 -16 16c0 5 2 10 6 13c190 142 323 535 323 867v300c0 332 -133 725 -323 867c-4 3 -6 8 -6 13c0 9 7 16 16 16c3 0 7 -1 9 -3c200 -150 382 -545 382 -893v-300Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2C" d="M203 1c0 -117 -80 -194 -91 -194c-5 0 -10 4 -10 11c0 3 0 5 11 16c33 33 68 93 68 167c0 14 -2 15 -2 15s-2 -1 -5 -3c-10 -9 -23 -13 -35 -13c-33 0 -53 26 -53 53c0 28 20 53 53 53c39 0 64 -39 64 -105Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D464" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D456" x="1013" y="-213"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-3D" x="1338" y="0"></use>
<g transform="translate(2394,0)">
 <use xlink:href="#E1-LATINMODERNMAIN-63"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-6F" x="444" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-73" x="945" y="0"></use>
</g>
<g transform="translate(3734,0)">
 <use xlink:href="#E1-LATINMODERNSIZE5-28"></use>
<g transform="translate(663,0)">
<g transform="translate(120,0)">
<rect stroke="none" width="1536" height="60" x="0" y="220"></rect>
<g transform="translate(60,676)">
 <use xlink:href="#E1-LATINMODERNMAIN-32" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D70B" x="500" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D456" x="1071" y="0"></use>
</g>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D45B" x="468" y="-686"></use>
</g>
</g>
 <use xlink:href="#E1-LATINMODERNSIZE5-29" x="2440" y="0"></use>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="6837" y="0"></use>
</g>
</svg>
</div>
<p>

 where <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 600.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">n</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D45B" d="M571 143c0 -8 -37 -154 -131 -154c-47 0 -82 35 -82 82c0 11 1 23 10 46c16 43 65 171 65 233c0 33 -9 70 -54 70c-95 0 -148 -91 -163 -122l-13 -50c-5 -23 -11 -45 -17 -67l-22 -90c-6 -25 -18 -72 -19 -74c-7 -20 -25 -28 -37 -28c-15 0 -29 9 -29 27c0 5 6 28 9 43 l58 231c13 52 16 63 16 84c0 33 -11 46 -31 46c-36 0 -56 -48 -73 -119c-6 -22 -7 -23 -17 -23c0 0 -12 0 -12 10c0 4 14 63 30 97c10 18 29 57 75 57s87 -31 92 -87c17 23 66 87 156 87c72 0 115 -40 115 -107c0 -57 -42 -167 -61 -220c-9 -22 -18 -46 -18 -71 c0 -23 7 -33 24 -33c49 0 82 56 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D45B" x="0" y="0"></use>
</g>
</svg> is the valence of the vertex.  The second tangent
<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.039ex" height="2.009ex" style="vertical-align: -0.338ex;" viewBox="0 -719.6 447.5 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">bold t</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D42D" d="M382 124c0 -73 -45 -130 -121 -130c-71 0 -158 22 -158 129v274h-82v36c99 3 148 102 149 202h47v-191h146v-47h-146v-276c0 -23 0 -87 58 -87c28 0 60 24 60 92v51h47v-53Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D42D" x="0" y="0"></use>
</g>
</svg> is
computed with weights
</p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">

</div>
<div class="col-md-10 col-lg-8">
<div class="displaymath"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="16.273ex" height="5.509ex" style="vertical-align: -2.171ex;" viewBox="0 -1437.2 7006.4 2372" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">w Subscript i Baseline equals sine left-parenthesis StartFraction 2 pi i Over n EndFraction right-parenthesis period</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D464" d="M691 372c0 -48 -32 -182 -66 -260c-26 -60 -70 -123 -145 -123c-30 0 -99 6 -125 70c-40 -70 -87 -70 -104 -70c-75 0 -142 35 -142 126c0 38 12 84 56 202c7 17 18 45 18 70c0 32 -16 33 -25 33c-35 0 -74 -31 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10 c0 9 37 154 132 154c49 0 82 -37 82 -82c0 -20 -6 -34 -17 -64c-47 -123 -52 -162 -52 -194c0 -17 0 -91 80 -91c39 0 69 31 92 84c-1 5 -1 7 -1 18c0 18 2 36 9 66c7 26 54 217 57 224c7 20 25 28 37 28c15 0 29 -9 29 -27c0 -6 -10 -43 -15 -65l-42 -168 c-4 -14 -11 -45 -11 -73c0 -57 27 -87 74 -87c49 0 84 35 110 88c26 51 55 149 55 183c0 48 -25 74 -36 85c-9 8 -15 14 -15 27c0 22 25 48 50 48c17 0 44 -15 44 -70Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D456" d="M284 625c0 -30 -30 -53 -53 -53c-24 0 -38 17 -38 36c0 27 27 53 54 53c23 0 37 -16 37 -36zM293 143c0 -9 -37 -154 -131 -154c-48 0 -82 35 -82 82c0 21 13 54 23 80c16 43 61 159 69 185c4 10 11 31 11 52c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124 c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 38 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -13 -53c-10 -27 -10 -29 -22 -58l-39 -105c-23 -61 -29 -75 -29 -100c0 -23 7 -33 24 -33c51 0 84 61 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-3D" d="M722 347c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20zM722 153c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-73" d="M360 128c0 -72 -46 -139 -161 -139c-21 0 -66 1 -110 43c-18 -19 -18 -21 -20 -23c-19 -19 -20 -20 -25 -20c-11 0 -11 7 -11 24v132c0 18 0 25 13 25c10 0 11 -4 14 -17c19 -85 55 -142 139 -142c78 0 113 40 113 91c0 72 -82 88 -104 92c-72 14 -100 20 -132 46 c-27 22 -43 50 -43 85c0 56 38 123 160 123c15 0 56 0 94 -28c4 3 14 12 17 16c13 12 15 12 20 12c11 0 11 -7 11 -24v-101c0 -19 0 -24 -13 -24c0 0 -11 0 -12 9c-2 31 -7 121 -117 121c-86 0 -112 -41 -112 -76c0 -58 67 -71 123 -82c42 -8 81 -16 114 -48 c12 -12 42 -42 42 -95Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-69" d="M247 0c-34 1 -69 3 -104 3l-110 -3v31c67 0 78 0 78 45v269c0 49 -9 55 -74 55v31l140 11v-367c0 -39 4 -44 70 -44v-31zM192 604c0 -25 -20 -53 -54 -53c-30 0 -53 26 -53 53c0 25 20 53 54 53c30 0 53 -26 53 -53Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-6E" d="M535 0l-112 3l-113 -3v31c67 0 78 0 78 45v233c0 57 -11 111 -74 111c-64 0 -135 -56 -135 -160v-184c0 -45 11 -45 78 -45v-31l-112 3l-113 -3v31c67 0 78 0 78 45v268c0 49 -8 56 -78 56v31l141 11v-105c28 62 75 105 148 105c58 0 91 -20 105 -37 c31 -36 31 -67 31 -153v-191c1 -30 26 -30 78 -30v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-28" d="M332 -238c0 -5 -5 -10 -10 -10c-2 0 -4 1 -6 2c-110 83 -215 283 -215 454v84c0 171 105 371 215 454c2 1 4 2 6 2c5 0 10 -5 10 -10c0 -3 -2 -6 -4 -8c-104 -78 -173 -278 -173 -438v-84c0 -160 69 -360 173 -438c2 -2 4 -5 4 -8Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-32" d="M449 174l-28 -174h-371c0 24 0 26 11 37l192 214c55 62 105 141 105 221c0 82 -43 163 -134 163c-58 0 -112 -37 -135 -102c3 1 5 1 13 1c35 0 53 -26 53 -52c0 -41 -35 -53 -52 -53c-3 0 -53 0 -53 56c0 89 74 181 187 181c122 0 212 -80 212 -194 c0 -100 -60 -154 -216 -292l-106 -103h180c22 0 88 0 95 8c10 15 17 59 22 89h25Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D70B" d="M567 407c0 -34 -36 -34 -49 -34h-114c-11 -52 -18 -106 -18 -159c0 -28 0 -93 29 -165c6 -14 6 -16 6 -22c0 -20 -21 -38 -41 -38c-15 0 -26 6 -36 50c-8 34 -8 61 -8 76c0 67 9 110 42 258h-113l-56 -221c-13 -50 -13 -52 -27 -98c-12 -37 -20 -65 -50 -65 c-13 0 -29 8 -29 27c0 7 0 9 8 24c42 91 96 212 128 333h-57c-20 0 -78 0 -127 -77c-6 -8 -8 -12 -16 -12c-12 0 -12 10 -12 10c0 5 26 51 61 90c44 47 82 47 104 47h335c19 0 40 0 40 -24Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D45B" d="M571 143c0 -8 -37 -154 -131 -154c-47 0 -82 35 -82 82c0 11 1 23 10 46c16 43 65 171 65 233c0 33 -9 70 -54 70c-95 0 -148 -91 -163 -122l-13 -50c-5 -23 -11 -45 -17 -67l-22 -90c-6 -25 -18 -72 -19 -74c-7 -20 -25 -28 -37 -28c-15 0 -29 9 -29 27c0 5 6 28 9 43 l58 231c13 52 16 63 16 84c0 33 -11 46 -31 46c-36 0 -56 -48 -73 -119c-6 -22 -7 -23 -17 -23c0 0 -12 0 -12 10c0 4 14 63 30 97c10 18 29 57 75 57s87 -31 92 -87c17 23 66 87 156 87c72 0 115 -40 115 -107c0 -57 -42 -167 -61 -220c-9 -22 -18 -46 -18 -71 c0 -23 7 -33 24 -33c49 0 82 56 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-29" d="M288 208c0 -171 -105 -371 -215 -454c-2 -1 -4 -2 -6 -2c-5 0 -10 5 -10 10c0 3 2 6 4 8c104 78 173 278 173 438v84c0 160 -69 360 -173 438c-2 2 -4 5 -4 8c0 5 5 10 10 10c2 0 4 -1 6 -2c110 -83 215 -283 215 -454v-84Z"></path>
<path stroke-width="1" id="E1-LATINMODERNSIZE5-28" d="M608 -780c0 -9 -7 -16 -16 -16c-4 0 -7 1 -10 3c-199 150 -381 545 -381 893v300c0 348 182 743 381 893c3 2 6 3 10 3c9 0 16 -7 16 -16c0 -5 -3 -10 -6 -13c-190 -142 -323 -535 -323 -867v-300c0 -332 133 -725 323 -867c3 -3 6 -8 6 -13Z"></path>
<path stroke-width="1" id="E1-LATINMODERNSIZE5-29" d="M462 100c0 -348 -182 -743 -382 -893c-2 -2 -6 -3 -9 -3c-9 0 -16 7 -16 16c0 5 2 10 6 13c190 142 323 535 323 867v300c0 332 -133 725 -323 867c-4 3 -6 8 -6 13c0 9 7 16 16 16c3 0 7 -1 9 -3c200 -150 382 -545 382 -893v-300Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2E" d="M192 53c0 -29 -24 -53 -53 -53s-53 24 -53 53s24 53 53 53s53 -24 53 -53Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D464" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D456" x="1013" y="-213"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-3D" x="1338" y="0"></use>
<g transform="translate(2394,0)">
 <use xlink:href="#E1-LATINMODERNMAIN-73"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-69" x="394" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-6E" x="673" y="0"></use>
</g>
<g transform="translate(3624,0)">
 <use xlink:href="#E1-LATINMODERNSIZE5-28"></use>
<g transform="translate(663,0)">
<g transform="translate(120,0)">
<rect stroke="none" width="1536" height="60" x="0" y="220"></rect>
<g transform="translate(60,676)">
 <use xlink:href="#E1-LATINMODERNMAIN-32" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D70B" x="500" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D456" x="1071" y="0"></use>
</g>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D45B" x="468" y="-686"></use>
</g>
</g>
 <use xlink:href="#E1-LATINMODERNSIZE5-29" x="2440" y="0"></use>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-2E" x="6727" y="0"></use>
</g>
</svg>
</div>
<p>


</p>
<p></p>
<span class="anchor" id="fragment-Computetangentsofinteriorface-0"></span><div class="fragmentname">&lt;&lt;Compute tangents of interior face&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">for (int j = 0; j &lt; valence; ++j) {
    S += std::cos(2 * <a href="../Utilities/Main_Include_File.html#Pi" class="code">Pi</a> * j / valence) * <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a>(pRing[j]);
    T += std::sin(2 * <a href="../Utilities/Main_Include_File.html#Pi" class="code">Pi</a> * j / valence) * <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a>(pRing[j]);
}</div><p>


</p>
<p>Tangents on boundary vertices are a bit trickier.
Figure&nbsp;<a href="#fig:loop-boundary-tangent">3.38</a> shows the ordering of
vertices in the one-ring expected in the following discussion.

</p>
<p></p>
<span class="anchor" id="fig:loop-boundary-tangent"></span><div class="card outerfigure"><div class="card-body figure"><p>



</p>
<div class="figure-row">
  <a href="Subdiv%20edge%20tangents.svg" title=""><img src="Subdiv%20edge%20tangents.svg" width=200 height=336 style="max-width: 100%;"></a>
</div>
<p>


</p>
<figcaption class="caption">Figure 3.38: <span class="legend"> Tangents at boundary vertices are
also computed as weighted averages of the adjacent vertices.  However, some of the
boundary tangent rules incorporate the value of the center vertex.</span>
</figcaption><p>


</p>
</div></div><p>


</p>
<p>The first tangent, known as the <em>across tangent</em>, is given by the
vector between the two neighboring boundary vertices:
</p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">

</div>
<div class="col-md-10 col-lg-8">
<div class="displaymath"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="14.47ex" height="2.343ex" style="vertical-align: -0.671ex;" viewBox="0 -719.6 6229.9 1008.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">bold s equals normal v Subscript n minus 1 Baseline minus normal v 0 period</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D42C" d="M415 140c0 -146 -154 -146 -185 -146c-20 0 -72 0 -118 32l-26 -17c-21 -15 -23 -15 -30 -15c-18 0 -18 9 -18 28v109c0 23 0 29 24 29c14 0 19 0 24 -14c12 -43 38 -116 144 -116c22 0 114 0 114 75c0 59 -75 72 -111 78c-77 14 -115 20 -155 55c-20 17 -40 44 -40 84 c0 131 154 131 184 131c40 0 75 -6 101 -19c39 19 41 19 45 19c18 0 18 -9 18 -28v-80c0 -23 0 -28 -24 -28c-21 0 -22 5 -23 20c-5 55 -43 84 -118 84c-19 0 -112 0 -112 -62c0 -47 65 -58 102 -65c78 -13 110 -19 149 -48c35 -28 55 -63 55 -106Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-3D" d="M722 347c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20zM722 153c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-76" d="M508 400c-66 -1 -83 -44 -92 -67l-131 -325c-4 -10 -8 -19 -21 -19s-15 5 -21 19l-144 355c-13 31 -17 37 -80 37v31c30 -2 70 -3 97 -3l109 3v-31c-18 0 -57 0 -57 -26c0 0 0 -4 6 -17l112 -279l102 255c4 11 6 15 6 24c0 19 -11 42 -48 43v31l87 -3c23 0 52 1 75 3v-31 Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D45B" d="M571 143c0 -8 -37 -154 -131 -154c-47 0 -82 35 -82 82c0 11 1 23 10 46c16 43 65 171 65 233c0 33 -9 70 -54 70c-95 0 -148 -91 -163 -122l-13 -50c-5 -23 -11 -45 -17 -67l-22 -90c-6 -25 -18 -72 -19 -74c-7 -20 -25 -28 -37 -28c-15 0 -29 9 -29 27c0 5 6 28 9 43 l58 231c13 52 16 63 16 84c0 33 -11 46 -31 46c-36 0 -56 -48 -73 -119c-6 -22 -7 -23 -17 -23c0 0 -12 0 -12 10c0 4 14 63 30 97c10 18 29 57 75 57s87 -31 92 -87c17 23 66 87 156 87c72 0 115 -40 115 -107c0 -57 -42 -167 -61 -220c-9 -22 -18 -46 -18 -71 c0 -23 7 -33 24 -33c49 0 82 56 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2212" d="M722 250c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-30" d="M460 320c0 -79 -5 -157 -37 -226c-44 -95 -120 -116 -174 -116c-49 0 -122 20 -165 101c-41 76 -45 166 -45 241c0 80 5 158 37 227c41 93 114 119 174 119c42 0 124 -16 170 -112c35 -74 40 -154 40 -234zM377 332c0 63 0 139 -10 195c-19 99 -85 117 -118 117 c-25 0 -100 -9 -119 -128c-8 -54 -8 -120 -8 -184c0 -59 0 -151 11 -211c18 -96 77 -121 116 -121c45 0 102 30 117 125c11 64 11 132 11 207Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2E" d="M192 53c0 -29 -24 -53 -53 -53s-53 24 -53 53s24 53 53 53s53 -24 53 -53Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D42C" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-3D" x="732" y="0"></use>
<g transform="translate(1788,0)">
 <use xlink:href="#E1-LATINMODERNMAIN-76" x="0" y="0"></use>
<g transform="translate(528,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D45B" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-2212" x="600" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-31" x="1379" y="0"></use>
</g>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-2212" x="3968" y="0"></use>
<g transform="translate(4969,0)">
 <use xlink:href="#E1-LATINMODERNMAIN-76" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-30" x="747" y="-213"></use>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-2E" x="5951" y="0"></use>
</g>
</svg>
</div>
<p>

The second tangent, known as the <em>transverse tangent</em>, is computed
based on the vertex&rsquo;s valence.  The center vertex is given a
weight <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.626ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 1130.8 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">w Subscript normal c</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D464" d="M691 372c0 -48 -32 -182 -66 -260c-26 -60 -70 -123 -145 -123c-30 0 -99 6 -125 70c-40 -70 -87 -70 -104 -70c-75 0 -142 35 -142 126c0 38 12 84 56 202c7 17 18 45 18 70c0 32 -16 33 -25 33c-35 0 -74 -31 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10 c0 9 37 154 132 154c49 0 82 -37 82 -82c0 -20 -6 -34 -17 -64c-47 -123 -52 -162 -52 -194c0 -17 0 -91 80 -91c39 0 69 31 92 84c-1 5 -1 7 -1 18c0 18 2 36 9 66c7 26 54 217 57 224c7 20 25 28 37 28c15 0 29 -9 29 -27c0 -6 -10 -43 -15 -65l-42 -168 c-4 -14 -11 -45 -11 -73c0 -57 27 -87 74 -87c49 0 84 35 110 88c26 51 55 149 55 183c0 48 -25 74 -36 85c-9 8 -15 14 -15 27c0 22 25 48 50 48c17 0 44 -15 44 -70Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-63" d="M415 119c0 -10 -32 -130 -166 -130c-116 0 -215 99 -215 227c0 124 92 232 217 232c77 0 153 -39 153 -107c0 -30 -20 -47 -46 -47c-28 0 -46 20 -46 46c0 13 6 43 47 46c-35 36 -98 37 -107 37c-53 0 -135 -42 -135 -205c0 -161 88 -204 141 -204c37 0 102 12 131 105 c2 6 4 10 13 10c3 0 13 0 13 -10Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D464" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-63" x="1013" y="-213"></use>
</g>
</svg> and  the one-ring vertices are given weights
specified by a vector <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="17.663ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 7605 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">left-parenthesis w 0 comma w 1 comma ellipsis comma w Subscript n minus 1 Baseline right-parenthesis</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-28" d="M332 -238c0 -5 -5 -10 -10 -10c-2 0 -4 1 -6 2c-110 83 -215 283 -215 454v84c0 171 105 371 215 454c2 1 4 2 6 2c5 0 10 -5 10 -10c0 -3 -2 -6 -4 -8c-104 -78 -173 -278 -173 -438v-84c0 -160 69 -360 173 -438c2 -2 4 -5 4 -8Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D464" d="M691 372c0 -48 -32 -182 -66 -260c-26 -60 -70 -123 -145 -123c-30 0 -99 6 -125 70c-40 -70 -87 -70 -104 -70c-75 0 -142 35 -142 126c0 38 12 84 56 202c7 17 18 45 18 70c0 32 -16 33 -25 33c-35 0 -74 -31 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10 c0 9 37 154 132 154c49 0 82 -37 82 -82c0 -20 -6 -34 -17 -64c-47 -123 -52 -162 -52 -194c0 -17 0 -91 80 -91c39 0 69 31 92 84c-1 5 -1 7 -1 18c0 18 2 36 9 66c7 26 54 217 57 224c7 20 25 28 37 28c15 0 29 -9 29 -27c0 -6 -10 -43 -15 -65l-42 -168 c-4 -14 -11 -45 -11 -73c0 -57 27 -87 74 -87c49 0 84 35 110 88c26 51 55 149 55 183c0 48 -25 74 -36 85c-9 8 -15 14 -15 27c0 22 25 48 50 48c17 0 44 -15 44 -70Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-30" d="M460 320c0 -79 -5 -157 -37 -226c-44 -95 -120 -116 -174 -116c-49 0 -122 20 -165 101c-41 76 -45 166 -45 241c0 80 5 158 37 227c41 93 114 119 174 119c42 0 124 -16 170 -112c35 -74 40 -154 40 -234zM377 332c0 63 0 139 -10 195c-19 99 -85 117 -118 117 c-25 0 -100 -9 -119 -128c-8 -54 -8 -120 -8 -184c0 -59 0 -151 11 -211c18 -96 77 -121 116 -121c45 0 102 30 117 125c11 64 11 132 11 207Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2C" d="M203 1c0 -117 -80 -194 -91 -194c-5 0 -10 4 -10 11c0 3 0 5 11 16c33 33 68 93 68 167c0 14 -2 15 -2 15s-2 -1 -5 -3c-10 -9 -23 -13 -35 -13c-33 0 -53 26 -53 53c0 28 20 53 53 53c39 0 64 -39 64 -105Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2026" d="M193 53c0 -29 -24 -53 -53 -53s-53 24 -53 53s24 53 53 53s53 -24 53 -53zM472 53c0 -29 -24 -53 -53 -53s-53 24 -53 53s24 53 53 53s53 -24 53 -53zM751 53c0 -29 -24 -53 -53 -53s-53 24 -53 53s24 53 53 53s53 -24 53 -53Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D45B" d="M571 143c0 -8 -37 -154 -131 -154c-47 0 -82 35 -82 82c0 11 1 23 10 46c16 43 65 171 65 233c0 33 -9 70 -54 70c-95 0 -148 -91 -163 -122l-13 -50c-5 -23 -11 -45 -17 -67l-22 -90c-6 -25 -18 -72 -19 -74c-7 -20 -25 -28 -37 -28c-15 0 -29 9 -29 27c0 5 6 28 9 43 l58 231c13 52 16 63 16 84c0 33 -11 46 -31 46c-36 0 -56 -48 -73 -119c-6 -22 -7 -23 -17 -23c0 0 -12 0 -12 10c0 4 14 63 30 97c10 18 29 57 75 57s87 -31 92 -87c17 23 66 87 156 87c72 0 115 -40 115 -107c0 -57 -42 -167 -61 -220c-9 -22 -18 -46 -18 -71 c0 -23 7 -33 24 -33c49 0 82 56 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2212" d="M722 250c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-29" d="M288 208c0 -171 -105 -371 -215 -454c-2 -1 -4 -2 -6 -2c-5 0 -10 5 -10 10c0 3 2 6 4 8c104 78 173 278 173 438v84c0 160 -69 360 -173 438c-2 2 -4 5 -4 8c0 5 5 10 10 10c2 0 4 -1 6 -2c110 -83 215 -283 215 -454v-84Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-28" x="0" y="0"></use>
<g transform="translate(389,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D464" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-30" x="1013" y="-213"></use>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="1559" y="0"></use>
<g transform="translate(2005,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D464" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-31" x="1013" y="-213"></use>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="3175" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2026" x="3620" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="4624" y="0"></use>
<g transform="translate(5069,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D464" x="0" y="0"></use>
<g transform="translate(716,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D45B" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-2212" x="600" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-31" x="1379" y="0"></use>
</g>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-29" x="7215" y="0"></use>
</g>
</svg>.  The transverse
tangent rules we will use are

</p>
<p><table class="table table-hover table-light table-sm"><thead><tr>
<th>Valence</th><th> <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.626ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 1130.8 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">w Subscript normal c</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D464" d="M691 372c0 -48 -32 -182 -66 -260c-26 -60 -70 -123 -145 -123c-30 0 -99 6 -125 70c-40 -70 -87 -70 -104 -70c-75 0 -142 35 -142 126c0 38 12 84 56 202c7 17 18 45 18 70c0 32 -16 33 -25 33c-35 0 -74 -31 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10 c0 9 37 154 132 154c49 0 82 -37 82 -82c0 -20 -6 -34 -17 -64c-47 -123 -52 -162 -52 -194c0 -17 0 -91 80 -91c39 0 69 31 92 84c-1 5 -1 7 -1 18c0 18 2 36 9 66c7 26 54 217 57 224c7 20 25 28 37 28c15 0 29 -9 29 -27c0 -6 -10 -43 -15 -65l-42 -168 c-4 -14 -11 -45 -11 -73c0 -57 27 -87 74 -87c49 0 84 35 110 88c26 51 55 149 55 183c0 48 -25 74 -36 85c-9 8 -15 14 -15 27c0 22 25 48 50 48c17 0 44 -15 44 -70Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-63" d="M415 119c0 -10 -32 -130 -166 -130c-116 0 -215 99 -215 227c0 124 92 232 217 232c77 0 153 -39 153 -107c0 -30 -20 -47 -46 -47c-28 0 -46 20 -46 46c0 13 6 43 47 46c-35 36 -98 37 -107 37c-53 0 -135 -42 -135 -205c0 -161 88 -204 141 -204c37 0 102 12 131 105 c2 6 4 10 13 10c3 0 13 0 13 -10Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D464" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-63" x="1013" y="-213"></use>
</g>
</svg></th><th> <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.464ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 1060.8 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">w Subscript i</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D464" d="M691 372c0 -48 -32 -182 -66 -260c-26 -60 -70 -123 -145 -123c-30 0 -99 6 -125 70c-40 -70 -87 -70 -104 -70c-75 0 -142 35 -142 126c0 38 12 84 56 202c7 17 18 45 18 70c0 32 -16 33 -25 33c-35 0 -74 -31 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10 c0 9 37 154 132 154c49 0 82 -37 82 -82c0 -20 -6 -34 -17 -64c-47 -123 -52 -162 -52 -194c0 -17 0 -91 80 -91c39 0 69 31 92 84c-1 5 -1 7 -1 18c0 18 2 36 9 66c7 26 54 217 57 224c7 20 25 28 37 28c15 0 29 -9 29 -27c0 -6 -10 -43 -15 -65l-42 -168 c-4 -14 -11 -45 -11 -73c0 -57 27 -87 74 -87c49 0 84 35 110 88c26 51 55 149 55 183c0 48 -25 74 -36 85c-9 8 -15 14 -15 27c0 22 25 48 50 48c17 0 44 -15 44 -70Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D456" d="M284 625c0 -30 -30 -53 -53 -53c-24 0 -38 17 -38 36c0 27 27 53 54 53c23 0 37 -16 37 -36zM293 143c0 -9 -37 -154 -131 -154c-48 0 -82 35 -82 82c0 21 13 54 23 80c16 43 61 159 69 185c4 10 11 31 11 52c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124 c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 38 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -13 -53c-10 -27 -10 -29 -22 -58l-39 -105c-23 -61 -29 -75 -29 -100c0 -23 7 -33 24 -33c51 0 84 61 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D464" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D456" x="1013" y="-213"></use>
</g>
</svg></th></tr>
</thead>
<tbody>
<tr>
<td>2</td><td> <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.971ex" height="2.343ex" style="vertical-align: -0.505ex;" viewBox="0 -791.3 1279 1008.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">negative 2</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-2212" d="M722 250c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-32" d="M449 174l-28 -174h-371c0 24 0 26 11 37l192 214c55 62 105 141 105 221c0 82 -43 163 -134 163c-58 0 -112 -37 -135 -102c3 1 5 1 13 1c35 0 53 -26 53 -52c0 -41 -35 -53 -52 -53c-3 0 -53 0 -53 56c0 89 74 181 187 181c122 0 212 -80 212 -194 c0 -100 -60 -154 -216 -292l-106 -103h180c22 0 88 0 95 8c10 15 17 59 22 89h25Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-2212" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-32" x="778" y="0"></use>
</g>
</svg></td><td> <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.168ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 2225.2 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">left-parenthesis 1 comma 1 right-parenthesis</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-28" d="M332 -238c0 -5 -5 -10 -10 -10c-2 0 -4 1 -6 2c-110 83 -215 283 -215 454v84c0 171 105 371 215 454c2 1 4 2 6 2c5 0 10 -5 10 -10c0 -3 -2 -6 -4 -8c-104 -78 -173 -278 -173 -438v-84c0 -160 69 -360 173 -438c2 -2 4 -5 4 -8Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2C" d="M203 1c0 -117 -80 -194 -91 -194c-5 0 -10 4 -10 11c0 3 0 5 11 16c33 33 68 93 68 167c0 14 -2 15 -2 15s-2 -1 -5 -3c-10 -9 -23 -13 -35 -13c-33 0 -53 26 -53 53c0 28 20 53 53 53c39 0 64 -39 64 -105Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-29" d="M288 208c0 -171 -105 -371 -215 -454c-2 -1 -4 -2 -6 -2c-5 0 -10 5 -10 10c0 3 2 6 4 8c104 78 173 278 173 438v84c0 160 -69 360 -173 438c-2 2 -4 5 -4 8c0 5 5 10 10 10c2 0 4 -1 6 -2c110 -83 215 -283 215 -454v-84Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-28" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-31" x="389" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="890" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-31" x="1335" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-29" x="1835" y="0"></use>
</g>
</svg></td></tr>
<tr>
<td>3</td><td> <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.971ex" height="2.343ex" style="vertical-align: -0.505ex;" viewBox="0 -791.3 1279 1008.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">negative 1</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-2212" d="M722 250c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-2212" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-31" x="778" y="0"></use>
</g>
</svg></td><td> <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="7.365ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 3170.8 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">left-parenthesis 0 comma 1 comma 0 right-parenthesis</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-28" d="M332 -238c0 -5 -5 -10 -10 -10c-2 0 -4 1 -6 2c-110 83 -215 283 -215 454v84c0 171 105 371 215 454c2 1 4 2 6 2c5 0 10 -5 10 -10c0 -3 -2 -6 -4 -8c-104 -78 -173 -278 -173 -438v-84c0 -160 69 -360 173 -438c2 -2 4 -5 4 -8Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-30" d="M460 320c0 -79 -5 -157 -37 -226c-44 -95 -120 -116 -174 -116c-49 0 -122 20 -165 101c-41 76 -45 166 -45 241c0 80 5 158 37 227c41 93 114 119 174 119c42 0 124 -16 170 -112c35 -74 40 -154 40 -234zM377 332c0 63 0 139 -10 195c-19 99 -85 117 -118 117 c-25 0 -100 -9 -119 -128c-8 -54 -8 -120 -8 -184c0 -59 0 -151 11 -211c18 -96 77 -121 116 -121c45 0 102 30 117 125c11 64 11 132 11 207Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2C" d="M203 1c0 -117 -80 -194 -91 -194c-5 0 -10 4 -10 11c0 3 0 5 11 16c33 33 68 93 68 167c0 14 -2 15 -2 15s-2 -1 -5 -3c-10 -9 -23 -13 -35 -13c-33 0 -53 26 -53 53c0 28 20 53 53 53c39 0 64 -39 64 -105Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-29" d="M288 208c0 -171 -105 -371 -215 -454c-2 -1 -4 -2 -6 -2c-5 0 -10 5 -10 10c0 3 2 6 4 8c104 78 173 278 173 438v84c0 160 -69 360 -173 438c-2 2 -4 5 -4 8c0 5 5 10 10 10c2 0 4 -1 6 -2c110 -83 215 -283 215 -454v-84Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-28" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-30" x="389" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="890" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-31" x="1335" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="1835" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-30" x="2280" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-29" x="2781" y="0"></use>
</g>
</svg></td></tr>
<tr>
<td>4 (regular)</td><td> <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.971ex" height="2.343ex" style="vertical-align: -0.505ex;" viewBox="0 -791.3 1279 1008.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">negative 2</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-2212" d="M722 250c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-32" d="M449 174l-28 -174h-371c0 24 0 26 11 37l192 214c55 62 105 141 105 221c0 82 -43 163 -134 163c-58 0 -112 -37 -135 -102c3 1 5 1 13 1c35 0 53 -26 53 -52c0 -41 -35 -53 -52 -53c-3 0 -53 0 -53 56c0 89 74 181 187 181c122 0 212 -80 212 -194 c0 -100 -60 -154 -216 -292l-106 -103h180c22 0 88 0 95 8c10 15 17 59 22 89h25Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-2212" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-32" x="778" y="0"></use>
</g>
</svg></td><td> <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="13.177ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 5673.5 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">left-parenthesis negative 1 comma 2 comma 2 comma negative 1 right-parenthesis</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-28" d="M332 -238c0 -5 -5 -10 -10 -10c-2 0 -4 1 -6 2c-110 83 -215 283 -215 454v84c0 171 105 371 215 454c2 1 4 2 6 2c5 0 10 -5 10 -10c0 -3 -2 -6 -4 -8c-104 -78 -173 -278 -173 -438v-84c0 -160 69 -360 173 -438c2 -2 4 -5 4 -8Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2212" d="M722 250c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2C" d="M203 1c0 -117 -80 -194 -91 -194c-5 0 -10 4 -10 11c0 3 0 5 11 16c33 33 68 93 68 167c0 14 -2 15 -2 15s-2 -1 -5 -3c-10 -9 -23 -13 -35 -13c-33 0 -53 26 -53 53c0 28 20 53 53 53c39 0 64 -39 64 -105Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-32" d="M449 174l-28 -174h-371c0 24 0 26 11 37l192 214c55 62 105 141 105 221c0 82 -43 163 -134 163c-58 0 -112 -37 -135 -102c3 1 5 1 13 1c35 0 53 -26 53 -52c0 -41 -35 -53 -52 -53c-3 0 -53 0 -53 56c0 89 74 181 187 181c122 0 212 -80 212 -194 c0 -100 -60 -154 -216 -292l-106 -103h180c22 0 88 0 95 8c10 15 17 59 22 89h25Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-29" d="M288 208c0 -171 -105 -371 -215 -454c-2 -1 -4 -2 -6 -2c-5 0 -10 5 -10 10c0 3 2 6 4 8c104 78 173 278 173 438v84c0 160 -69 360 -173 438c-2 2 -4 5 -4 8c0 5 5 10 10 10c2 0 4 -1 6 -2c110 -83 215 -283 215 -454v-84Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-28" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2212" x="389" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-31" x="1168" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="1668" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-32" x="2113" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="2614" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-32" x="3059" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="3559" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2212" x="4004" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-31" x="4783" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-29" x="5284" y="0"></use>
</g>
</svg></td></tr>
</tbody></table>


</p>
<p>For valences of 5 and higher, <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="6.887ex" height="2.509ex" style="vertical-align: -0.671ex;" viewBox="0 -791.3 2965.4 1080.4" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">w Subscript normal c Baseline equals 0</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D464" d="M691 372c0 -48 -32 -182 -66 -260c-26 -60 -70 -123 -145 -123c-30 0 -99 6 -125 70c-40 -70 -87 -70 -104 -70c-75 0 -142 35 -142 126c0 38 12 84 56 202c7 17 18 45 18 70c0 32 -16 33 -25 33c-35 0 -74 -31 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10 c0 9 37 154 132 154c49 0 82 -37 82 -82c0 -20 -6 -34 -17 -64c-47 -123 -52 -162 -52 -194c0 -17 0 -91 80 -91c39 0 69 31 92 84c-1 5 -1 7 -1 18c0 18 2 36 9 66c7 26 54 217 57 224c7 20 25 28 37 28c15 0 29 -9 29 -27c0 -6 -10 -43 -15 -65l-42 -168 c-4 -14 -11 -45 -11 -73c0 -57 27 -87 74 -87c49 0 84 35 110 88c26 51 55 149 55 183c0 48 -25 74 -36 85c-9 8 -15 14 -15 27c0 22 25 48 50 48c17 0 44 -15 44 -70Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-63" d="M415 119c0 -10 -32 -130 -166 -130c-116 0 -215 99 -215 227c0 124 92 232 217 232c77 0 153 -39 153 -107c0 -30 -20 -47 -46 -47c-28 0 -46 20 -46 46c0 13 6 43 47 46c-35 36 -98 37 -107 37c-53 0 -135 -42 -135 -205c0 -161 88 -204 141 -204c37 0 102 12 131 105 c2 6 4 10 13 10c3 0 13 0 13 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-3D" d="M722 347c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20zM722 153c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-30" d="M460 320c0 -79 -5 -157 -37 -226c-44 -95 -120 -116 -174 -116c-49 0 -122 20 -165 101c-41 76 -45 166 -45 241c0 80 5 158 37 227c41 93 114 119 174 119c42 0 124 -16 170 -112c35 -74 40 -154 40 -234zM377 332c0 63 0 139 -10 195c-19 99 -85 117 -118 117 c-25 0 -100 -9 -119 -128c-8 -54 -8 -120 -8 -184c0 -59 0 -151 11 -211c18 -96 77 -121 116 -121c45 0 102 30 117 125c11 64 11 132 11 207Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D464" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-63" x="1013" y="-213"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-3D" x="1408" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-30" x="2464" y="0"></use>
</g>
</svg> and
</p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">

</div>
<div class="col-md-10 col-lg-8">
<div class="displaymath"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="26.498ex" height="6.509ex" style="vertical-align: -2.671ex;" viewBox="0 -1652.5 11408.6 2802.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">StartLayout 1st Row 1st Column w 0 2nd Column equals w Subscript n minus 1 Baseline equals sine theta 2nd Row 1st Column w Subscript i 2nd Column equals left-parenthesis 2 cosine theta minus 2 right-parenthesis sine left-parenthesis theta i right-parenthesis comma EndLayout</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D464" d="M691 372c0 -48 -32 -182 -66 -260c-26 -60 -70 -123 -145 -123c-30 0 -99 6 -125 70c-40 -70 -87 -70 -104 -70c-75 0 -142 35 -142 126c0 38 12 84 56 202c7 17 18 45 18 70c0 32 -16 33 -25 33c-35 0 -74 -31 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10 c0 9 37 154 132 154c49 0 82 -37 82 -82c0 -20 -6 -34 -17 -64c-47 -123 -52 -162 -52 -194c0 -17 0 -91 80 -91c39 0 69 31 92 84c-1 5 -1 7 -1 18c0 18 2 36 9 66c7 26 54 217 57 224c7 20 25 28 37 28c15 0 29 -9 29 -27c0 -6 -10 -43 -15 -65l-42 -168 c-4 -14 -11 -45 -11 -73c0 -57 27 -87 74 -87c49 0 84 35 110 88c26 51 55 149 55 183c0 48 -25 74 -36 85c-9 8 -15 14 -15 27c0 22 25 48 50 48c17 0 44 -15 44 -70Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-30" d="M460 320c0 -79 -5 -157 -37 -226c-44 -95 -120 -116 -174 -116c-49 0 -122 20 -165 101c-41 76 -45 166 -45 241c0 80 5 158 37 227c41 93 114 119 174 119c42 0 124 -16 170 -112c35 -74 40 -154 40 -234zM377 332c0 63 0 139 -10 195c-19 99 -85 117 -118 117 c-25 0 -100 -9 -119 -128c-8 -54 -8 -120 -8 -184c0 -59 0 -151 11 -211c18 -96 77 -121 116 -121c45 0 102 30 117 125c11 64 11 132 11 207Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-3D" d="M722 347c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20zM722 153c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D45B" d="M571 143c0 -8 -37 -154 -131 -154c-47 0 -82 35 -82 82c0 11 1 23 10 46c16 43 65 171 65 233c0 33 -9 70 -54 70c-95 0 -148 -91 -163 -122l-13 -50c-5 -23 -11 -45 -17 -67l-22 -90c-6 -25 -18 -72 -19 -74c-7 -20 -25 -28 -37 -28c-15 0 -29 9 -29 27c0 5 6 28 9 43 l58 231c13 52 16 63 16 84c0 33 -11 46 -31 46c-36 0 -56 -48 -73 -119c-6 -22 -7 -23 -17 -23c0 0 -12 0 -12 10c0 4 14 63 30 97c10 18 29 57 75 57s87 -31 92 -87c17 23 66 87 156 87c72 0 115 -40 115 -107c0 -57 -42 -167 -61 -220c-9 -22 -18 -46 -18 -71 c0 -23 7 -33 24 -33c49 0 82 56 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2212" d="M722 250c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-73" d="M360 128c0 -72 -46 -139 -161 -139c-21 0 -66 1 -110 43c-18 -19 -18 -21 -20 -23c-19 -19 -20 -20 -25 -20c-11 0 -11 7 -11 24v132c0 18 0 25 13 25c10 0 11 -4 14 -17c19 -85 55 -142 139 -142c78 0 113 40 113 91c0 72 -82 88 -104 92c-72 14 -100 20 -132 46 c-27 22 -43 50 -43 85c0 56 38 123 160 123c15 0 56 0 94 -28c4 3 14 12 17 16c13 12 15 12 20 12c11 0 11 -7 11 -24v-101c0 -19 0 -24 -13 -24c0 0 -11 0 -12 9c-2 31 -7 121 -117 121c-86 0 -112 -41 -112 -76c0 -58 67 -71 123 -82c42 -8 81 -16 114 -48 c12 -12 42 -42 42 -95Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-69" d="M247 0c-34 1 -69 3 -104 3l-110 -3v31c67 0 78 0 78 45v269c0 49 -9 55 -74 55v31l140 11v-367c0 -39 4 -44 70 -44v-31zM192 604c0 -25 -20 -53 -54 -53c-30 0 -53 26 -53 53c0 25 20 53 54 53c30 0 53 -26 53 -53Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-6E" d="M535 0l-112 3l-113 -3v31c67 0 78 0 78 45v233c0 57 -11 111 -74 111c-64 0 -135 -56 -135 -160v-184c0 -45 11 -45 78 -45v-31l-112 3l-113 -3v31c67 0 78 0 78 45v268c0 49 -8 56 -78 56v31l141 11v-105c28 62 75 105 148 105c58 0 91 -20 105 -37 c31 -36 31 -67 31 -153v-191c1 -30 26 -30 78 -30v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D703" d="M455 500c0 -224 -152 -511 -293 -511c-91 0 -120 111 -120 205c0 229 154 511 293 511c102 0 120 -139 120 -205zM389 562c0 57 -6 121 -55 121c-45 0 -82 -56 -109 -105c-40 -71 -60 -151 -77 -215h209c24 99 32 150 32 199zM348 331h-208c-26 -98 -32 -156 -32 -198 c0 -93 21 -122 54 -122c43 0 81 49 116 117c38 72 59 157 70 203Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D456" d="M284 625c0 -30 -30 -53 -53 -53c-24 0 -38 17 -38 36c0 27 27 53 54 53c23 0 37 -16 37 -36zM293 143c0 -9 -37 -154 -131 -154c-48 0 -82 35 -82 82c0 21 13 54 23 80c16 43 61 159 69 185c4 10 11 31 11 52c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124 c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 38 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -13 -53c-10 -27 -10 -29 -22 -58l-39 -105c-23 -61 -29 -75 -29 -100c0 -23 7 -33 24 -33c51 0 84 61 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-28" d="M332 -238c0 -5 -5 -10 -10 -10c-2 0 -4 1 -6 2c-110 83 -215 283 -215 454v84c0 171 105 371 215 454c2 1 4 2 6 2c5 0 10 -5 10 -10c0 -3 -2 -6 -4 -8c-104 -78 -173 -278 -173 -438v-84c0 -160 69 -360 173 -438c2 -2 4 -5 4 -8Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-32" d="M449 174l-28 -174h-371c0 24 0 26 11 37l192 214c55 62 105 141 105 221c0 82 -43 163 -134 163c-58 0 -112 -37 -135 -102c3 1 5 1 13 1c35 0 53 -26 53 -52c0 -41 -35 -53 -52 -53c-3 0 -53 0 -53 56c0 89 74 181 187 181c122 0 212 -80 212 -194 c0 -100 -60 -154 -216 -292l-106 -103h180c22 0 88 0 95 8c10 15 17 59 22 89h25Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-63" d="M415 119c0 -10 -32 -130 -166 -130c-116 0 -215 99 -215 227c0 124 92 232 217 232c77 0 153 -39 153 -107c0 -30 -20 -47 -46 -47c-28 0 -46 20 -46 46c0 13 6 43 47 46c-35 36 -98 37 -107 37c-53 0 -135 -42 -135 -205c0 -161 88 -204 141 -204c37 0 102 12 131 105 c2 6 4 10 13 10c3 0 13 0 13 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-6F" d="M471 214c0 -127 -101 -225 -222 -225c-117 0 -221 96 -221 225c0 125 97 234 222 234c121 0 221 -106 221 -234zM388 222c0 38 0 96 -26 139s-69 65 -113 65c-40 0 -87 -21 -114 -67c-24 -44 -24 -98 -24 -137c0 -36 0 -97 25 -141c27 -46 71 -67 114 -67 c50 0 94 29 116 74c22 44 22 98 22 134Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-29" d="M288 208c0 -171 -105 -371 -215 -454c-2 -1 -4 -2 -6 -2c-5 0 -10 5 -10 10c0 3 2 6 4 8c104 78 173 278 173 438v84c0 160 -69 360 -173 438c-2 2 -4 5 -4 8c0 5 5 10 10 10c2 0 4 -1 6 -2c110 -83 215 -283 215 -454v-84Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2C" d="M203 1c0 -117 -80 -194 -91 -194c-5 0 -10 4 -10 11c0 3 0 5 11 16c33 33 68 93 68 167c0 14 -2 15 -2 15s-2 -1 -5 -3c-10 -9 -23 -13 -35 -13c-33 0 -53 26 -53 53c0 28 20 53 53 53c39 0 64 -39 64 -105Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
<g transform="translate(167,0)">
<g transform="translate(-11,0)">
<g transform="translate(0,729)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D464" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-30" x="1013" y="-213"></use>
</g>
<g transform="translate(109,-781)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D464" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D456" x="1013" y="-213"></use>
</g>
</g>
<g transform="translate(1437,0)">
<g transform="translate(0,729)">
 <use xlink:href="#E1-LATINMODERNMAIN-3D" x="0" y="0"></use>
<g transform="translate(1056,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D464" x="0" y="0"></use>
<g transform="translate(716,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D45B" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-2212" x="600" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-31" x="1379" y="0"></use>
</g>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-3D" x="3479" y="0"></use>
<g transform="translate(4535,0)">
 <use xlink:href="#E1-LATINMODERNMAIN-73"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-69" x="394" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-6E" x="673" y="0"></use>
</g>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D703" x="5932" y="0"></use>
</g>
<g transform="translate(0,-781)">
 <use xlink:href="#E1-LATINMODERNMAIN-3D" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-28" x="1056" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-32" x="1445" y="0"></use>
<g transform="translate(2112,0)">
 <use xlink:href="#E1-LATINMODERNMAIN-63"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-6F" x="444" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-73" x="945" y="0"></use>
</g>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D703" x="3619" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2212" x="4310" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-32" x="5311" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-29" x="5812" y="0"></use>
<g transform="translate(6534,0)">
 <use xlink:href="#E1-LATINMODERNMAIN-73"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-69" x="394" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-6E" x="673" y="0"></use>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-28" x="7764" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D703" x="8153" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D456" x="8623" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-29" x="8968" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="9358" y="0"></use>
</g>
</g>
</g>
</g>
</svg>
</div>
<p>

where
</p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">

</div>
<div class="col-md-10 col-lg-8">
<div class="displaymath"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="11.069ex" height="4.843ex" style="vertical-align: -2.005ex;" viewBox="0 -1221.9 4766 2085" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">theta equals StartFraction pi Over n minus 1 EndFraction period</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D703" d="M455 500c0 -224 -152 -511 -293 -511c-91 0 -120 111 -120 205c0 229 154 511 293 511c102 0 120 -139 120 -205zM389 562c0 57 -6 121 -55 121c-45 0 -82 -56 -109 -105c-40 -71 -60 -151 -77 -215h209c24 99 32 150 32 199zM348 331h-208c-26 -98 -32 -156 -32 -198 c0 -93 21 -122 54 -122c43 0 81 49 116 117c38 72 59 157 70 203Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-3D" d="M722 347c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20zM722 153c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D70B" d="M567 407c0 -34 -36 -34 -49 -34h-114c-11 -52 -18 -106 -18 -159c0 -28 0 -93 29 -165c6 -14 6 -16 6 -22c0 -20 -21 -38 -41 -38c-15 0 -26 6 -36 50c-8 34 -8 61 -8 76c0 67 9 110 42 258h-113l-56 -221c-13 -50 -13 -52 -27 -98c-12 -37 -20 -65 -50 -65 c-13 0 -29 8 -29 27c0 7 0 9 8 24c42 91 96 212 128 333h-57c-20 0 -78 0 -127 -77c-6 -8 -8 -12 -16 -12c-12 0 -12 10 -12 10c0 5 26 51 61 90c44 47 82 47 104 47h335c19 0 40 0 40 -24Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D45B" d="M571 143c0 -8 -37 -154 -131 -154c-47 0 -82 35 -82 82c0 11 1 23 10 46c16 43 65 171 65 233c0 33 -9 70 -54 70c-95 0 -148 -91 -163 -122l-13 -50c-5 -23 -11 -45 -17 -67l-22 -90c-6 -25 -18 -72 -19 -74c-7 -20 -25 -28 -37 -28c-15 0 -29 9 -29 27c0 5 6 28 9 43 l58 231c13 52 16 63 16 84c0 33 -11 46 -31 46c-36 0 -56 -48 -73 -119c-6 -22 -7 -23 -17 -23c0 0 -12 0 -12 10c0 4 14 63 30 97c10 18 29 57 75 57s87 -31 92 -87c17 23 66 87 156 87c72 0 115 -40 115 -107c0 -57 -42 -167 -61 -220c-9 -22 -18 -46 -18 -71 c0 -23 7 -33 24 -33c49 0 82 56 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2212" d="M722 250c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2E" d="M192 53c0 -29 -24 -53 -53 -53s-53 24 -53 53s24 53 53 53s53 -24 53 -53Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D703" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-3D" x="747" y="0"></use>
<g transform="translate(1525,0)">
<g transform="translate(397,0)">
<rect stroke="none" width="2443" height="60" x="0" y="220"></rect>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D70B" x="936" y="676"></use>
<g transform="translate(60,-687)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D45B" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2212" x="822" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-31" x="1823" y="0"></use>
</g>
</g>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-2E" x="4487" y="0"></use>
</g>
</svg>
</div>
<p>


</p>
<p>Although we will not prove it here, these weights sum to zero for all
values of <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="0.802ex" height="2.176ex" style="vertical-align: -0.338ex;" viewBox="0 -791.3 345.5 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">i</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D456" d="M284 625c0 -30 -30 -53 -53 -53c-24 0 -38 17 -38 36c0 27 27 53 54 53c23 0 37 -16 37 -36zM293 143c0 -9 -37 -154 -131 -154c-48 0 -82 35 -82 82c0 21 13 54 23 80c16 43 61 159 69 185c4 10 11 31 11 52c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124 c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 38 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -13 -53c-10 -27 -10 -29 -22 -58l-39 -105c-23 -61 -29 -75 -29 -100c0 -23 7 -33 24 -33c51 0 84 61 102 124c5 15 5 18 15 18c3 0 12 0 12 -10Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D456" x="0" y="0"></use>
</g>
</svg>.  This guarantees that the weighted sum is in fact a tangent
vector.

</p>
<p></p>
<span class="anchor" id="fragment-Computetangentsofboundaryface-0"></span><div class="fragmentname">&lt;&lt;Compute tangents of boundary face&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">S = pRing[valence - 1] - pRing[0];
if (valence == 2)
    T = <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a>(pRing[0] + pRing[1] - 2 * vertex-&gt;p);
else if (valence == 3)
    T = pRing[1] - vertex-&gt;p;
else if (valence == 4) // regular
    T = <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a>(-1 * pRing[0] +  2 * pRing[1] + 2 * pRing[2] + 
                 -1 * pRing[3] + -2 * vertex-&gt;p);
else {
    Float theta = <a href="../Utilities/Main_Include_File.html#Pi" class="code">Pi</a> / float(valence - 1);
    T = <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a>(std::sin(theta) * (pRing[0] + pRing[valence - 1]));
    for (int k = 1; k &lt; valence - 1; ++k) {
        Float wt = (2 * std::cos(theta) - 2) * std::sin((k) * theta);
        T += <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a>(wt * pRing[k]);
    }
    T = -T;
}</div><p>


</p>
<p>Finally, the fragment &lt;&lt;<span class="fragmentname">Create triangle mesh from subdivision
mesh</span>&gt;&gt; initializes a vector of <tt>Triangle</tt>s corresponding to the triangulation of
the limit surface.  We won&rsquo;t include it here, since
it&rsquo;s just a straightforward transformation of the subdivided mesh into an
indexed triangle mesh.

</p>
<p>
  


</p>
<p>
</p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

</div>  <!-- container-fluid -->
</div>  <!-- maincontainer -->

<nav class="navbar navbar-expand-md">
  <div class="container-fluid-nav">
    <!--  <ul class="nav navbar-nav navbar-center"> -->
      <span class="navbar-text" style="text-align: center;">
        Thanks to Farhan Wali and 34 others for generously supporting <i>Physically
        Based Rendering</i> online
        through <a href="https://patreon.com/pbrbook">Patreon</a>.
    </span>
  </div>
</nav>

<nav class="navbar navbar-expand-md">
  <span class="navbar-text"><i>Physically Based Rendering: From Theory To Implementation</i>, &copy; 2004-2021 Matt Pharr, Wenzel Jakob, and Greg Humphreys under the <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">CC BY-NC-ND 4.0</a> license. (<a href="https://github.com/mmp/pbr-book-website/">github</a>)</span>
  <div class="container">
    <ul class="nav navbar-nav ml-auto">
      <li class="nav-item">Next: <a href="../Shapes/Managing_Rounding_Error.html">Shapes / Managing Rounding Error</a></li>
    </ul>
  </div>

</nav>

<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script>
  $(function () {
    $('[data-toggle="popover"]').popover()
    $('[data-toggle="tooltip"]').tooltip()
   })
</script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>

<script>
// https://stackoverflow.com/a/17535094
// The function actually applying the offset
function offsetAnchor() {
  if (location.hash.length !== 0) {
    window.scrollTo(window.scrollX, window.scrollY - window.innerHeight / 8);
  }
}

// Captures click events of all <a> elements with href starting with #
$(document).on('click', 'a[href^="#"]', function(event) {
  // Click events are captured before hashchanges. Timeout
  // causes offsetAnchor to be called after the page jump.
  window.setTimeout(function() {
    offsetAnchor();
  }, 500);
});

// Set the offset when entering page with hash present in the url
window.setTimeout(offsetAnchor, 1500);
</script>

</body>
</html>
