
<!doctype html>
<html lang="en">
<head>

<!-- all praise to https://realfavicongenerator.net -->
<link rel="icon" href="/favicon.ico?v=2" /> <!-- force refresh -->
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">

  <!-- Required meta tags -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="/fonts.css">
  <link rel="stylesheet" href="../pbrstyle.css">
  <link rel="stylesheet" href="/fontawesome-free-5.15.3-web/css/all.css">

  <script async src="https://cse.google.com/cse.js?cx=003601324460585362024:4xwpwgaitgd"></script>
  <script src="/react.min.js"></script>
  <script src="/react-dom.min.js"></script>
  <script src="/jeri.min.js"></script>
  <link rel="preload" href="/exr.worker.js" as="script" crossorigin="anonymous">
        
  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/bootstrap.min.css">

  <title>Path Tracer Implementation</title>
</head>
        
<body>

<nav class="fixed-top-lg-navbar navbar navbar-expand bg-light navbar-light">
  <ul class="nav navbar-nav">
    <a class="navbar-brand" href="../contents.html"><img src="../pbr.jpg" width=25 height=25></a>
    <li class="nav-item"><a class="nav-link" href="../Wavefront_Rendering_on_GPUs.html">Wavefront Rendering on GPUs</a></li>
    <span class="navbar-text">/</span>
    <li class="nav-item"><a class="nav-link" href="#">Path Tracer Implementation</a></li>
    <span class="navbar-text">&nbsp;&nbsp;</span>
    <li class="nav-item"><a class="nav-link" href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html">(Previous: Implementation Foundations)</a></li>
  </ul>

  <ul class="nav navbar-nav ml-auto d-none d-md-block">
        <li class="nav-item"><div class="gcse-search"></div></li>
    </ul>
  <ul class="nav navbar-nav d-block d-md-none">
        <li class="nav-item"><div class="gcse-search"></div></li>
    </ul>
</nav>

<div class="maincontainer">
<div class="container-fluid">

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">

</div>
<div class="col-md-10 col-lg-8">

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#"><i class="fas fa-link "></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span class="anchor" id="sec:pbrt-gpu-path-tracer"></span><h2>15.3 Path Tracer Implementation</h2><p>



</p>
<p>With these utility classes in hand, we can turn to the
<tt>WavefrontPathIntegrator</tt> class implementation.  As mentioned earlier,
its functionality matches that of the <a href="../Light_Transport_II_Volume_Rendering/Volume_Scattering_Integrators.html#VolPathIntegrator"><tt>VolPathIntegrator</tt></a>, restructured
to run with a wavefront architecture.

</p>
<p>The <tt>WavefrontPathIntegrator</tt> class declaration is in the file
<a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/wavefront/integrator.h"><tt>wavefront/integrator.h</tt></a> and some of its implementation is in
<a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/wavefront/integrator.cpp"><tt>wavefront/integrator.cpp</tt></a>, though a number of its method
implementations are distributed across separate source files in the
<a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/wavefront/"><tt>wavefront/</tt></a> directory.  While this is a different organization
than we have used elsewhere in <tt>pbrt</tt> (where all the non-inline method
definitions for a class defined in a file named <tt>file.h</tt> are in
<tt>file.cpp</tt>), distributing them in this way reduces the time necessary
to compile <tt>pbrt</tt>, since many of the methods make use of C++ features that
can lead to long compile times.  Spreading them out across multiple files
allows multiple CPU cores to compile their implementations in parallel.

</p>
<p></p>
<span class="anchor" id="fragment-WavefrontPathIntegratorDefinition-0"></span><div class="fragmentname">&lt;&lt;WavefrontPathIntegrator Definition&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">class <span class="anchor" id="WavefrontPathIntegrator"></span>WavefrontPathIntegrator {
  public:
    &lt;&lt;<span class="fragmentname"><a href="#fragment-WavefrontPathIntegratorPublicMethods-0">WavefrontPathIntegrator Public Methods</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2422" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2422"><i></i></a><div id="fragbit-2422" class="collapse"><div class="fragmentcode">       Float Render();
       
       void GenerateCameraRays(int y0, int sampleIndex);
       template &lt;typename <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a>&gt;
       void GenerateCameraRays(int y0, int sampleIndex);
       
       void GenerateRaySamples(int wavefrontDepth, int sampleIndex);
       template &lt;typename <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a>&gt;
       void GenerateRaySamples(int wavefrontDepth, int sampleIndex);
       
       void TraceShadowRays(int wavefrontDepth);
       void SampleMediumInteraction(int wavefrontDepth);
       template &lt;typename <a href="../Volume_Scattering/Phase_Functions.html#PhaseFunction" class="code">PhaseFunction</a>&gt;
       void SampleMediumScattering(int wavefrontDepth);
       void SampleSubsurface(int wavefrontDepth);
       
       void HandleEscapedRays();
       void HandleEmissiveIntersection();
       
       void EvaluateMaterialsAndBSDFs(int wavefrontDepth);
       template &lt;typename ConcreteMaterial&gt;
       void EvaluateMaterialAndBSDF(int wavefrontDepth);
       template &lt;typename ConcreteMaterial, typename <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#TextureEvaluator" class="code">TextureEvaluator</a>&gt;
       void EvaluateMaterialAndBSDF(MaterialEvalQueue *evalQueue, int wavefrontDepth);
       
       void UpdateFilm();
       WavefrontPathIntegrator(pstd::pmr::memory_resource *memoryResource,
                               <a href="../Processing_the_Scene_Description/BasicScene_and_Final_Object_Creation.html#BasicScene" class="code">BasicScene</a> &amp;scene);
       template &lt;typename F&gt;
       void <a href="../Utilities/Parallelism.html#ParallelFor" class="code">ParallelFor</a>(const char *description, int nItems, F &amp;&amp;func) {
           if (<a href="../Utilities/System_Startup,_Cleanup,_and_Options.html#Options" class="code">Options</a>-&gt;<a href="../Utilities/System_Startup,_Cleanup,_and_Options.html#BasicPBRTOptions::useGPU" class="code">useGPU</a>)
               <a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#GPUParallelFor" class="code">GPUParallelFor</a>(description, nItems, func);
           else
               pbrt::<a href="../Utilities/Parallelism.html#ParallelFor" class="code">ParallelFor</a>(0, nItems, func);
       }
       template &lt;typename F&gt;
       void Do(const char *description, F &amp;&amp;func) {
           if (<a href="../Utilities/System_Startup,_Cleanup,_and_Options.html#Options" class="code">Options</a>-&gt;<a href="../Utilities/System_Startup,_Cleanup,_and_Options.html#BasicPBRTOptions::useGPU" class="code">useGPU</a>)
               <a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#GPUParallelFor" class="code">GPUParallelFor</a>(description, 1,
                              [=] PBRT_GPU (int) mutable { func(); });
           else
               func();
       }
       RayQueue *CurrentRayQueue(int wavefrontDepth) {
           return <a href="#WavefrontPathIntegrator::rayQueues" class="code">rayQueues</a>[wavefrontDepth &amp; 1];
       }
       RayQueue *NextRayQueue(int wavefrontDepth) {
           return <a href="#WavefrontPathIntegrator::rayQueues" class="code">rayQueues</a>[(wavefrontDepth + 1) &amp; 1];
       }</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-WavefrontPathIntegratorMemberVariables-0">WavefrontPathIntegrator Member Variables</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2423" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2423"><i></i></a><div id="fragbit-2423" class="collapse"><div class="fragmentcode">       bool initializeVisibleSurface;
       bool haveSubsurface;
       bool haveMedia;
       pstd::array&lt;bool, <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#Material" class="code">Material</a>::NumTags()&gt; haveBasicEvalMaterial;
       pstd::array&lt;bool, <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#Material" class="code">Material</a>::NumTags()&gt; haveUniversalEvalMaterial;
       
       struct Stats {
           Stats(int maxDepth, Allocator alloc);
       
           std::string Print() const;
       
           // Note: not atomics: tid 0 always updates them for everyone...
           uint64_t cameraRays = 0;
           pstd::vector&lt;uint64_t&gt; indirectRays, shadowRays;
       };
       Stats *stats;
       pstd::pmr::memory_resource *memoryResource;
       <a href="../Sampling_and_Reconstruction/Image_Reconstruction.html#Filter" class="code">Filter</a> filter;
       <a href="../Cameras_and_Film/Film_and_Imaging.html#Film" class="code">Film</a> film;
       <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a> sampler;
       <a href="../Cameras_and_Film/Camera_Interface.html#Camera" class="code">Camera</a> camera;
       pstd::vector&lt;<a href="../Light_Sources/Light_Interface.html#Light" class="code">Light</a>&gt; *infiniteLights;
       <a href="../Light_Sources/Light_Sampling.html#LightSampler" class="code">LightSampler</a> lightSampler;
       int maxDepth, samplesPerPixel;
       bool regularize;
       int scanlinesPerPass, maxQueueSize;
       SOA&lt;PixelSampleState&gt; pixelSampleState;
       RayQueue *rayQueues[2];
       WavefrontAggregate *aggregate = nullptr;
       MediumSampleQueue *mediumSampleQueue = nullptr;
       MediumScatterQueue *mediumScatterQueue = nullptr;
       EscapedRayQueue *escapedRayQueue = nullptr;
       HitAreaLightQueue *hitAreaLightQueue = nullptr;
       MaterialEvalQueue *basicEvalMaterialQueue = nullptr;
       MaterialEvalQueue *universalEvalMaterialQueue = nullptr;
       ShadowRayQueue *shadowRayQueue = nullptr;
       GetBSSRDFAndProbeRayQueue *bssrdfEvalQueue = nullptr;
       SubsurfaceScatterQueue *subsurfaceScatterQueue = nullptr;</div></div>
};</div><p>


</p>
<p>

</p>
<p>

</p>
<p>The constructor converts the provided <a href="../Processing_the_Scene_Description/BasicScene_and_Final_Object_Creation.html#BasicScene"><tt>BasicScene</tt></a> into the objects
that represent the scene for rendering.  We will skip over the majority of
its implementation here, however, as most of it just calls all the
appropriate object <tt>Create()</tt> methods to allocate and initialize the
corresponding objects (see Section&nbsp;<a href="../Processing_the_Scene_Description/BasicScene_and_Final_Object_Creation.html#sec:basic-scene">A.3</a>).  All
allocations are performed with <a href="../Introduction/Using_and_Understanding_the_Code.html#Allocator"><tt>Allocator</tt></a>s that use the provided
memory resource.  When rendering on the GPU, this leads to the use of
managed memory.
 
</p>
<span class="anchor" id="fragment-WavefrontPathIntegratorPublicMethods-0"></span><div class="fragmentname">&lt;&lt;WavefrontPathIntegrator Public Methods&gt;&gt;=&nbsp;<a href="#fragment-WavefrontPathIntegratorPublicMethods-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">WavefrontPathIntegrator(pstd::pmr::memory_resource *memoryResource,
                        <a href="../Processing_the_Scene_Description/BasicScene_and_Final_Object_Creation.html#BasicScene" class="code">BasicScene</a> &amp;scene);</div><p>


</p>
<p></p>
<span class="anchor" id="fragment-WavefrontPathIntegratorMemberVariables-0"></span><div class="fragmentname">&lt;&lt;WavefrontPathIntegrator Member Variables&gt;&gt;=&nbsp;<a href="#fragment-WavefrontPathIntegratorMemberVariables-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">pstd::pmr::memory_resource *<span class="anchor" id="WavefrontPathIntegrator::memoryResource"></span>memoryResource;</div><p>


</p>
<p>These are some of the key scene objects that are initialized in the
constructor.  As with the CPU-based <a href="../Introduction/pbrt_System_Overview.html#Integrator"><tt>Integrator</tt></a>s, the infinite lights
are stored independently so that they can be efficiently iterated over for
rays that escape the scene.

</p>
<p></p>
<span class="anchor" id="fragment-WavefrontPathIntegratorMemberVariables-1"></span><div class="fragmentname">&lt;&lt;WavefrontPathIntegrator Member Variables&gt;&gt;+=&nbsp;<a href="#fragment-WavefrontPathIntegratorMemberVariables-0"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-WavefrontPathIntegratorMemberVariables-2"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode"><a href="../Sampling_and_Reconstruction/Image_Reconstruction.html#Filter" class="code">Filter</a> <span class="anchor" id="WavefrontPathIntegrator::filter"></span>filter;
<a href="../Cameras_and_Film/Film_and_Imaging.html#Film" class="code">Film</a> <span class="anchor" id="WavefrontPathIntegrator::film"></span>film;
<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a> <span class="anchor" id="WavefrontPathIntegrator::sampler"></span>sampler;
<a href="../Cameras_and_Film/Camera_Interface.html#Camera" class="code">Camera</a> <span class="anchor" id="WavefrontPathIntegrator::camera"></span>camera;
pstd::vector&lt;<a href="../Light_Sources/Light_Interface.html#Light" class="code">Light</a>&gt; *<span class="anchor" id="WavefrontPathIntegrator::infiniteLights"></span>infiniteLights;
<a href="../Light_Sources/Light_Sampling.html#LightSampler" class="code">LightSampler</a> <span class="anchor" id="WavefrontPathIntegrator::lightSampler"></span>lightSampler;</div><p>


</p>
<p>There are a few additional member variables to store what should now be
familiar configuration options.

</p>
<p></p>
<span class="anchor" id="fragment-WavefrontPathIntegratorMemberVariables-2"></span><div class="fragmentname">&lt;&lt;WavefrontPathIntegrator Member Variables&gt;&gt;+=&nbsp;<a href="#fragment-WavefrontPathIntegratorMemberVariables-1"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-WavefrontPathIntegratorMemberVariables-3"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">int <span class="anchor" id="WavefrontPathIntegrator::maxDepth"></span>maxDepth, <span class="anchor" id="WavefrontPathIntegrator::samplesPerPixel"></span>samplesPerPixel;
bool <span class="anchor" id="WavefrontPathIntegrator::regularize"></span>regularize;</div><p>


</p>
<p>In order to limit memory use, this integrator places a limit on the number
of pixel samples that it works on at once.  All told, each active pixel
sample requires roughly 1,000 bytes of additional storage for its
state variables and to ensure that all the queues have sufficient space
for the work to be done for the ray.  (The actual amount of storage varies
based on the scene, as the constructor is careful not to allocate work
queues for the volume scattering kernels if there is no participating media
in the scene, for example.)

</p>
<p>The following fragment from the <a href="#WavefrontPathIntegrator"><tt>WavefrontPathIntegrator</tt></a> constructor
therefore sets a maximum number of active samples and then determines how
many scanlines of pixels that corresponds to.  That value in turn
determines how many passes (of rendering that many scanlines) are necessary
to cover the full image resolution.  Finally, <tt>scanlinesPerPass</tt> is
set with a new value that evens out the number of scanlines rendered in
each pass. This can help with load balancing by avoiding having a
small number of scanlines in the final pass. 

</p>
<p></p>
<span class="anchor" id="fragment-Computenumberofscanlinestorenderperpass-0"></span><div class="fragmentname">&lt;&lt;Compute number of scanlines to render per pass&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Geometry_and_Transformations/Vectors.html#Vector2i" class="code">Vector2i</a> resolution = film.<a href="../Cameras_and_Film/Film_and_Imaging.html#Film::PixelBounds" class="code">PixelBounds</a>().<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds2::Diagonal" class="code">Diagonal</a>();
int maxSamples = 1024 * 1024;
scanlinesPerPass = std::max(1, maxSamples / resolution.x);
int nPasses = (resolution.y + scanlinesPerPass - 1) / scanlinesPerPass;
scanlinesPerPass = (resolution.y + nPasses - 1) / nPasses;
maxQueueSize = resolution.x * scanlinesPerPass;
</div><p>


</p>
<p>All the queues that are allocated to buffer work between kernels are also
allocated to be able to store <tt>maxQueueSize</tt> individual work items.
Thus, all queues are able to store one work item for each of the active
pixel samples.  This is a sufficient number, as none of the kernels in the
current implementation ever push more than one item on a queue for each
item processed.  However, it may waste a substantial amount of memory.  For
example, there is a work queue for rays that hit emissive surfaces in the
scene.  It is rare that all the rays will hit emissive objects, yet
there must be storage for all in case of that eventuality.  The alternative,
dynamically increasing the size of the queues when necessary, would be
difficult to implement efficiently in the context of the massive
parallelism on GPUs.

</p>
<p></p>
<span class="anchor" id="fragment-WavefrontPathIntegratorMemberVariables-3"></span><div class="fragmentname">&lt;&lt;WavefrontPathIntegrator Member Variables&gt;&gt;+=&nbsp;<a href="#fragment-WavefrontPathIntegratorMemberVariables-2"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-WavefrontPathIntegratorMemberVariables-4"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">int <span class="anchor" id="WavefrontPathIntegrator::scanlinesPerPass"></span>scanlinesPerPass, <span class="anchor" id="WavefrontPathIntegrator::maxQueueSize"></span>maxQueueSize;</div><p>


</p>
<p>The <a href="#WavefrontPathIntegrator"><tt>WavefrontPathIntegrator</tt></a> does not use only queues to provide values to
kernels and to communicate results.  While the queue model is elegant, it
can be inefficient if some values are computed early and
not used until much later.  For example, consider the <a href="../Cameras_and_Film/Film_and_Imaging.html#VisibleSurface"><tt>VisibleSurface</tt></a>
structure that is provided to <a href="../Cameras_and_Film/Film_and_Imaging.html#Film"><tt>Film</tt></a> implementations like the
<a href="../Cameras_and_Film/Film_and_Imaging.html#GBufferFilm"><tt>GBufferFilm</tt></a>: it is initialized at the first intersection after the
camera, but then its value is not used again until the full ray path has
been traced and the <a href="../Cameras_and_Film/Film_and_Imaging.html#Film::AddSample"><tt>Film::AddSample()</tt></a> method is called at the end.
<tt>VisibleSurface</tt> is, further, a relatively large structure.  In a purely
queue-based model, a substantial amount of memory bandwidth would be
consumed passing it along from kernel to kernel until the end.

</p>
<p>Therefore, the <a href="#PixelSampleState"><tt>PixelSampleState</tt></a> structure is used for storing all such
values. Various member variables will be added to it in what follows.

</p>
<p></p>
<span class="anchor" id="fragment-PixelSampleStateDefinition-0"></span><div class="fragmentname">&lt;&lt;PixelSampleState Definition&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">struct <span class="anchor" id="PixelSampleState"></span>PixelSampleState {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-PixelSampleStatePublicMembers-0">PixelSampleState Public Members</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2424" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2424"><i></i></a><div id="fragbit-2424" class="collapse"><div class="fragmentcode">       <a href="../Geometry_and_Transformations/Points.html#Point2i" class="code">Point2i</a> pPixel;
       <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> L;
       <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> lambda;
       Float filterWeight;
       <a href="../Cameras_and_Film/Film_and_Imaging.html#VisibleSurface" class="code">VisibleSurface</a> visibleSurface;
       <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> cameraRayWeight;
       RaySamples samples;</div></div>
};</div><p>


</p>
<p>The <a href="#WavefrontPathIntegrator"><tt>WavefrontPathIntegrator</tt></a> maintains an SOA-arranged array of
<tt>PixelSampleState</tt>s, allocated to have <tt>maxQueueSize</tt> entries.
Each sample&rsquo;s index into this array is carried through the rendering
computation so that it is easy to determine which entry corresponds to a
pixel sample being processed.

</p>
<p></p>
<span class="anchor" id="fragment-WavefrontPathIntegratorMemberVariables-4"></span><div class="fragmentname">&lt;&lt;WavefrontPathIntegrator Member Variables&gt;&gt;+=&nbsp;<a href="#fragment-WavefrontPathIntegratorMemberVariables-3"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-WavefrontPathIntegratorMemberVariables-5"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">SOA&lt;PixelSampleState&gt; <span class="anchor" id="WavefrontPathIntegrator::pixelSampleState"></span>pixelSampleState;</div><p>


</p>
<p>

</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#WorkLaunch"><i class="fas fa-link h3h4marginlink"></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span id="WorkLaunch"></span><h3>15.3.1  Work Launch</h3><p>


</p>
<p>Because the <tt>WavefrontPathIntegrator</tt> may be running either on the CPU
or on the GPU, it provides methods for launching work that use the
appropriate processor.  Each selects the appropriate type of processor
based on the renderer&rsquo;s configuration.

</p>
<p>The first, <tt>ParallelFor()</tt>, selects between the types of two parallel
<tt>for</tt> loops.

</p>
<p></p>
<span class="anchor" id="fragment-WavefrontPathIntegratorPublicMethods-1"></span><div class="fragmentname">&lt;&lt;WavefrontPathIntegrator Public Methods&gt;&gt;+=&nbsp;<a href="#fragment-WavefrontPathIntegratorPublicMethods-0"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-WavefrontPathIntegratorPublicMethods-2"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">template &lt;typename F&gt;
void <span class="anchor" id="WavefrontPathIntegrator::ParallelFor"></span><a href="../Utilities/Parallelism.html#ParallelFor" class="code">ParallelFor</a>(const char *description, int nItems, F &amp;&amp;func) {
    if (<a href="../Utilities/System_Startup,_Cleanup,_and_Options.html#Options" class="code">Options</a>-&gt;<a href="../Utilities/System_Startup,_Cleanup,_and_Options.html#BasicPBRTOptions::useGPU" class="code">useGPU</a>)
        <a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#GPUParallelFor" class="code">GPUParallelFor</a>(description, nItems, func);
    else
        pbrt::<a href="../Utilities/Parallelism.html#ParallelFor" class="code">ParallelFor</a>(0, nItems, func);
}</div><p>


</p>
<p>The <tt>Do()</tt> method executes the provided function in a single thread.
On the CPU, it is no different than a regular function call; on the GPU,
however, it executes the provided function
using <a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#GPUParallelFor"><tt>GPUParallelFor()</tt></a> with a single-item loop.  For reasons that
should be clear by now, this not a good way to do a meaningful amount of
work on the GPU, but this capability is necessary for resetting counters,
clearing queues, and the like.

</p>
<p></p>
<span class="anchor" id="fragment-WavefrontPathIntegratorPublicMethods-2"></span><div class="fragmentname">&lt;&lt;WavefrontPathIntegrator Public Methods&gt;&gt;+=&nbsp;<a href="#fragment-WavefrontPathIntegratorPublicMethods-1"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-WavefrontPathIntegratorPublicMethods-3"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">template &lt;typename F&gt;
void <span class="anchor" id="WavefrontPathIntegrator::Do"></span>Do(const char *description, F &amp;&amp;func) {
    if (<a href="../Utilities/System_Startup,_Cleanup,_and_Options.html#Options" class="code">Options</a>-&gt;<a href="../Utilities/System_Startup,_Cleanup,_and_Options.html#BasicPBRTOptions::useGPU" class="code">useGPU</a>)
        <a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#GPUParallelFor" class="code">GPUParallelFor</a>(description, 1,
                       [=] PBRT_GPU (int) mutable { func(); });
    else
        func();
}</div><p>


</p>
<p>

</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#TheRenderMethod"><i class="fas fa-link h3h4marginlink"></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span id="TheRenderMethod"></span><h3>15.3.2  The Render() Method</h3><p>


</p>
<p>Rendering is initiated by a call to <tt>Render()</tt>.  (Recall Figure&nbsp;<a href="../Wavefront_Rendering_on_GPUs/Mapping_Path_Tracing_to_the_GPU.html#fig:gpu-kernels-overview">15.2</a>
in Section&nbsp;<a href="../Wavefront_Rendering_on_GPUs/Mapping_Path_Tracing_to_the_GPU.html#sec:pbrt-gpu-system-overview">15.1.3</a>, which summarizes the
kernels that this method launches.)  Similar to earlier
integrators, it progressively takes more samples in all pixels until
the requested number of samples have been taken.  This method 
tracks how long rendering takes and returns the number of elapsed seconds;
we have not included here
the straightforward few lines of code that handle that.

</p>
<p>One subtlety is that the initialization of the <tt>pixelBounds</tt> variable
at the start is important for rendering performance.  It will be necessary to have
this value later on in the implementation of <tt>Render()</tt>&mdash;though
because the <a href="../Cameras_and_Film/Film_and_Imaging.html#Film"><tt>Film</tt></a> is stored in managed memory, calling the
<tt>PixelBounds()</tt> method after GPU
kernels have been launched could incur the overhead of copying data back to
the CPU.

</p>
<p></p>
<span class="anchor" id="fragment-WavefrontPathIntegratorMethodDefinitions-0"></span><div class="fragmentname">&lt;&lt;WavefrontPathIntegrator Method Definitions&gt;&gt;=&nbsp;<a href="#fragment-WavefrontPathIntegratorMethodDefinitions-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">Float <span class="anchor" id="WavefrontPathIntegrator::Render"></span>WavefrontPathIntegrator::Render() {
    <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds2i" class="code">Bounds2i</a> pixelBounds = <a href="#WavefrontPathIntegrator::film" class="code">film</a>.<a href="../Cameras_and_Film/Film_and_Imaging.html#Film::PixelBounds" class="code">PixelBounds</a>();
    <a href="../Geometry_and_Transformations/Vectors.html#Vector2i" class="code">Vector2i</a> resolution = pixelBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds2::Diagonal" class="code">Diagonal</a>();
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Loopoversampleindicesandevaluatepixelsamples-0">Loop over sample indices and evaluate pixel samples</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2425" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2425"><i></i></a><div id="fragbit-2425" class="collapse"><div class="fragmentcode">       int firstSampleIndex = 0, lastSampleIndex = <a href="#WavefrontPathIntegrator::samplesPerPixel" class="code">samplesPerPixel</a>;
       for (int sampleIndex = firstSampleIndex; sampleIndex &lt; lastSampleIndex;
            ++sampleIndex) {
           &lt;&lt;<span class="fragmentname"><a href="#fragment-RenderimageforsamplemonosampleIndex-0">Render image for sample <tt>sampleIndex</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2426" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2426"><i></i></a><div id="fragbit-2426" class="collapse"><div class="fragmentcode">              for (int y0 = pixelBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds2::pMin" class="code">pMin</a>.y; y0 &lt; pixelBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds2::pMax" class="code">pMax</a>.y;
                   y0 += <a href="#WavefrontPathIntegrator::scanlinesPerPass" class="code">scanlinesPerPass</a>) {
                  &lt;&lt;<span class="fragmentname"><a href="#fragment-Generatecameraraysforcurrentscanlinerange-0">Generate camera rays for current scanline range</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2427" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2427"><i></i></a><div id="fragbit-2427" class="collapse"><div class="fragmentcode">                     RayQueue *cameraRayQueue = <a href="#WavefrontPathIntegrator::CurrentRayQueue" class="code">CurrentRayQueue</a>(0);
                     <a href="#WavefrontPathIntegrator::Do" class="code">Do</a>("<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#WorkQueue::Reset" class="code">Reset</a> ray queue", PBRT_CPU_GPU_LAMBDA () {
                                               cameraRayQueue-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#WorkQueue::Reset" class="code">Reset</a>();
                                           });
                     <a href="#WavefrontPathIntegrator::GenerateCameraRays" class="code">GenerateCameraRays</a>(y0, sampleIndex);
                     </div></div>
                  &lt;&lt;<span class="fragmentname"><a href="#fragment-Traceraysandestimateradianceuptomaximumraydepth-0">Trace rays and estimate radiance up to maximum ray depth</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2428" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2428"><i></i></a><div id="fragbit-2428" class="collapse"><div class="fragmentcode">                     for (int wavefrontDepth = 0; true; ++wavefrontDepth) {
                         &lt;&lt;<span class="fragmentname"><a href="#fragment-Resetqueuesbeforetracingrays-0">Reset queues before tracing rays</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2429" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2429"><i></i></a><div id="fragbit-2429" class="collapse"><div class="fragmentcode">                            <a href="#RayQueue" class="code">RayQueue</a> *nextQueue = <a href="#WavefrontPathIntegrator::NextRayQueue" class="code">NextRayQueue</a>(wavefrontDepth);
                            <a href="#WavefrontPathIntegrator::Do" class="code">Do</a>("<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#WorkQueue::Reset" class="code">Reset</a> queues before tracing rays",
                               PBRT_CPU_GPU_LAMBDA () {
                                   nextQueue-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#WorkQueue::Reset" class="code">Reset</a>();
                                   &lt;&lt;<span class="fragmentname"><a href="#fragment-Resetqueuesbeforetracingnextbatchofrays-0">Reset queues before tracing next batch of rays</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2430" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2430"><i></i></a><div id="fragbit-2430" class="collapse"><div class="fragmentcode">                                      if (mediumSampleQueue)
                                          mediumSampleQueue-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue::Reset" class="code">Reset</a>();
                                      if (mediumScatterQueue)
                                          mediumScatterQueue-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue::Reset" class="code">Reset</a>();
                                      if (<a href="#WavefrontPathIntegrator::escapedRayQueue" class="code">escapedRayQueue</a>) <a href="#WavefrontPathIntegrator::escapedRayQueue" class="code">escapedRayQueue</a>-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue::Reset" class="code">Reset</a>();
                                      <a href="#WavefrontPathIntegrator::hitAreaLightQueue" class="code">hitAreaLightQueue</a>-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue::Reset" class="code">Reset</a>();
                                      <a href="#WavefrontPathIntegrator::basicEvalMaterialQueue" class="code">basicEvalMaterialQueue</a>-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue::Reset" class="code">Reset</a>();
                                      <a href="#WavefrontPathIntegrator::universalEvalMaterialQueue" class="code">universalEvalMaterialQueue</a>-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue::Reset" class="code">Reset</a>();
                                      if (bssrdfEvalQueue)
                                          bssrdfEvalQueue-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue::Reset" class="code">Reset</a>();
                                      if (subsurfaceScatterQueue)
                                          subsurfaceScatterQueue-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue::Reset" class="code">Reset</a>();</div></div>
                               });</div></div>
                         &lt;&lt;<span class="fragmentname"><a href="#fragment-Followactiveraypathsandaccumulateradianceestimates-0">Follow active ray paths and accumulate radiance estimates</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2431" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2431"><i></i></a><div id="fragbit-2431" class="collapse"><div class="fragmentcode">                            <a href="#WavefrontPathIntegrator::GenerateRaySamples" class="code">GenerateRaySamples</a>(wavefrontDepth, sampleIndex);
                            &lt;&lt;<span class="fragmentname"><a href="#fragment-Findclosestintersectionsalongactiverays-0">Find closest intersections along active rays</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2432" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2432"><i></i></a><div id="fragbit-2432" class="collapse"><div class="fragmentcode">                               <a href="#WavefrontPathIntegrator::aggregate" class="code">aggregate</a>-&gt;<a href="#WavefrontAggregate::IntersectClosest" class="code">IntersectClosest</a>(<a href="#WavefrontPathIntegrator::maxQueueSize" class="code">maxQueueSize</a>, <a href="#WavefrontPathIntegrator::CurrentRayQueue" class="code">CurrentRayQueue</a>(wavefrontDepth),
                                   <a href="#WavefrontPathIntegrator::escapedRayQueue" class="code">escapedRayQueue</a>, <a href="#WavefrontPathIntegrator::hitAreaLightQueue" class="code">hitAreaLightQueue</a>, <a href="#WavefrontPathIntegrator::basicEvalMaterialQueue" class="code">basicEvalMaterialQueue</a>,
                                   <a href="#WavefrontPathIntegrator::universalEvalMaterialQueue" class="code">universalEvalMaterialQueue</a>, <a href="#WavefrontPathIntegrator::mediumSampleQueue" class="code">mediumSampleQueue</a>,
                                   <a href="#WavefrontPathIntegrator::NextRayQueue" class="code">NextRayQueue</a>(wavefrontDepth));</div></div>
                            <a href="#WavefrontPathIntegrator::SampleMediumInteraction" class="code">SampleMediumInteraction</a>(wavefrontDepth);
                            <a href="#WavefrontPathIntegrator::HandleEscapedRays" class="code">HandleEscapedRays</a>();
                            <a href="#WavefrontPathIntegrator::HandleEmissiveIntersection" class="code">HandleEmissiveIntersection</a>();
                            if (wavefrontDepth == <a href="#WavefrontPathIntegrator::maxDepth" class="code">maxDepth</a>)
                                break;
                            <a href="#WavefrontPathIntegrator::EvaluateMaterialsAndBSDFs" class="code">EvaluateMaterialsAndBSDFs</a>(wavefrontDepth);
                            <a href="#WavefrontPathIntegrator::TraceShadowRays" class="code">TraceShadowRays</a>(wavefrontDepth);
                            SampleSubsurface(wavefrontDepth);</div></div>
                     }</div></div>
                  <a href="#WavefrontPathIntegrator::UpdateFilm" class="code">UpdateFilm</a>();
              }</div></div>
       }
       </div></div>
}</div><p>


</p>
<p>By default, the number of samples taken in each pixel is the number
determined by the <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler"><tt>Sampler</tt></a>; the value returned by its
<tt>SamplesPerPixel()</tt> method is
cached in a member variable for the same reason as <tt>pixelBounds</tt> is
cached above.  It is possible to limit rendering to a single specified
sample index using the <tt>&ndash;debugstart</tt> command line option; the code to set
<tt>firstSampleIndex</tt> and <tt>lastSampleIndex</tt> in that case is not
included here.

</p>
<p></p>
<span class="anchor" id="fragment-Loopoversampleindicesandevaluatepixelsamples-0"></span><div class="fragmentname">&lt;&lt;Loop over sample indices and evaluate pixel samples&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">int firstSampleIndex = 0, lastSampleIndex = <a href="#WavefrontPathIntegrator::samplesPerPixel" class="code">samplesPerPixel</a>;
for (int sampleIndex = firstSampleIndex; sampleIndex &lt; lastSampleIndex;
     ++sampleIndex) {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-RenderimageforsamplemonosampleIndex-0">Render image for sample <tt>sampleIndex</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2433" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2433"><i></i></a><div id="fragbit-2433" class="collapse"><div class="fragmentcode">       for (int y0 = pixelBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds2::pMin" class="code">pMin</a>.y; y0 &lt; pixelBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds2::pMax" class="code">pMax</a>.y;
            y0 += <a href="#WavefrontPathIntegrator::scanlinesPerPass" class="code">scanlinesPerPass</a>) {
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Generatecameraraysforcurrentscanlinerange-0">Generate camera rays for current scanline range</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2434" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2434"><i></i></a><div id="fragbit-2434" class="collapse"><div class="fragmentcode">              RayQueue *cameraRayQueue = <a href="#WavefrontPathIntegrator::CurrentRayQueue" class="code">CurrentRayQueue</a>(0);
              <a href="#WavefrontPathIntegrator::Do" class="code">Do</a>("<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#WorkQueue::Reset" class="code">Reset</a> ray queue", PBRT_CPU_GPU_LAMBDA () {
                                        cameraRayQueue-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#WorkQueue::Reset" class="code">Reset</a>();
                                    });
              <a href="#WavefrontPathIntegrator::GenerateCameraRays" class="code">GenerateCameraRays</a>(y0, sampleIndex);
              </div></div>
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Traceraysandestimateradianceuptomaximumraydepth-0">Trace rays and estimate radiance up to maximum ray depth</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2435" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2435"><i></i></a><div id="fragbit-2435" class="collapse"><div class="fragmentcode">              for (int wavefrontDepth = 0; true; ++wavefrontDepth) {
                  &lt;&lt;<span class="fragmentname"><a href="#fragment-Resetqueuesbeforetracingrays-0">Reset queues before tracing rays</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2436" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2436"><i></i></a><div id="fragbit-2436" class="collapse"><div class="fragmentcode">                     <a href="#RayQueue" class="code">RayQueue</a> *nextQueue = <a href="#WavefrontPathIntegrator::NextRayQueue" class="code">NextRayQueue</a>(wavefrontDepth);
                     <a href="#WavefrontPathIntegrator::Do" class="code">Do</a>("<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#WorkQueue::Reset" class="code">Reset</a> queues before tracing rays",
                        PBRT_CPU_GPU_LAMBDA () {
                            nextQueue-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#WorkQueue::Reset" class="code">Reset</a>();
                            &lt;&lt;<span class="fragmentname"><a href="#fragment-Resetqueuesbeforetracingnextbatchofrays-0">Reset queues before tracing next batch of rays</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2437" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2437"><i></i></a><div id="fragbit-2437" class="collapse"><div class="fragmentcode">                               if (mediumSampleQueue)
                                   mediumSampleQueue-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue::Reset" class="code">Reset</a>();
                               if (mediumScatterQueue)
                                   mediumScatterQueue-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue::Reset" class="code">Reset</a>();
                               if (<a href="#WavefrontPathIntegrator::escapedRayQueue" class="code">escapedRayQueue</a>) <a href="#WavefrontPathIntegrator::escapedRayQueue" class="code">escapedRayQueue</a>-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue::Reset" class="code">Reset</a>();
                               <a href="#WavefrontPathIntegrator::hitAreaLightQueue" class="code">hitAreaLightQueue</a>-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue::Reset" class="code">Reset</a>();
                               <a href="#WavefrontPathIntegrator::basicEvalMaterialQueue" class="code">basicEvalMaterialQueue</a>-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue::Reset" class="code">Reset</a>();
                               <a href="#WavefrontPathIntegrator::universalEvalMaterialQueue" class="code">universalEvalMaterialQueue</a>-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue::Reset" class="code">Reset</a>();
                               if (bssrdfEvalQueue)
                                   bssrdfEvalQueue-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue::Reset" class="code">Reset</a>();
                               if (subsurfaceScatterQueue)
                                   subsurfaceScatterQueue-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue::Reset" class="code">Reset</a>();</div></div>
                        });</div></div>
                  &lt;&lt;<span class="fragmentname"><a href="#fragment-Followactiveraypathsandaccumulateradianceestimates-0">Follow active ray paths and accumulate radiance estimates</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2438" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2438"><i></i></a><div id="fragbit-2438" class="collapse"><div class="fragmentcode">                     <a href="#WavefrontPathIntegrator::GenerateRaySamples" class="code">GenerateRaySamples</a>(wavefrontDepth, sampleIndex);
                     &lt;&lt;<span class="fragmentname"><a href="#fragment-Findclosestintersectionsalongactiverays-0">Find closest intersections along active rays</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2439" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2439"><i></i></a><div id="fragbit-2439" class="collapse"><div class="fragmentcode">                        <a href="#WavefrontPathIntegrator::aggregate" class="code">aggregate</a>-&gt;<a href="#WavefrontAggregate::IntersectClosest" class="code">IntersectClosest</a>(<a href="#WavefrontPathIntegrator::maxQueueSize" class="code">maxQueueSize</a>, <a href="#WavefrontPathIntegrator::CurrentRayQueue" class="code">CurrentRayQueue</a>(wavefrontDepth),
                            <a href="#WavefrontPathIntegrator::escapedRayQueue" class="code">escapedRayQueue</a>, <a href="#WavefrontPathIntegrator::hitAreaLightQueue" class="code">hitAreaLightQueue</a>, <a href="#WavefrontPathIntegrator::basicEvalMaterialQueue" class="code">basicEvalMaterialQueue</a>,
                            <a href="#WavefrontPathIntegrator::universalEvalMaterialQueue" class="code">universalEvalMaterialQueue</a>, <a href="#WavefrontPathIntegrator::mediumSampleQueue" class="code">mediumSampleQueue</a>,
                            <a href="#WavefrontPathIntegrator::NextRayQueue" class="code">NextRayQueue</a>(wavefrontDepth));</div></div>
                     <a href="#WavefrontPathIntegrator::SampleMediumInteraction" class="code">SampleMediumInteraction</a>(wavefrontDepth);
                     <a href="#WavefrontPathIntegrator::HandleEscapedRays" class="code">HandleEscapedRays</a>();
                     <a href="#WavefrontPathIntegrator::HandleEmissiveIntersection" class="code">HandleEmissiveIntersection</a>();
                     if (wavefrontDepth == <a href="#WavefrontPathIntegrator::maxDepth" class="code">maxDepth</a>)
                         break;
                     <a href="#WavefrontPathIntegrator::EvaluateMaterialsAndBSDFs" class="code">EvaluateMaterialsAndBSDFs</a>(wavefrontDepth);
                     <a href="#WavefrontPathIntegrator::TraceShadowRays" class="code">TraceShadowRays</a>(wavefrontDepth);
                     SampleSubsurface(wavefrontDepth);</div></div>
              }</div></div>
           <a href="#WavefrontPathIntegrator::UpdateFilm" class="code">UpdateFilm</a>();
       }</div></div>
}
</div><p>


</p>
<p>Given a sample index, the next step is to loop over the one or more chunks
of scanlines and to evaluate a sample in each of their pixels.  This code
is also similar to the corresponding code in the <a href="../Light_Transport_II_Volume_Rendering/Volume_Scattering_Integrators.html#VolPathIntegrator"><tt>VolPathIntegrator</tt></a>:
evaluating each sample starts with generating a camera ray and then
following it through multiple intersections until it is terminated or the maximum
depth is reached.  The key difference is that, here, these tasks are being
performed for as many as a million or so pixel samples at a time.

</p>
<p></p>
<span class="anchor" id="fragment-RenderimageforsamplemonosampleIndex-0"></span><div class="fragmentname">&lt;&lt;Render image for sample <tt>sampleIndex</tt>&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">for (int y0 = pixelBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds2::pMin" class="code">pMin</a>.y; y0 &lt; pixelBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds2::pMax" class="code">pMax</a>.y;
     y0 += <a href="#WavefrontPathIntegrator::scanlinesPerPass" class="code">scanlinesPerPass</a>) {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Generatecameraraysforcurrentscanlinerange-0">Generate camera rays for current scanline range</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2440" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2440"><i></i></a><div id="fragbit-2440" class="collapse"><div class="fragmentcode">       RayQueue *cameraRayQueue = <a href="#WavefrontPathIntegrator::CurrentRayQueue" class="code">CurrentRayQueue</a>(0);
       <a href="#WavefrontPathIntegrator::Do" class="code">Do</a>("<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#WorkQueue::Reset" class="code">Reset</a> ray queue", PBRT_CPU_GPU_LAMBDA () {
                                 cameraRayQueue-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#WorkQueue::Reset" class="code">Reset</a>();
                             });
       <a href="#WavefrontPathIntegrator::GenerateCameraRays" class="code">GenerateCameraRays</a>(y0, sampleIndex);
       </div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Traceraysandestimateradianceuptomaximumraydepth-0">Trace rays and estimate radiance up to maximum ray depth</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2441" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2441"><i></i></a><div id="fragbit-2441" class="collapse"><div class="fragmentcode">       for (int wavefrontDepth = 0; true; ++wavefrontDepth) {
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Resetqueuesbeforetracingrays-0">Reset queues before tracing rays</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2442" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2442"><i></i></a><div id="fragbit-2442" class="collapse"><div class="fragmentcode">              <a href="#RayQueue" class="code">RayQueue</a> *nextQueue = <a href="#WavefrontPathIntegrator::NextRayQueue" class="code">NextRayQueue</a>(wavefrontDepth);
              <a href="#WavefrontPathIntegrator::Do" class="code">Do</a>("<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#WorkQueue::Reset" class="code">Reset</a> queues before tracing rays",
                 PBRT_CPU_GPU_LAMBDA () {
                     nextQueue-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#WorkQueue::Reset" class="code">Reset</a>();
                     &lt;&lt;<span class="fragmentname"><a href="#fragment-Resetqueuesbeforetracingnextbatchofrays-0">Reset queues before tracing next batch of rays</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2443" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2443"><i></i></a><div id="fragbit-2443" class="collapse"><div class="fragmentcode">                        if (mediumSampleQueue)
                            mediumSampleQueue-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue::Reset" class="code">Reset</a>();
                        if (mediumScatterQueue)
                            mediumScatterQueue-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue::Reset" class="code">Reset</a>();
                        if (<a href="#WavefrontPathIntegrator::escapedRayQueue" class="code">escapedRayQueue</a>) <a href="#WavefrontPathIntegrator::escapedRayQueue" class="code">escapedRayQueue</a>-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue::Reset" class="code">Reset</a>();
                        <a href="#WavefrontPathIntegrator::hitAreaLightQueue" class="code">hitAreaLightQueue</a>-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue::Reset" class="code">Reset</a>();
                        <a href="#WavefrontPathIntegrator::basicEvalMaterialQueue" class="code">basicEvalMaterialQueue</a>-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue::Reset" class="code">Reset</a>();
                        <a href="#WavefrontPathIntegrator::universalEvalMaterialQueue" class="code">universalEvalMaterialQueue</a>-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue::Reset" class="code">Reset</a>();
                        if (bssrdfEvalQueue)
                            bssrdfEvalQueue-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue::Reset" class="code">Reset</a>();
                        if (subsurfaceScatterQueue)
                            subsurfaceScatterQueue-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue::Reset" class="code">Reset</a>();</div></div>
                 });</div></div>
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Followactiveraypathsandaccumulateradianceestimates-0">Follow active ray paths and accumulate radiance estimates</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2444" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2444"><i></i></a><div id="fragbit-2444" class="collapse"><div class="fragmentcode">              <a href="#WavefrontPathIntegrator::GenerateRaySamples" class="code">GenerateRaySamples</a>(wavefrontDepth, sampleIndex);
              &lt;&lt;<span class="fragmentname"><a href="#fragment-Findclosestintersectionsalongactiverays-0">Find closest intersections along active rays</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2445" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2445"><i></i></a><div id="fragbit-2445" class="collapse"><div class="fragmentcode">                 <a href="#WavefrontPathIntegrator::aggregate" class="code">aggregate</a>-&gt;<a href="#WavefrontAggregate::IntersectClosest" class="code">IntersectClosest</a>(<a href="#WavefrontPathIntegrator::maxQueueSize" class="code">maxQueueSize</a>, <a href="#WavefrontPathIntegrator::CurrentRayQueue" class="code">CurrentRayQueue</a>(wavefrontDepth),
                     <a href="#WavefrontPathIntegrator::escapedRayQueue" class="code">escapedRayQueue</a>, <a href="#WavefrontPathIntegrator::hitAreaLightQueue" class="code">hitAreaLightQueue</a>, <a href="#WavefrontPathIntegrator::basicEvalMaterialQueue" class="code">basicEvalMaterialQueue</a>,
                     <a href="#WavefrontPathIntegrator::universalEvalMaterialQueue" class="code">universalEvalMaterialQueue</a>, <a href="#WavefrontPathIntegrator::mediumSampleQueue" class="code">mediumSampleQueue</a>,
                     <a href="#WavefrontPathIntegrator::NextRayQueue" class="code">NextRayQueue</a>(wavefrontDepth));</div></div>
              <a href="#WavefrontPathIntegrator::SampleMediumInteraction" class="code">SampleMediumInteraction</a>(wavefrontDepth);
              <a href="#WavefrontPathIntegrator::HandleEscapedRays" class="code">HandleEscapedRays</a>();
              <a href="#WavefrontPathIntegrator::HandleEmissiveIntersection" class="code">HandleEmissiveIntersection</a>();
              if (wavefrontDepth == <a href="#WavefrontPathIntegrator::maxDepth" class="code">maxDepth</a>)
                  break;
              <a href="#WavefrontPathIntegrator::EvaluateMaterialsAndBSDFs" class="code">EvaluateMaterialsAndBSDFs</a>(wavefrontDepth);
              <a href="#WavefrontPathIntegrator::TraceShadowRays" class="code">TraceShadowRays</a>(wavefrontDepth);
              SampleSubsurface(wavefrontDepth);</div></div>
       }</div></div>
    <a href="#WavefrontPathIntegrator::UpdateFilm" class="code">UpdateFilm</a>();
}</div><p>


</p>
<p>Before the rays are generated, it is necessary to reset the work queue that
will store them.  We will need to maintain more than one ray queue: one for
the set of rays currently being traced and another for the indirect rays
that have been spawned to be traced at the next depth.  The
<tt>CurrentRayQueue()</tt> method, defined shortly, returns the queue for
the specified depth.

</p>
<p>When the GPU is being used for rendering, it is critically important that the
<tt>Reset()</tt> method is called from the GPU and not the CPU;
<tt>Do()</tt> is thus used here.  Not only could resetting it from the CPU
be inefficient, as doing so would involve the CPU writing to managed memory,
but&mdash;given the asynchronous execution of the GPU&mdash;it would almost certainly
be incorrect, potentially resetting a queue that was still in use by the
code that was executing on the GPU.

</p>
<p></p>
<span class="anchor" id="fragment-Generatecameraraysforcurrentscanlinerange-0"></span><div class="fragmentname">&lt;&lt;Generate camera rays for current scanline range&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">RayQueue *cameraRayQueue = <a href="#WavefrontPathIntegrator::CurrentRayQueue" class="code">CurrentRayQueue</a>(0);
<a href="#WavefrontPathIntegrator::Do" class="code">Do</a>("<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#WorkQueue::Reset" class="code">Reset</a> ray queue", PBRT_CPU_GPU_LAMBDA () {
                          cameraRayQueue-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#WorkQueue::Reset" class="code">Reset</a>();
                      });
<a href="#WavefrontPathIntegrator::GenerateCameraRays" class="code">GenerateCameraRays</a>(y0, sampleIndex);
</div><p>


</p>
<p>The <tt>RayQueue</tt> class adds a few convenience methods to <a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#WorkQueue"><tt>WorkQueue</tt></a>
that we will discuss in the following pages.  (<a href="#RayWorkItem"><tt>RayWorkItem</tt></a> will also
be defined in a few pages, closer to where it is first used.)

</p>
<p></p>
<span class="anchor" id="fragment-RayQueueDefinition-0"></span><div class="fragmentname">&lt;&lt;RayQueue Definition&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">class <span class="anchor" id="RayQueue"></span>RayQueue : public <a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#WorkQueue" class="code">WorkQueue</a>&lt;<a href="#RayWorkItem" class="code">RayWorkItem</a>&gt; {
  public:
    &lt;&lt;<span class="fragmentname"><a href="#fragment-RayQueuePublicMethods-0">RayQueue Public Methods</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2446" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2446"><i></i></a><div id="fragbit-2446" class="collapse"><div class="fragmentcode">       int PushCameraRay(const <a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> &amp;ray, const <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> &amp;lambda,
                         int pixelIndex);
       int PushIndirectRay(const <a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> &amp;ray, int depth, const <a href="../Light_Sources/Light_Interface.html#LightSampleContext" class="code">LightSampleContext</a> &amp;prevIntrCtx,
           const <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> &amp;beta, const <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> &amp;r_u,
           const <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> &amp;r_l, const <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> &amp;lambda,
           Float etaScale, bool specularBounce, bool anyNonSpecularBounces,
           int pixelIndex);</div></div>
};</div><p>


</p>
<p>The <tt>WavefrontPathIntegrator</tt> maintains a pair of ray queues, rather than
allocating one for each ray depth up to the maximum.  It manages them using
<em>double buffering</em>: one stores the current active set of rays and
should only be read from, while the other stores the rays enqueued to trace
at the next depth and should only be written to.  At each successive ray
depth, the roles of the two queues are switched.

</p>
<p></p>
<span class="anchor" id="fragment-WavefrontPathIntegratorMemberVariables-5"></span><div class="fragmentname">&lt;&lt;WavefrontPathIntegrator Member Variables&gt;&gt;+=&nbsp;<a href="#fragment-WavefrontPathIntegratorMemberVariables-4"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-WavefrontPathIntegratorMemberVariables-6"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">RayQueue *<span class="anchor" id="WavefrontPathIntegrator::rayQueues"></span>rayQueues[2];</div><p>


</p>
<p>Two convenience methods return pointers to the <a href="#RayQueue"><tt>RayQueue</tt></a>s given a
depth.  The double buffering logic is effectively encapsulated in their
implementations.

</p>
<p></p>
<span class="anchor" id="fragment-WavefrontPathIntegratorPublicMethods-3"></span><div class="fragmentname">&lt;&lt;WavefrontPathIntegrator Public Methods&gt;&gt;+=&nbsp;<a href="#fragment-WavefrontPathIntegratorPublicMethods-2"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode">RayQueue *<span class="anchor" id="WavefrontPathIntegrator::CurrentRayQueue"></span>CurrentRayQueue(int wavefrontDepth) {
    return <a href="#WavefrontPathIntegrator::rayQueues" class="code">rayQueues</a>[wavefrontDepth &amp; 1];
}
RayQueue *<span class="anchor" id="WavefrontPathIntegrator::NextRayQueue"></span>NextRayQueue(int wavefrontDepth) {
    return <a href="#WavefrontPathIntegrator::rayQueues" class="code">rayQueues</a>[(wavefrontDepth + 1) &amp; 1];
}</div><p>


</p>
<p>

</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#GeneratingCameraRays"><i class="fas fa-link h3h4marginlink"></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span class="anchor" id="sec:gpu-camera-rays"></span><span id="GeneratingCameraRays"></span><h3>15.3.3  Generating Camera Rays</h3><p>



</p>
<p>The two methods related to generating camera rays are implemented in the
file <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/wavefront/camera.cpp"><tt>wavefront/camera.cpp</tt></a>, not in
<a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/wavefront/integrator.cpp"><tt>wavefront/integrator.cpp</tt></a>, because we have used C++ templates
to generate multiple specialized instances of the methods, each
one specialized based on some of the object types involved.  As mentioned
earlier, techniques like this can cause lengthy compile times, so it is
worthwhile to isolate the camera method implementations in their own source
file.

</p>
<p>There are two <tt>GenerateCameraRays()</tt> methods.  The first, which is
called by <a href="#WavefrontPathIntegrator::Render"><tt>WavefrontPathIntegrator::Render()</tt></a>, determines the concrete
type of the <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler"><tt>Sampler</tt></a> being used and then calls the second
<tt>GenerateCameraRays()</tt> method, which is templated on the type of the
<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler"><tt>Sampler</tt></a>.  This idea is something that we will see again in other
methods: CPU code making a runtime determination of the types of objects
involved in a computation, which allows the execution of code that is specialized for
those types.  This is especially beneficial to performance when running on
the GPU.

</p>
<p>The first method defines a lambda function, <tt>generateRays</tt>, and then
invokes the <a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer"><tt>TaggedPointer</tt></a>&rsquo;s dynamic dispatch mechanism, which will end
up calling the lambda function using the concrete type of the
<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler"><tt>Sampler</tt></a>.  (In this case, we use the <tt>DispatchCPU()</tt> variant,
which must be used for code that can only execute on the CPU.)

</p>
<p></p>
<span class="anchor" id="fragment-WavefrontPathIntegratorCameraRayMethods-0"></span><div class="fragmentname">&lt;&lt;WavefrontPathIntegrator Camera Ray Methods&gt;&gt;=&nbsp;<a href="#fragment-WavefrontPathIntegratorCameraRayMethods-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">void <span class="anchor" id="WavefrontPathIntegrator::GenerateCameraRays"></span>WavefrontPathIntegrator::GenerateCameraRays(int y0, int sampleIndex) {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-DefinemonogenerateRayslambdafunction-0">Define <tt>generateRays</tt> lambda function</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2447" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2447"><i></i></a><div id="fragbit-2447" class="collapse"><div class="fragmentcode">       auto generateRays = [=](auto sampler) {
           using ConcreteSampler = std::remove_reference_t&lt;decltype(*sampler)&gt;;
           if constexpr (!std::is_same_v&lt;ConcreteSampler, MLTSampler&gt; &amp;&amp;
                         !std::is_same_v&lt;ConcreteSampler, DebugMLTSampler&gt;)
               GenerateCameraRays&lt;ConcreteSampler&gt;(y0, sampleIndex);
       };</div></div>
    <a href="#WavefrontPathIntegrator::sampler" class="code">sampler</a>.<a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer::DispatchCPU" class="code">DispatchCPU</a>(generateRays);
}</div><p>


</p>
<p>Using <tt>auto</tt> in the parameter declaration for the following
lambda function causes it to be parameterized by the type of
<tt>sampler</tt>, like a template function.  (C++20 provides a less obscure
syntax for templated lambda functions, though this version of <tt>pbrt</tt> limits
itself to C++17.)  Thus, the type of <tt>sampler</tt> will be a concrete
instance of one of the sampler types provided in the
<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler"><tt>Sampler</tt></a> declaration in Section&nbsp;<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#sec:sampling-interface">8.3</a>.

</p>
<p>There is a nit in that <tt>sampler</tt> is passed as a reference to a pointer
to the specific <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler"><tt>Sampler</tt></a> type; a bit of work in the <tt>using</tt>
declaration gives us the actual <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler"><tt>Sampler</tt></a> type.  A second nit is that
we must filter out the <tt>MLTSampler</tt>, which is only used by the <tt>MLTIntegrator</tt>, and <tt>DebugMLTSampler</tt>, a
variant of it that is used for debugging.  Those classes use <tt>vector</tt>
methods like <tt>push_back()</tt> that are not supported in GPU code, and
therefore we must make clear to the compiler what we know in any case:
those samplers will not be used here.

</p>
<p>With the concrete sampler type in hand, the second
<tt>GenerateCameraRays()</tt> method can be called, with the sampler type
provided for the template specialization.

</p>
<p></p>
<span class="anchor" id="fragment-DefinemonogenerateRayslambdafunction-0"></span><div class="fragmentname">&lt;&lt;Define <tt>generateRays</tt> lambda function&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">auto generateRays = [=](auto sampler) {
    using ConcreteSampler = std::remove_reference_t&lt;decltype(*sampler)&gt;;
    if constexpr (!std::is_same_v&lt;ConcreteSampler, MLTSampler&gt; &amp;&amp;
                  !std::is_same_v&lt;ConcreteSampler, DebugMLTSampler&gt;)
        GenerateCameraRays&lt;ConcreteSampler&gt;(y0, sampleIndex);
};</div><p>


</p>
<p>We can now move on to the second <tt>GenerateCameraRays()</tt> method, which
calls <a href="#WavefrontPathIntegrator::ParallelFor"><tt>WavefrontPathIntegrator::ParallelFor()</tt></a> to generate all of
the rays in parallel.

</p>
<p></p>
<span class="anchor" id="fragment-WavefrontPathIntegratorCameraRayMethods-1"></span><div class="fragmentname">&lt;&lt;WavefrontPathIntegrator Camera Ray Methods&gt;&gt;+=&nbsp;<a href="#fragment-WavefrontPathIntegratorCameraRayMethods-0"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode">template &lt;typename ConcreteSampler&gt;
void WavefrontPathIntegrator::GenerateCameraRays(int y0, int sampleIndex) {
    <a href="#RayQueue" class="code">RayQueue</a> *rayQueue = <a href="#WavefrontPathIntegrator::CurrentRayQueue" class="code">CurrentRayQueue</a>(0);
    <a href="#WavefrontPathIntegrator::ParallelFor" class="code">ParallelFor</a>("Generate camera rays", <a href="#WavefrontPathIntegrator::maxQueueSize" class="code">maxQueueSize</a>,
        PBRT_CPU_GPU_LAMBDA (int pixelIndex) {
            &lt;&lt;<span class="fragmentname"><a href="#fragment-Enqueuecamerarayandsetpixelstateforsample-0">Enqueue camera ray and set pixel state for sample</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2448" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2448"><i></i></a><div id="fragbit-2448" class="collapse"><div class="fragmentcode">               &lt;&lt;<span class="fragmentname"><a href="#fragment-ComputepixelcoordinatesformonopixelIndex-0">Compute pixel coordinates for <tt>pixelIndex</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2449" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2449"><i></i></a><div id="fragbit-2449" class="collapse"><div class="fragmentcode">                  <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds2i" class="code">Bounds2i</a> pixelBounds = <a href="#WavefrontPathIntegrator::film" class="code">film</a>.<a href="../Cameras_and_Film/Film_and_Imaging.html#Film::PixelBounds" class="code">PixelBounds</a>();
                  int xResolution = pixelBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds2::pMax" class="code">pMax</a>.x - pixelBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds2::pMin" class="code">pMin</a>.x;
                  <a href="../Geometry_and_Transformations/Points.html#Point2i" class="code">Point2i</a> <a href="#PixelSampleState::pPixel" class="code">pPixel</a>(pixelBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds2::pMin" class="code">pMin</a>.x + pixelIndex % xResolution,
                                 y0 + pixelIndex / xResolution);
                  <a href="#WavefrontPathIntegrator::pixelSampleState" class="code">pixelSampleState</a>.<a href="#PixelSampleState::pPixel" class="code">pPixel</a>[pixelIndex] = <a href="#PixelSampleState::pPixel" class="code">pPixel</a>;</div></div>
               &lt;&lt;<span class="fragmentname"><a href="#fragment-Testpixelcoordinatesagainstpixelbounds-0">Test pixel coordinates against pixel bounds</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2450" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2450"><i></i></a><div id="fragbit-2450" class="collapse"><div class="fragmentcode">                  if (!<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds2::InsideExclusive" class="code">InsideExclusive</a>(pPixel, pixelBounds))
                      return;</div></div>
               &lt;&lt;<span class="fragmentname"><a href="#fragment-InitializeuseSamplerforcurrentpixelandsample-0">Initialize <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler"><tt>Sampler</tt></a> for current pixel and sample</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2451" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2451"><i></i></a><div id="fragbit-2451" class="collapse"><div class="fragmentcode">                  ConcreteSampler pixelSampler = *<a href="#WavefrontPathIntegrator::sampler" class="code">sampler</a>.<a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer::Cast" class="code">Cast</a>&lt;ConcreteSampler&gt;();
                  pixelSampler.<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::StartPixelSample" class="code">StartPixelSample</a>(pPixel, sampleIndex, 0);</div></div>
               &lt;&lt;<span class="fragmentname"><a href="#fragment-Samplewavelengthsforraypath-0">Sample wavelengths for ray path</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2452" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2452"><i></i></a><div id="fragbit-2452" class="collapse"><div class="fragmentcode">                  Float lu = pixelSampler.<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::Get1D" class="code">Get1D</a>();
                  <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> lambda = film.<a href="../Cameras_and_Film/Film_and_Imaging.html#Film::SampleWavelengths" class="code">SampleWavelengths</a>(lu);</div></div>
               &lt;&lt;<span class="fragmentname"><a href="#fragment-GeneratemonoCameraSampleandcorrespondingray-0">Generate <tt>CameraSample</tt> and corresponding ray</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2453" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2453"><i></i></a><div id="fragbit-2453" class="collapse"><div class="fragmentcode">                  <a href="../Cameras_and_Film/Camera_Interface.html#CameraSample" class="code">CameraSample</a> cameraSample = <a href="../Sampling_and_Reconstruction/Image_Reconstruction.html#GetCameraSample" class="code">GetCameraSample</a>(pixelSampler, pPixel, filter);
                  pstd::optional&lt;<a href="../Cameras_and_Film/Camera_Interface.html#CameraRay" class="code">CameraRay</a>&gt; cameraRay =
                      <a href="#WavefrontPathIntegrator::camera" class="code">camera</a>.<a href="../Cameras_and_Film/Camera_Interface.html#Camera::GenerateRay" class="code">GenerateRay</a>(cameraSample, lambda);</div></div>
               &lt;&lt;<span class="fragmentname"><a href="#fragment-InitializeremainderofmonoPixelSampleStateforray-0">Initialize remainder of <tt>PixelSampleState</tt> for ray</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2454" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2454"><i></i></a><div id="fragbit-2454" class="collapse"><div class="fragmentcode">                  pixelSampleState.<a href="#PixelSampleState::L" class="code">L</a>[pixelIndex] = <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a>(0.f);
                  pixelSampleState.<a href="#PixelSampleState::lambda" class="code">lambda</a>[pixelIndex] = <a href="#PixelSampleState::lambda" class="code">lambda</a>;
                  pixelSampleState.<a href="../Cameras_and_Film/Camera_Interface.html#CameraSample::filterWeight" class="code">filterWeight</a>[pixelIndex] = cameraSample.<a href="../Cameras_and_Film/Camera_Interface.html#CameraSample::filterWeight" class="code">filterWeight</a>;
                  if (initializeVisibleSurface)
                      pixelSampleState.<a href="#PixelSampleState::visibleSurface" class="code">visibleSurface</a>[pixelIndex] = <a href="../Cameras_and_Film/Film_and_Imaging.html#VisibleSurface" class="code">VisibleSurface</a>();</div></div>
               &lt;&lt;<span class="fragmentname"><a href="#fragment-Enqueuecamerarayforintersectiontests-0">Enqueue camera ray for intersection tests</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2455" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2455"><i></i></a><div id="fragbit-2455" class="collapse"><div class="fragmentcode">                  if (cameraRay) {
                      rayQueue-&gt;<a href="#RayQueue::PushCameraRay" class="code">PushCameraRay</a>(cameraRay-&gt;<a href="../Cameras_and_Film/Camera_Interface.html#CameraRay::ray" class="code">ray</a>, lambda, pixelIndex);
                      pixelSampleState.<a href="#PixelSampleState::cameraRayWeight" class="code">cameraRayWeight</a>[pixelIndex] = cameraRay-&gt;<a href="../Cameras_and_Film/Camera_Interface.html#CameraRay::weight" class="code">weight</a>;
                  } else
                      pixelSampleState.<a href="#PixelSampleState::cameraRayWeight" class="code">cameraRayWeight</a>[pixelIndex] = <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a>(0);</div></div></div></div>
        });
}</div><p>


</p>
<p>The sequence of operations performed for each camera ray again generally
matches what we have seen before: after computing the pixel coordinates for
the provided loop index, samples are generated, a set of wavelengths are
sampled, and then the <a href="../Cameras_and_Film/Camera_Interface.html#Camera"><tt>Camera</tt></a> generates the ray.

</p>
<p></p>
<span class="anchor" id="fragment-Enqueuecamerarayandsetpixelstateforsample-0"></span><div class="fragmentname">&lt;&lt;Enqueue camera ray and set pixel state for sample&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">&lt;&lt;<span class="fragmentname"><a href="#fragment-ComputepixelcoordinatesformonopixelIndex-0">Compute pixel coordinates for <tt>pixelIndex</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2456" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2456"><i></i></a><div id="fragbit-2456" class="collapse"><div class="fragmentcode">   <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds2i" class="code">Bounds2i</a> pixelBounds = <a href="#WavefrontPathIntegrator::film" class="code">film</a>.<a href="../Cameras_and_Film/Film_and_Imaging.html#Film::PixelBounds" class="code">PixelBounds</a>();
   int xResolution = pixelBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds2::pMax" class="code">pMax</a>.x - pixelBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds2::pMin" class="code">pMin</a>.x;
   <a href="../Geometry_and_Transformations/Points.html#Point2i" class="code">Point2i</a> <a href="#PixelSampleState::pPixel" class="code">pPixel</a>(pixelBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds2::pMin" class="code">pMin</a>.x + pixelIndex % xResolution,
                  y0 + pixelIndex / xResolution);
   <a href="#WavefrontPathIntegrator::pixelSampleState" class="code">pixelSampleState</a>.<a href="#PixelSampleState::pPixel" class="code">pPixel</a>[pixelIndex] = <a href="#PixelSampleState::pPixel" class="code">pPixel</a>;</div></div>
&lt;&lt;<span class="fragmentname"><a href="#fragment-Testpixelcoordinatesagainstpixelbounds-0">Test pixel coordinates against pixel bounds</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2457" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2457"><i></i></a><div id="fragbit-2457" class="collapse"><div class="fragmentcode">   if (!<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds2::InsideExclusive" class="code">InsideExclusive</a>(pPixel, pixelBounds))
       return;</div></div>
&lt;&lt;<span class="fragmentname"><a href="#fragment-InitializeuseSamplerforcurrentpixelandsample-0">Initialize <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler"><tt>Sampler</tt></a> for current pixel and sample</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2458" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2458"><i></i></a><div id="fragbit-2458" class="collapse"><div class="fragmentcode">   ConcreteSampler pixelSampler = *<a href="#WavefrontPathIntegrator::sampler" class="code">sampler</a>.<a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer::Cast" class="code">Cast</a>&lt;ConcreteSampler&gt;();
   pixelSampler.<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::StartPixelSample" class="code">StartPixelSample</a>(pPixel, sampleIndex, 0);</div></div>
&lt;&lt;<span class="fragmentname"><a href="#fragment-Samplewavelengthsforraypath-0">Sample wavelengths for ray path</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2459" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2459"><i></i></a><div id="fragbit-2459" class="collapse"><div class="fragmentcode">   Float lu = pixelSampler.<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::Get1D" class="code">Get1D</a>();
   <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> lambda = film.<a href="../Cameras_and_Film/Film_and_Imaging.html#Film::SampleWavelengths" class="code">SampleWavelengths</a>(lu);</div></div>
&lt;&lt;<span class="fragmentname"><a href="#fragment-GeneratemonoCameraSampleandcorrespondingray-0">Generate <tt>CameraSample</tt> and corresponding ray</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2460" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2460"><i></i></a><div id="fragbit-2460" class="collapse"><div class="fragmentcode">   <a href="../Cameras_and_Film/Camera_Interface.html#CameraSample" class="code">CameraSample</a> cameraSample = <a href="../Sampling_and_Reconstruction/Image_Reconstruction.html#GetCameraSample" class="code">GetCameraSample</a>(pixelSampler, pPixel, filter);
   pstd::optional&lt;<a href="../Cameras_and_Film/Camera_Interface.html#CameraRay" class="code">CameraRay</a>&gt; cameraRay =
       <a href="#WavefrontPathIntegrator::camera" class="code">camera</a>.<a href="../Cameras_and_Film/Camera_Interface.html#Camera::GenerateRay" class="code">GenerateRay</a>(cameraSample, lambda);</div></div>
&lt;&lt;<span class="fragmentname"><a href="#fragment-InitializeremainderofmonoPixelSampleStateforray-0">Initialize remainder of <tt>PixelSampleState</tt> for ray</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2461" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2461"><i></i></a><div id="fragbit-2461" class="collapse"><div class="fragmentcode">   pixelSampleState.<a href="#PixelSampleState::L" class="code">L</a>[pixelIndex] = <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a>(0.f);
   pixelSampleState.<a href="#PixelSampleState::lambda" class="code">lambda</a>[pixelIndex] = <a href="#PixelSampleState::lambda" class="code">lambda</a>;
   pixelSampleState.<a href="../Cameras_and_Film/Camera_Interface.html#CameraSample::filterWeight" class="code">filterWeight</a>[pixelIndex] = cameraSample.<a href="../Cameras_and_Film/Camera_Interface.html#CameraSample::filterWeight" class="code">filterWeight</a>;
   if (initializeVisibleSurface)
       pixelSampleState.<a href="#PixelSampleState::visibleSurface" class="code">visibleSurface</a>[pixelIndex] = <a href="../Cameras_and_Film/Film_and_Imaging.html#VisibleSurface" class="code">VisibleSurface</a>();</div></div>
&lt;&lt;<span class="fragmentname"><a href="#fragment-Enqueuecamerarayforintersectiontests-0">Enqueue camera ray for intersection tests</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2462" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2462"><i></i></a><div id="fragbit-2462" class="collapse"><div class="fragmentcode">   if (cameraRay) {
       rayQueue-&gt;<a href="#RayQueue::PushCameraRay" class="code">PushCameraRay</a>(cameraRay-&gt;<a href="../Cameras_and_Film/Camera_Interface.html#CameraRay::ray" class="code">ray</a>, lambda, pixelIndex);
       pixelSampleState.<a href="#PixelSampleState::cameraRayWeight" class="code">cameraRayWeight</a>[pixelIndex] = cameraRay-&gt;<a href="../Cameras_and_Film/Camera_Interface.html#CameraRay::weight" class="code">weight</a>;
   } else
       pixelSampleState.<a href="#PixelSampleState::cameraRayWeight" class="code">cameraRayWeight</a>[pixelIndex] = <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a>(0);</div></div></div><p>


</p>
<p>Given the pixel bounds of the film, the <tt>pixelIndex</tt> value is mapped
to pixel coordinates, starting from the <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.312ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 2287.2 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">left-parenthesis x comma y right-parenthesis</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-28" d="M332 -238c0 -5 -5 -10 -10 -10c-2 0 -4 1 -6 2c-110 83 -215 283 -215 454v84c0 171 105 371 215 454c2 1 4 2 6 2c5 0 10 -5 10 -10c0 -3 -2 -6 -4 -8c-104 -78 -173 -278 -173 -438v-84c0 -160 69 -360 173 -438c2 -2 4 -5 4 -8Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D465" d="M527 376c0 -40 -32 -58 -54 -58c-27 0 -38 19 -38 35c0 24 20 49 48 54c-21 13 -45 13 -50 13c-70 0 -93 -92 -99 -118l-34 -137c-11 -44 -17 -66 -17 -88c0 -34 16 -66 55 -66c32 0 100 24 133 131c2 7 4 11 13 11c3 0 12 0 12 -10c0 -25 -57 -154 -160 -154 c-60 0 -96 39 -108 76c-3 -6 -39 -76 -105 -76c-44 0 -94 20 -94 66c0 32 25 58 55 58c15 0 37 -8 37 -35c0 -28 -22 -49 -47 -54c21 -13 44 -13 50 -13c44 0 79 42 95 104c37 140 54 207 54 238c0 58 -35 67 -54 67c-34 0 -100 -25 -134 -131c-2 -9 -5 -11 -13 -11 c0 0 -12 0 -12 10c0 25 57 154 161 154c29 0 83 -10 108 -76c12 23 47 76 105 76c34 0 93 -14 93 -66Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2C" d="M203 1c0 -117 -80 -194 -91 -194c-5 0 -10 4 -10 11c0 3 0 5 11 16c33 33 68 93 68 167c0 14 -2 15 -2 15s-2 -1 -5 -3c-10 -9 -23 -13 -35 -13c-33 0 -53 26 -53 53c0 28 20 53 53 53c39 0 64 -39 64 -105Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D466" d="M490 404c0 -7 0 -9 -4 -23l-96 -382c-28 -113 -131 -204 -234 -204c-62 0 -106 37 -106 87c0 49 33 65 56 65c10 0 37 -4 37 -35c0 -19 -10 -32 -20 -41c-14 -12 -27 -12 -43 -12c17 -39 62 -42 76 -42c46 0 84 29 110 63c40 53 52 102 65 154c-28 -28 -62 -45 -101 -45 c-59 0 -122 30 -122 119c0 47 18 104 58 210c7 19 17 45 17 70c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -20 -4 -31 -20 -72c-34 -88 -51 -150 -51 -196c0 -37 11 -81 62 -81 c66 0 109 70 113 85l45 180l20 80c4 18 12 49 14 54c9 15 25 21 35 21c15 0 29 -9 29 -27Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-29" d="M288 208c0 -171 -105 -371 -215 -454c-2 -1 -4 -2 -6 -2c-5 0 -10 5 -10 10c0 3 2 6 4 8c104 78 173 278 173 438v84c0 160 -69 360 -173 438c-2 2 -4 5 -4 8c0 5 5 10 10 10c2 0 4 -1 6 -2c110 -83 215 -283 215 -454v-84Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-28" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D465" x="389" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="962" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D466" x="1407" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-29" x="1897" y="0"></use>
</g>
</svg> lower bound given by the
pixel bounds and <tt>y0</tt> value, respectively. Threads are then assigned
to pixels in scanline order.  Because the <tt>PBRT_GPU_LAMBDA</tt> macro
includes <tt>*this</tt> in the lambda capture, various
<a href="#WavefrontPathIntegrator"><tt>WavefrontPathIntegrator</tt></a> member variables such as <tt>film</tt>, which
is used here, can be directly accessed in the lambda function.

</p>
<p>The pixel coordinates are then stored in <a href="#PixelSampleState"><tt>PixelSampleState</tt></a>.  Note that
if we are just setting a single member variable of an <tt>SOA</tt> structure
rather than assigning an entire structure value, then the member variable
must be indexed and not the <tt>pixelSampleState</tt> structure itself; our
automatically generated <tt>SOA</tt> classes are not able to provide the same
syntax as would be used for an array of structures layout in that case.

</p>
<p></p>
<span class="anchor" id="fragment-ComputepixelcoordinatesformonopixelIndex-0"></span><div class="fragmentname">&lt;&lt;Compute pixel coordinates for <tt>pixelIndex</tt>&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds2i" class="code">Bounds2i</a> pixelBounds = <a href="#WavefrontPathIntegrator::film" class="code">film</a>.<a href="../Cameras_and_Film/Film_and_Imaging.html#Film::PixelBounds" class="code">PixelBounds</a>();
int xResolution = pixelBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds2::pMax" class="code">pMax</a>.x - pixelBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds2::pMin" class="code">pMin</a>.x;
<a href="../Geometry_and_Transformations/Points.html#Point2i" class="code">Point2i</a> <a href="#PixelSampleState::pPixel" class="code">pPixel</a>(pixelBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds2::pMin" class="code">pMin</a>.x + pixelIndex % xResolution,
               y0 + pixelIndex / xResolution);
<a href="#WavefrontPathIntegrator::pixelSampleState" class="code">pixelSampleState</a>.<a href="#PixelSampleState::pPixel" class="code">pPixel</a>[pixelIndex] = <a href="#PixelSampleState::pPixel" class="code">pPixel</a>;</div><p>


</p>
<p>The pixel coordinates corresponding to a sample are our first addition to
the <a href="#PixelSampleState"><tt>PixelSampleState</tt></a> structure.

</p>
<p></p>
<span class="anchor" id="fragment-PixelSampleStatePublicMembers-0"></span><div class="fragmentname">&lt;&lt;PixelSampleState Public Members&gt;&gt;=&nbsp;<a href="#fragment-PixelSampleStatePublicMembers-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode"><a href="../Geometry_and_Transformations/Points.html#Point2i" class="code">Point2i</a> <span class="anchor" id="PixelSampleState::pPixel"></span>pPixel;</div><p>


</p>
<p>If the image has been split into multiple spans of scanlines, then the
number of parallel loop iterations in the final pass may be a few more than
there are pixels left to be sampled.  Rather than worry about this when
specifying the number of threads to launch in the call to
<a href="#WavefrontPathIntegrator::ParallelFor"><tt>WavefrontPathIntegrator::ParallelFor()</tt></a>, we just check this condition in
the kernel.  Indices for out of bounds pixels return after initializing
<a href="#PixelSampleState::pPixel"><tt>PixelSampleState::pPixel</tt></a> and do not enqueue any rays.

</p>
<p></p>
<span class="anchor" id="fragment-Testpixelcoordinatesagainstpixelbounds-0"></span><div class="fragmentname">&lt;&lt;Test pixel coordinates against pixel bounds&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">if (!<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds2::InsideExclusive" class="code">InsideExclusive</a>(pPixel, pixelBounds))
    return;</div><p>


</p>
<p>Next, samples are needed to generate the camera ray.  Here we can see the
value of specializing this method based on the <tt>ConcreteSampler</tt> type.
The following fragment is perhaps best understood by reading it with the
<tt>ConcreteSampler</tt> in the following replaced with, say,
<tt>HaltonSampler</tt> in your head.  <tt>pixelSampler</tt> then is a
stack-allocated <tt>HaltonSampler</tt>, and the <a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer::Cast"><tt>TaggedPointer::Cast()</tt></a>
call gives us a pointer of that type; dereferencing it lets each thread
initialize its own sampler from the exemplar of the one that the
<tt>WavefrontPathIntegrator</tt> stores.  All threads access the same memory
locations, so reading the <tt>Sampler</tt> from memory does not consume much
bandwidth.

</p>
<p>The benefit from this approach comes from having the sampler allocated on
the stack.  On the GPU, its member variables can be stored directly in
registers, giving high performance when executing its methods.  As an
additional bonus, there is no overhead for dynamic dispatch in the
<tt>StartPixelSample()</tt> call: the sampler&rsquo;s type is known, so the
appropriate method can be called directly.  It will usually be expanded
inline at the call site.

</p>
<p></p>
<span class="anchor" id="fragment-InitializeuseSamplerforcurrentpixelandsample-0"></span><div class="fragmentname">&lt;&lt;Initialize <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler"><tt>Sampler</tt></a> for current pixel and sample&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">ConcreteSampler pixelSampler = *<a href="#WavefrontPathIntegrator::sampler" class="code">sampler</a>.<a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer::Cast" class="code">Cast</a>&lt;ConcreteSampler&gt;();
pixelSampler.<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::StartPixelSample" class="code">StartPixelSample</a>(pPixel, sampleIndex, 0);</div><p>


</p>
<p>Wavelengths are sampled in precisely the same way as they are in
most of the other integrators.

</p>
<p></p>
<span class="anchor" id="fragment-Samplewavelengthsforraypath-0"></span><div class="fragmentname">&lt;&lt;Sample wavelengths for ray path&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">Float lu = pixelSampler.<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::Get1D" class="code">Get1D</a>();
<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> lambda = film.<a href="../Cameras_and_Film/Film_and_Imaging.html#Film::SampleWavelengths" class="code">SampleWavelengths</a>(lu);</div><p>


</p>
<p>The <a href="../Cameras_and_Film/Camera_Interface.html#CameraSample"><tt>CameraSample</tt></a> can be initialized in the usual way and then it is
on to call <a href="../Cameras_and_Film/Camera_Interface.html#Camera::GenerateRay"><tt>Camera::GenerateRay()</tt></a>.  In this case, this method call is
also resolved using <tt>pbrt</tt>&rsquo;s usual dynamic dispatch system, just as it is in
all the other integrators.  An alternative implementation approach would
be to further specialize the <tt>GenerateCameraRays()</tt> method based on
the type of the <tt>Camera</tt> being used; after all, it is the same for all
pixel samples and so it is somewhat wasteful for all threads to perform the
same computations for dynamic dispatch.  We have found that in practice
that alternative gives a negligible performance benefit, and so our 
implementation here remains based on dynamic dispatch.

</p>
<p>One other thing to note is that the wavefront integrator path generates
regular <a href="../Geometry_and_Transformations/Rays.html#Ray"><tt>Ray</tt></a>s here and not <a href="../Geometry_and_Transformations/Rays.html#RayDifferential"><tt>RayDifferential</tt></a>s.  Approximate
differentials for filtering will be computed later, trading off superior
antialiasing quality in exchange for higher performance from reduced memory
bandwidth due to having less information associated with each ray.  An exercise at the
end of the chapter revisits this choice.

</p>
<p></p>
<span class="anchor" id="fragment-GeneratemonoCameraSampleandcorrespondingray-0"></span><div class="fragmentname">&lt;&lt;Generate <tt>CameraSample</tt> and corresponding ray&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Cameras_and_Film/Camera_Interface.html#CameraSample" class="code">CameraSample</a> cameraSample = <a href="../Sampling_and_Reconstruction/Image_Reconstruction.html#GetCameraSample" class="code">GetCameraSample</a>(pixelSampler, pPixel, filter);
pstd::optional&lt;<a href="../Cameras_and_Film/Camera_Interface.html#CameraRay" class="code">CameraRay</a>&gt; cameraRay =
    <a href="#WavefrontPathIntegrator::camera" class="code">camera</a>.<a href="../Cameras_and_Film/Camera_Interface.html#Camera::GenerateRay" class="code">GenerateRay</a>(cameraSample, lambda);</div><p>


</p>
<p>A few additional values that are stored in <tt>PixelSampleState</tt> can now
be set.  We avoid initializing the heavyweight <a href="../Cameras_and_Film/Film_and_Imaging.html#VisibleSurface"><tt>VisibleSurface</tt></a> member
if it is not going to be used by the <a href="../Cameras_and_Film/Film_and_Imaging.html#Film"><tt>Film</tt></a>; the
<tt>initializeVisibleSurface</tt> member variable is set in the
<a href="#WavefrontPathIntegrator"><tt>WavefrontPathIntegrator</tt></a> constructor to record whether it is needed.
Saving this memory bandwidth when possible is worth this easy check.

</p>
<p></p>
<span class="anchor" id="fragment-InitializeremainderofmonoPixelSampleStateforray-0"></span><div class="fragmentname">&lt;&lt;Initialize remainder of <tt>PixelSampleState</tt> for ray&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">pixelSampleState.<a href="#PixelSampleState::L" class="code">L</a>[pixelIndex] = <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a>(0.f);
pixelSampleState.<a href="#PixelSampleState::lambda" class="code">lambda</a>[pixelIndex] = <a href="#PixelSampleState::lambda" class="code">lambda</a>;
pixelSampleState.<a href="../Cameras_and_Film/Camera_Interface.html#CameraSample::filterWeight" class="code">filterWeight</a>[pixelIndex] = cameraSample.<a href="../Cameras_and_Film/Camera_Interface.html#CameraSample::filterWeight" class="code">filterWeight</a>;
if (initializeVisibleSurface)
    pixelSampleState.<a href="#PixelSampleState::visibleSurface" class="code">visibleSurface</a>[pixelIndex] = <a href="../Cameras_and_Film/Film_and_Imaging.html#VisibleSurface" class="code">VisibleSurface</a>();</div><p>


</p>
<p>Of these member variables, we will see <tt>L</tt> most often in what follows.
It stores the accumulated radiance estimate for the ray path.
After the path terminates, its value will be provided to the <a href="../Cameras_and_Film/Film_and_Imaging.html#Film"><tt>Film</tt></a>.

</p>
<p></p>
<span class="anchor" id="fragment-PixelSampleStatePublicMembers-1"></span><div class="fragmentname">&lt;&lt;PixelSampleState Public Members&gt;&gt;+=&nbsp;<a href="#fragment-PixelSampleStatePublicMembers-0"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-PixelSampleStatePublicMembers-2"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode"><a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <span class="anchor" id="PixelSampleState::L"></span>L;
<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> <span class="anchor" id="PixelSampleState::lambda"></span>lambda;
Float <span class="anchor" id="PixelSampleState::filterWeight"></span>filterWeight;
<a href="../Cameras_and_Film/Film_and_Imaging.html#VisibleSurface" class="code">VisibleSurface</a> <span class="anchor" id="PixelSampleState::visibleSurface"></span>visibleSurface;</div><p>


</p>
<p>If the <a href="../Cameras_and_Film/Camera_Interface.html#Camera"><tt>Camera</tt></a> successfully generated a ray, it is pushed into the
<a href="#RayQueue"><tt>RayQueue</tt></a> along with its wavelengths and associated pixel index, which
allows subsequent kernels to be able to index into
<a href="#WavefrontPathIntegrator::pixelSampleState"><tt>WavefrontPathIntegrator::pixelSampleState</tt></a> to retrieve values there that are
associated with this ray.

</p>
<p></p>
<span class="anchor" id="fragment-Enqueuecamerarayforintersectiontests-0"></span><div class="fragmentname">&lt;&lt;Enqueue camera ray for intersection tests&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">if (cameraRay) {
    rayQueue-&gt;<a href="#RayQueue::PushCameraRay" class="code">PushCameraRay</a>(cameraRay-&gt;<a href="../Cameras_and_Film/Camera_Interface.html#CameraRay::ray" class="code">ray</a>, lambda, pixelIndex);
    pixelSampleState.<a href="#PixelSampleState::cameraRayWeight" class="code">cameraRayWeight</a>[pixelIndex] = cameraRay-&gt;<a href="../Cameras_and_Film/Camera_Interface.html#CameraRay::weight" class="code">weight</a>;
} else
    pixelSampleState.<a href="#PixelSampleState::cameraRayWeight" class="code">cameraRayWeight</a>[pixelIndex] = <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a>(0);</div><p>


</p>
<p></p>
<span class="anchor" id="fragment-PixelSampleStatePublicMembers-2"></span><div class="fragmentname">&lt;&lt;PixelSampleState Public Members&gt;&gt;+=&nbsp;<a href="#fragment-PixelSampleStatePublicMembers-1"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-PixelSampleStatePublicMembers-3"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode"><a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <span class="anchor" id="PixelSampleState::cameraRayWeight"></span>cameraRayWeight;</div><p>


</p>
<p>Some of the work queues provide specialized methods for pushing work on to
them; <tt>RayQueue</tt> is one of them.  It provides a <tt>PushCameraRay()</tt>
method for camera rays and
<tt>PushIndirectRay()</tt> for
scattered rays that sample indirect lighting.  Doing so not only makes the code
where work is pushed on to the queue slightly cleaner, but it also makes it
possible to set some of the forthcoming <a href="#RayWorkItem"><tt>RayWorkItem</tt></a> member variables
to default values for camera rays without needing to specify default values
here.  (For example, <tt>RayWorkItem</tt> carries path sampling PDFs that are
initialized to&nbsp;1 for camera rays.)  We will pass over the implementation of
this method here, as it is all setting member variables,
either from passed-in values or from defaults.

</p>
<p></p>
<span class="anchor" id="fragment-RayQueuePublicMethods-0"></span><div class="fragmentname">&lt;&lt;RayQueue Public Methods&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">int <span class="anchor" id="RayQueue::PushCameraRay"></span>PushCameraRay(const <a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> &amp;ray, const <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> &amp;lambda,
                  int pixelIndex);</div><p>


</p>
<p>We will start the definition of the <tt>RayWorkItem</tt> structure here.

</p>
<p></p>
<span class="anchor" id="fragment-RayWorkItemDefinition-0"></span><div class="fragmentname">&lt;&lt;RayWorkItem Definition&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">struct <span class="anchor" id="RayWorkItem"></span>RayWorkItem {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-RayWorkItemPublicMembers-0">RayWorkItem Public Members</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2463" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2463"><i></i></a><div id="fragbit-2463" class="collapse"><div class="fragmentcode">       <a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> ray;
       int depth;
       <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> lambda;
       int pixelIndex;
       <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> beta, r_u, r_l;
       <a href="../Light_Sources/Light_Interface.html#LightSampleContext" class="code">LightSampleContext</a> prevIntrCtx;
       Float etaScale;
       int specularBounce;
       int anyNonSpecularBounces;</div></div>
};</div><p>


</p>
<p>As would be expected from the parameters passed to <tt>PushCameraRay()</tt>,
<tt>RayWorkItem</tt> stores a ray, its wavelengths, and an index into the
<a href="#WavefrontPathIntegrator"><tt>WavefrontPathIntegrator</tt></a>&rsquo;s
<tt>pixelSampleState</tt>
array from which additional data associated with the ray can be found.

</p>
<p></p>
<span class="anchor" id="fragment-RayWorkItemPublicMembers-0"></span><div class="fragmentname">&lt;&lt;RayWorkItem Public Members&gt;&gt;=&nbsp;<a href="#fragment-RayWorkItemPublicMembers-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode"><a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> <span class="anchor" id="RayWorkItem::ray"></span>ray;
int <span class="anchor" id="RayWorkItem::depth"></span>depth;
<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> <span class="anchor" id="RayWorkItem::lambda"></span>lambda;
int <span class="anchor" id="RayWorkItem::pixelIndex"></span>pixelIndex;</div><p>


</p>
<p>The reader may have noted that <tt>lambda</tt> is both pushed to the ray
queue and stored in the <a href="#PixelSampleState"><tt>PixelSampleState</tt></a>, which is admittedly
redundant, though there are good reasons for both.  Its value must be
stored in the <a href="#PixelSampleState"><tt>PixelSampleState</tt></a> structure, as it is required for
updating the film, which is not scheduled using work queues but via a
loop over the <a href="#PixelSampleState"><tt>PixelSampleState</tt></a> values; see further discussion of this
design in Section&nbsp;<a href="#sec:gpu-film-update">15.3.11</a>.

</p>
<p>However, if other kernels along the way accessed <tt>lambda</tt> via
<a href="#PixelSampleState"><tt>PixelSampleState</tt></a>, performance would be poor, since the initial
correlation between the value of <tt>pixelIndex</tt> and threads in a thread
group quickly becomes shuffled up over the course of rendering.  Thus,
reads from <a href="#PixelSampleState"><tt>PixelSampleState</tt></a> would be highly incoherent.  Because it
is used in just about every kernel, <tt>lambda</tt> is also passed along
throughout the queues of the wavefront integrator.  Since it is in
work queues, the loads and stores to read and save its value are coherent
across the thread group, giving good performance.

</p>
<p>

</p>
<p>

</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#LoopoverRayDepths"><i class="fas fa-link h3h4marginlink"></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span id="LoopoverRayDepths"></span><h3>15.3.4  Loop over Ray Depths</h3><p>
 

</p>
<p>With the camera having seeded the ray queue with an initial set of rays, we
can now turn to the loop that executes once for each successive set of ray
intersection tests and shading calculations up until the maximum ray path
length.  One subtlety is that this loop is over &ldquo;wavefront depth,&rdquo; which
is different than the ray depth that has been tracked in other integrators.
Here, the wavefront depth reflects the number of times that this loop has
executed, tracing a batch of rays and processing their intersections.  Each
ray tracks its own depth, which is usually the same as the wavefront depth,
though the depth of rays that hit invisible surfaces that delineate the
boundaries between volumetric media is not incremented at those
intersections (as in other integrators).

</p>
<p>This loop always runs on the CPU; when the GPU is used for rendering, it is
responsible for launching the appropriate kernels to perform the rendering
computation.  An implication of this design and the decoupling of the CPU
and GPU is that the CPU has no visibility into the state of the ray-tracing
calculations on the GPU.  For example, if all rays terminate after the
first intersection, the CPU will continue submitting kernel launches to
execute the ray-tracing pipeline even though no work is passing through it.
All the kernels would exit immediately, though there would be a cost
from launching all of them and their determining that there is no work to
be done.  For many scenes this is not a problem, but it can harm this
integrator&rsquo;s performance with high maximum ray depths.  An exercise at the
end of the chapter outlines some design alternatives.

</p>
<p></p>
<span class="anchor" id="fragment-Traceraysandestimateradianceuptomaximumraydepth-0"></span><div class="fragmentname">&lt;&lt;Trace rays and estimate radiance up to maximum ray depth&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">for (int wavefrontDepth = 0; true; ++wavefrontDepth) {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Resetqueuesbeforetracingrays-0">Reset queues before tracing rays</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2464" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2464"><i></i></a><div id="fragbit-2464" class="collapse"><div class="fragmentcode">       <a href="#RayQueue" class="code">RayQueue</a> *nextQueue = <a href="#WavefrontPathIntegrator::NextRayQueue" class="code">NextRayQueue</a>(wavefrontDepth);
       <a href="#WavefrontPathIntegrator::Do" class="code">Do</a>("<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#WorkQueue::Reset" class="code">Reset</a> queues before tracing rays",
          PBRT_CPU_GPU_LAMBDA () {
              nextQueue-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#WorkQueue::Reset" class="code">Reset</a>();
              &lt;&lt;<span class="fragmentname"><a href="#fragment-Resetqueuesbeforetracingnextbatchofrays-0">Reset queues before tracing next batch of rays</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2465" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2465"><i></i></a><div id="fragbit-2465" class="collapse"><div class="fragmentcode">                 if (mediumSampleQueue)
                     mediumSampleQueue-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue::Reset" class="code">Reset</a>();
                 if (mediumScatterQueue)
                     mediumScatterQueue-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue::Reset" class="code">Reset</a>();
                 if (<a href="#WavefrontPathIntegrator::escapedRayQueue" class="code">escapedRayQueue</a>) <a href="#WavefrontPathIntegrator::escapedRayQueue" class="code">escapedRayQueue</a>-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue::Reset" class="code">Reset</a>();
                 <a href="#WavefrontPathIntegrator::hitAreaLightQueue" class="code">hitAreaLightQueue</a>-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue::Reset" class="code">Reset</a>();
                 <a href="#WavefrontPathIntegrator::basicEvalMaterialQueue" class="code">basicEvalMaterialQueue</a>-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue::Reset" class="code">Reset</a>();
                 <a href="#WavefrontPathIntegrator::universalEvalMaterialQueue" class="code">universalEvalMaterialQueue</a>-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue::Reset" class="code">Reset</a>();
                 if (bssrdfEvalQueue)
                     bssrdfEvalQueue-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue::Reset" class="code">Reset</a>();
                 if (subsurfaceScatterQueue)
                     subsurfaceScatterQueue-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue::Reset" class="code">Reset</a>();</div></div>
          });</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Followactiveraypathsandaccumulateradianceestimates-0">Follow active ray paths and accumulate radiance estimates</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2466" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2466"><i></i></a><div id="fragbit-2466" class="collapse"><div class="fragmentcode">       <a href="#WavefrontPathIntegrator::GenerateRaySamples" class="code">GenerateRaySamples</a>(wavefrontDepth, sampleIndex);
       &lt;&lt;<span class="fragmentname"><a href="#fragment-Findclosestintersectionsalongactiverays-0">Find closest intersections along active rays</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2467" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2467"><i></i></a><div id="fragbit-2467" class="collapse"><div class="fragmentcode">          <a href="#WavefrontPathIntegrator::aggregate" class="code">aggregate</a>-&gt;<a href="#WavefrontAggregate::IntersectClosest" class="code">IntersectClosest</a>(<a href="#WavefrontPathIntegrator::maxQueueSize" class="code">maxQueueSize</a>, <a href="#WavefrontPathIntegrator::CurrentRayQueue" class="code">CurrentRayQueue</a>(wavefrontDepth),
              <a href="#WavefrontPathIntegrator::escapedRayQueue" class="code">escapedRayQueue</a>, <a href="#WavefrontPathIntegrator::hitAreaLightQueue" class="code">hitAreaLightQueue</a>, <a href="#WavefrontPathIntegrator::basicEvalMaterialQueue" class="code">basicEvalMaterialQueue</a>,
              <a href="#WavefrontPathIntegrator::universalEvalMaterialQueue" class="code">universalEvalMaterialQueue</a>, <a href="#WavefrontPathIntegrator::mediumSampleQueue" class="code">mediumSampleQueue</a>,
              <a href="#WavefrontPathIntegrator::NextRayQueue" class="code">NextRayQueue</a>(wavefrontDepth));</div></div>
       <a href="#WavefrontPathIntegrator::SampleMediumInteraction" class="code">SampleMediumInteraction</a>(wavefrontDepth);
       <a href="#WavefrontPathIntegrator::HandleEscapedRays" class="code">HandleEscapedRays</a>();
       <a href="#WavefrontPathIntegrator::HandleEmissiveIntersection" class="code">HandleEmissiveIntersection</a>();
       if (wavefrontDepth == <a href="#WavefrontPathIntegrator::maxDepth" class="code">maxDepth</a>)
           break;
       <a href="#WavefrontPathIntegrator::EvaluateMaterialsAndBSDFs" class="code">EvaluateMaterialsAndBSDFs</a>(wavefrontDepth);
       <a href="#WavefrontPathIntegrator::TraceShadowRays" class="code">TraceShadowRays</a>(wavefrontDepth);
       SampleSubsurface(wavefrontDepth);</div></div>
}</div><p>


</p>
<p>All the work queues except for the <a href="#RayQueue"><tt>RayQueue</tt></a> holding the current
set of rays must be cleared at the start of each iteration.  The following
fragment clears the <a href="#RayQueue"><tt>RayQueue</tt></a> for the next set of indirect rays and
adds a fragment for the rest of the queues.  We will add additional
<tt>Reset()</tt> calls to this fragment for the various other queues along
with the code that defines and uses them.

</p>
<p></p>
<span class="anchor" id="fragment-Resetqueuesbeforetracingrays-0"></span><div class="fragmentname">&lt;&lt;Reset queues before tracing rays&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="#RayQueue" class="code">RayQueue</a> *nextQueue = <a href="#WavefrontPathIntegrator::NextRayQueue" class="code">NextRayQueue</a>(wavefrontDepth);
<a href="#WavefrontPathIntegrator::Do" class="code">Do</a>("<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#WorkQueue::Reset" class="code">Reset</a> queues before tracing rays",
   PBRT_CPU_GPU_LAMBDA () {
       nextQueue-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#WorkQueue::Reset" class="code">Reset</a>();
       &lt;&lt;<span class="fragmentname"><a href="#fragment-Resetqueuesbeforetracingnextbatchofrays-0">Reset queues before tracing next batch of rays</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2468" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2468"><i></i></a><div id="fragbit-2468" class="collapse"><div class="fragmentcode">          if (mediumSampleQueue)
              mediumSampleQueue-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue::Reset" class="code">Reset</a>();
          if (mediumScatterQueue)
              mediumScatterQueue-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue::Reset" class="code">Reset</a>();
          if (<a href="#WavefrontPathIntegrator::escapedRayQueue" class="code">escapedRayQueue</a>) <a href="#WavefrontPathIntegrator::escapedRayQueue" class="code">escapedRayQueue</a>-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue::Reset" class="code">Reset</a>();
          <a href="#WavefrontPathIntegrator::hitAreaLightQueue" class="code">hitAreaLightQueue</a>-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue::Reset" class="code">Reset</a>();
          <a href="#WavefrontPathIntegrator::basicEvalMaterialQueue" class="code">basicEvalMaterialQueue</a>-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue::Reset" class="code">Reset</a>();
          <a href="#WavefrontPathIntegrator::universalEvalMaterialQueue" class="code">universalEvalMaterialQueue</a>-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue::Reset" class="code">Reset</a>();
          if (bssrdfEvalQueue)
              bssrdfEvalQueue-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue::Reset" class="code">Reset</a>();
          if (subsurfaceScatterQueue)
              subsurfaceScatterQueue-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue::Reset" class="code">Reset</a>();</div></div>
   });</div><p>


</p>
<p>Once the queues are cleared, rendering proceeds mostly following the same
steps as the <a href="../Light_Transport_II_Volume_Rendering/Volume_Scattering_Integrators.html#VolPathIntegrator"><tt>VolPathIntegrator</tt></a>.  First, the <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler"><tt>Sampler</tt></a> computes
sample values for all of the rays and stores them in memory.

</p>
<p></p>
<span class="anchor" id="fragment-Followactiveraypathsandaccumulateradianceestimates-0"></span><div class="fragmentname">&lt;&lt;Follow active ray paths and accumulate radiance estimates&gt;&gt;=&nbsp;<a href="#fragment-Followactiveraypathsandaccumulateradianceestimates-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode"><a href="#WavefrontPathIntegrator::GenerateRaySamples" class="code">GenerateRaySamples</a>(wavefrontDepth, sampleIndex);</div><p>


</p>
<p>The closest intersection with a surface, if any, is then found for each
ray.

</p>
<p></p>
<span class="anchor" id="fragment-Followactiveraypathsandaccumulateradianceestimates-1"></span><div class="fragmentname">&lt;&lt;Follow active ray paths and accumulate radiance estimates&gt;&gt;+=&nbsp;<a href="#fragment-Followactiveraypathsandaccumulateradianceestimates-0"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-Followactiveraypathsandaccumulateradianceestimates-2"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">&lt;&lt;<span class="fragmentname"><a href="#fragment-Findclosestintersectionsalongactiverays-0">Find closest intersections along active rays</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2469" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2469"><i></i></a><div id="fragbit-2469" class="collapse"><div class="fragmentcode">   <a href="#WavefrontPathIntegrator::aggregate" class="code">aggregate</a>-&gt;<a href="#WavefrontAggregate::IntersectClosest" class="code">IntersectClosest</a>(<a href="#WavefrontPathIntegrator::maxQueueSize" class="code">maxQueueSize</a>, <a href="#WavefrontPathIntegrator::CurrentRayQueue" class="code">CurrentRayQueue</a>(wavefrontDepth),
       <a href="#WavefrontPathIntegrator::escapedRayQueue" class="code">escapedRayQueue</a>, <a href="#WavefrontPathIntegrator::hitAreaLightQueue" class="code">hitAreaLightQueue</a>, <a href="#WavefrontPathIntegrator::basicEvalMaterialQueue" class="code">basicEvalMaterialQueue</a>,
       <a href="#WavefrontPathIntegrator::universalEvalMaterialQueue" class="code">universalEvalMaterialQueue</a>, <a href="#WavefrontPathIntegrator::mediumSampleQueue" class="code">mediumSampleQueue</a>,
       <a href="#WavefrontPathIntegrator::NextRayQueue" class="code">NextRayQueue</a>(wavefrontDepth));</div></div>
</div><p>


</p>
<p>Before surface scattering or emission is considered, the medium (if any) is
sampled.  If the medium scatters or absorbs the ray, then any surface
intersection will be ignored.

</p>
<p></p>
<span class="anchor" id="fragment-Followactiveraypathsandaccumulateradianceestimates-2"></span><div class="fragmentname">&lt;&lt;Follow active ray paths and accumulate radiance estimates&gt;&gt;+=&nbsp;<a href="#fragment-Followactiveraypathsandaccumulateradianceestimates-1"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-Followactiveraypathsandaccumulateradianceestimates-3"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode"><a href="#WavefrontPathIntegrator::SampleMediumInteraction" class="code">SampleMediumInteraction</a>(wavefrontDepth);</div><p>


</p>
<p>Only after medium sampling are rays that left the scene taken care
of.  In this way, rays passing through participating media that do not
interact with it and then leave the scene can be processed at the same time
as rays that left the scene but did not pass through media.

</p>
<p></p>
<span class="anchor" id="fragment-Followactiveraypathsandaccumulateradianceestimates-3"></span><div class="fragmentname">&lt;&lt;Follow active ray paths and accumulate radiance estimates&gt;&gt;+=&nbsp;<a href="#fragment-Followactiveraypathsandaccumulateradianceestimates-2"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-Followactiveraypathsandaccumulateradianceestimates-4"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode"><a href="#WavefrontPathIntegrator::HandleEscapedRays" class="code">HandleEscapedRays</a>();</div><p>


</p>
<p>The contribution of emissive surfaces to a sample&rsquo;s radiance value is also
only added after medium sampling, since it should not be included if the
medium scattered or absorbed the ray.

</p>
<p></p>
<span class="anchor" id="fragment-Followactiveraypathsandaccumulateradianceestimates-4"></span><div class="fragmentname">&lt;&lt;Follow active ray paths and accumulate radiance estimates&gt;&gt;+=&nbsp;<a href="#fragment-Followactiveraypathsandaccumulateradianceestimates-3"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-Followactiveraypathsandaccumulateradianceestimates-5"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode"><a href="#WavefrontPathIntegrator::HandleEmissiveIntersection" class="code">HandleEmissiveIntersection</a>();</div><p>


</p>
<p>The loop over wavefront depth can only be terminated after emissive
surfaces have been accounted for, since the MIS-based direct lighting
calculation accounts for their contribution.

</p>
<p></p>
<span class="anchor" id="fragment-Followactiveraypathsandaccumulateradianceestimates-5"></span><div class="fragmentname">&lt;&lt;Follow active ray paths and accumulate radiance estimates&gt;&gt;+=&nbsp;<a href="#fragment-Followactiveraypathsandaccumulateradianceestimates-4"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-Followactiveraypathsandaccumulateradianceestimates-6"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">if (wavefrontDepth == <a href="#WavefrontPathIntegrator::maxDepth" class="code">maxDepth</a>)
    break;</div><p>


</p>
<p>If the loop does not terminate, only now are surface intersections handled,
with the <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#Material"><tt>Material</tt></a>s evaluating their textures and returning
<a href="../Reflection_Models/BSDF_Representation.html#BSDF"><tt>BSDF</tt></a>s, lights sampled, and
indirect rays enqueued.

</p>
<p></p>
<span class="anchor" id="fragment-Followactiveraypathsandaccumulateradianceestimates-6"></span><div class="fragmentname">&lt;&lt;Follow active ray paths and accumulate radiance estimates&gt;&gt;+=&nbsp;<a href="#fragment-Followactiveraypathsandaccumulateradianceestimates-5"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-Followactiveraypathsandaccumulateradianceestimates-7"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode"><a href="#WavefrontPathIntegrator::EvaluateMaterialsAndBSDFs" class="code">EvaluateMaterialsAndBSDFs</a>(wavefrontDepth);</div><p>


</p>
<p>Next, the shadow rays enqueued by the material evaluation kernel are
traced; the radiance contributions of the unoccluded ones are accumulated
in <a href="#PixelSampleState"><tt>PixelSampleState</tt></a>.

</p>
<p></p>
<span class="anchor" id="fragment-Followactiveraypathsandaccumulateradianceestimates-7"></span><div class="fragmentname">&lt;&lt;Follow active ray paths and accumulate radiance estimates&gt;&gt;+=&nbsp;<a href="#fragment-Followactiveraypathsandaccumulateradianceestimates-6"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode"><a href="#WavefrontPathIntegrator::TraceShadowRays" class="code">TraceShadowRays</a>(wavefrontDepth);</div><p>


</p>
<p>

</p>
<p>The following sections go into these steps in more detail.

</p>
<p>

</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#SampleGeneration"><i class="fas fa-link h3h4marginlink"></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span id="SampleGeneration"></span><h3>15.3.5  Sample Generation</h3><p>


</p>
<p>The first step in each loop iteration is to generate values for all the sample
dimensions that may be required for sampling lighting if a scattering event
is found along the ray, either in a participating medium or on a surface.
Generating all of these samples ahead of time in a separate kernel allows
for specializing that kernel based on the sampler type, giving the same
performance benefits as were found in <tt>GenerateCameraRays()</tt>.

</p>
<p>The <tt>GenerateRaySamples()</tt> method is defined in the file
<a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/wavefront/samples.cpp"><tt>wavefront/samples.cpp</tt></a>.  Similar to camera rays, there is an initial
<tt>GenerateRaySamples()</tt> method called in the main rendering
loop that determines the actual <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler"><tt>Sampler</tt></a> type and invokes the
appropriate specialization.  Because this dispatch method is nearly the
same as the analog in <tt>GenerateCameraRays()</tt>, we omit it here and turn
directly to the specialized method.

</p>
<p>

</p>
<p></p>
<span class="anchor" id="fragment-WavefrontPathIntegratorSamplerMethods-0"></span><div class="fragmentname">&lt;&lt;WavefrontPathIntegrator Sampler Methods&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">template &lt;typename ConcreteSampler&gt;
void <span class="anchor" id="WavefrontPathIntegrator::GenerateRaySamples"></span>WavefrontPathIntegrator::GenerateRaySamples(int wavefrontDepth,
                                                 int sampleIndex) {
    &lt;&lt;<span class="fragmentname">Generate description string <tt>desc</tt> for ray sample generation</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2470" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2470"><i></i></a><div id="fragbit-2470" class="collapse"><div class="fragmentcode">       std::string desc = std::string("Generate ray samples - ") + ConcreteSampler::Name();</div></div>
    <a href="#RayQueue" class="code">RayQueue</a> *rayQueue = <a href="#WavefrontPathIntegrator::CurrentRayQueue" class="code">CurrentRayQueue</a>(wavefrontDepth);
    <a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#ForAllQueued" class="code">ForAllQueued</a>(desc.c_str(), rayQueue, maxQueueSize,
        PBRT_CPU_GPU_LAMBDA (const RayWorkItem w) {
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Generatesamplesforraysegmentatcurrentsampleindex-0">Generate samples for ray segment at current sample index</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2471" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2471"><i></i></a><div id="fragbit-2471" class="collapse"><div class="fragmentcode">              &lt;&lt;<span class="fragmentname"><a href="#fragment-Findfirstsampledimension-0">Find first sample dimension</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2472" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2472"><i></i></a><div id="fragbit-2472" class="collapse"><div class="fragmentcode">                 int dimension = 6 + 7 * w.<a href="#RayWorkItem::depth" class="code">depth</a>;
                 if (haveMedia)
                     dimension += 2 * w.<a href="#RayWorkItem::depth" class="code">depth</a>;</div></div>
              &lt;&lt;<span class="fragmentname"><a href="#fragment-InitializemonoSamplerforpixelsampleindexanddimension-0">Initialize <tt>Sampler</tt> for pixel, sample index, and dimension</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2473" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2473"><i></i></a><div id="fragbit-2473" class="collapse"><div class="fragmentcode">                 ConcreteSampler pixelSampler = *sampler.<a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer::Cast" class="code">Cast</a>&lt;ConcreteSampler&gt;();
                 <a href="../Geometry_and_Transformations/Points.html#Point2i" class="code">Point2i</a> <a href="#PixelSampleState::pPixel" class="code">pPixel</a> = <a href="#WavefrontPathIntegrator::pixelSampleState" class="code">pixelSampleState</a>.<a href="#PixelSampleState::pPixel" class="code">pPixel</a>[w.<a href="#RayWorkItem::pixelIndex" class="code">pixelIndex</a>];
                 pixelSampler.<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::StartPixelSample" class="code">StartPixelSample</a>(<a href="#PixelSampleState::pPixel" class="code">pPixel</a>, sampleIndex, dimension);</div></div>
              &lt;&lt;<span class="fragmentname"><a href="#fragment-InitializemonoRaySamplesstructurewithsamplevalues-0">Initialize <tt>RaySamples</tt> structure with sample values</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2474" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2474"><i></i></a><div id="fragbit-2474" class="collapse"><div class="fragmentcode">                 RaySamples rs;
                 rs.<a href="#RaySamples::direct" class="code">direct</a>.<a href="#RaySamples::direct::uc" class="code">uc</a> = pixelSampler.<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::Get1D" class="code">Get1D</a>();
                 rs.<a href="#RaySamples::direct" class="code">direct</a>.<a href="#RaySamples::direct::u" class="code">u</a> = pixelSampler.<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::Get2D" class="code">Get2D</a>();
                 &lt;&lt;<span class="fragmentname">Initialize remaining samples in <tt>rs</tt></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2475" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2475"><i></i></a><div id="fragbit-2475" class="collapse"><div class="fragmentcode">                    rs.indirect.uc = pixelSampler.Get1D();
                    rs.indirect.u = pixelSampler.Get2D();
                    rs.indirect.rr = pixelSampler.Get1D();
                    rs.haveMedia = haveMedia;
                    if (haveMedia) {
                        rs.media.uDist = pixelSampler.Get1D();
                        rs.media.uMode = pixelSampler.Get1D();
                    }</div></div></div></div>
              &lt;&lt;<span class="fragmentname"><a href="#fragment-StoremonoRaySamplesinpixelsamplestate-0">Store <tt>RaySamples</tt> in pixel sample state</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2476" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2476"><i></i></a><div id="fragbit-2476" class="collapse"><div class="fragmentcode">                 <a href="#WavefrontPathIntegrator::pixelSampleState" class="code">pixelSampleState</a>.<a href="#PixelSampleState::samples" class="code">samples</a>[w.<a href="#RayWorkItem::pixelIndex" class="code">pixelIndex</a>] = rs;</div></div></div></div>
   });
}</div><p>


</p>
<p>

</p>
<p>Unlike the CPU-only integrators, where sample dimensions are allocated
implicitly based on the runtime sequence of <tt>Get1D()</tt> and
<tt>Get2D()</tt> method calls, here dimensions are explicitly allocated,
ensuring that unique dimensions are assigned to different uses of samples.
Doing so imposes a coupling between this kernel and the use of samples in
following ones and also means that samples may be generated that are not
actually used (e.g., if a perfect specular surface is intersected).
These costs are worth paying in return for the performance benefits of
generating samples in a specialized kernel.

</p>
<p></p>
<span class="anchor" id="fragment-Generatesamplesforraysegmentatcurrentsampleindex-0"></span><div class="fragmentname">&lt;&lt;Generate samples for ray segment at current sample index&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">&lt;&lt;<span class="fragmentname"><a href="#fragment-Findfirstsampledimension-0">Find first sample dimension</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2477" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2477"><i></i></a><div id="fragbit-2477" class="collapse"><div class="fragmentcode">   int dimension = 6 + 7 * w.<a href="#RayWorkItem::depth" class="code">depth</a>;
   if (haveMedia)
       dimension += 2 * w.<a href="#RayWorkItem::depth" class="code">depth</a>;</div></div>
&lt;&lt;<span class="fragmentname"><a href="#fragment-InitializemonoSamplerforpixelsampleindexanddimension-0">Initialize <tt>Sampler</tt> for pixel, sample index, and dimension</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2478" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2478"><i></i></a><div id="fragbit-2478" class="collapse"><div class="fragmentcode">   ConcreteSampler pixelSampler = *sampler.<a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer::Cast" class="code">Cast</a>&lt;ConcreteSampler&gt;();
   <a href="../Geometry_and_Transformations/Points.html#Point2i" class="code">Point2i</a> <a href="#PixelSampleState::pPixel" class="code">pPixel</a> = <a href="#WavefrontPathIntegrator::pixelSampleState" class="code">pixelSampleState</a>.<a href="#PixelSampleState::pPixel" class="code">pPixel</a>[w.<a href="#RayWorkItem::pixelIndex" class="code">pixelIndex</a>];
   pixelSampler.<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::StartPixelSample" class="code">StartPixelSample</a>(<a href="#PixelSampleState::pPixel" class="code">pPixel</a>, sampleIndex, dimension);</div></div>
&lt;&lt;<span class="fragmentname"><a href="#fragment-InitializemonoRaySamplesstructurewithsamplevalues-0">Initialize <tt>RaySamples</tt> structure with sample values</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2479" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2479"><i></i></a><div id="fragbit-2479" class="collapse"><div class="fragmentcode">   RaySamples rs;
   rs.<a href="#RaySamples::direct" class="code">direct</a>.<a href="#RaySamples::direct::uc" class="code">uc</a> = pixelSampler.<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::Get1D" class="code">Get1D</a>();
   rs.<a href="#RaySamples::direct" class="code">direct</a>.<a href="#RaySamples::direct::u" class="code">u</a> = pixelSampler.<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::Get2D" class="code">Get2D</a>();
   &lt;&lt;<span class="fragmentname">Initialize remaining samples in <tt>rs</tt></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2480" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2480"><i></i></a><div id="fragbit-2480" class="collapse"><div class="fragmentcode">      rs.indirect.uc = pixelSampler.Get1D();
      rs.indirect.u = pixelSampler.Get2D();
      rs.indirect.rr = pixelSampler.Get1D();
      rs.haveMedia = haveMedia;
      if (haveMedia) {
          rs.media.uDist = pixelSampler.Get1D();
          rs.media.uMode = pixelSampler.Get1D();
      }</div></div></div></div>
&lt;&lt;<span class="fragmentname"><a href="#fragment-StoremonoRaySamplesinpixelsamplestate-0">Store <tt>RaySamples</tt> in pixel sample state</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2481" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2481"><i></i></a><div id="fragbit-2481" class="collapse"><div class="fragmentcode">   <a href="#WavefrontPathIntegrator::pixelSampleState" class="code">pixelSampleState</a>.<a href="#PixelSampleState::samples" class="code">samples</a>[w.<a href="#RayWorkItem::pixelIndex" class="code">pixelIndex</a>] = rs;</div></div></div><p>


</p>
<p>The first task is to find the first dimension to allocate for this ray&rsquo;s
samples.  The first 5&nbsp;sample dimensions are used to generate the camera
ray, and then 1&nbsp;is used to sample the wavelengths.  At least 7&nbsp;samples are
needed for each ray depth: 3&nbsp;for the call to <a href="../Reflection_Models/BSDF_Representation.html#BSDF::Sample_f"><tt>BSDF::Sample_f()</tt></a>, 1&nbsp;to
sample a light source and then 2&nbsp;to sample a position on it, and then
1&nbsp;more for Russian roulette for the indirect ray.

Two additional dimensions are consumed for sampling participating media.

(The <tt>haveMedia</tt> <tt>WavefrontPathIntegrator</tt>
member variable is


set in its constructor based on the scene.)

</p>
<p></p>
<span class="anchor" id="fragment-Findfirstsampledimension-0"></span><div class="fragmentname">&lt;&lt;Find first sample dimension&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">int dimension = 6 + 7 * w.<a href="#RayWorkItem::depth" class="code">depth</a>;
if (haveMedia)
    dimension += 2 * w.<a href="#RayWorkItem::depth" class="code">depth</a>;</div><p>


</p>
<p>This kernel uses the same trick to get a stack-allocated <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler"><tt>Sampler</tt></a> as
was done for camera rays.  In this case, figuring out which pixel the ray
is associated with requires a read from the <a href="#PixelSampleState"><tt>PixelSampleState</tt></a>.

</p>
<p></p>
<span class="anchor" id="fragment-InitializemonoSamplerforpixelsampleindexanddimension-0"></span><div class="fragmentname">&lt;&lt;Initialize <tt>Sampler</tt> for pixel, sample index, and dimension&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">ConcreteSampler pixelSampler = *sampler.<a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer::Cast" class="code">Cast</a>&lt;ConcreteSampler&gt;();
<a href="../Geometry_and_Transformations/Points.html#Point2i" class="code">Point2i</a> <a href="#PixelSampleState::pPixel" class="code">pPixel</a> = <a href="#WavefrontPathIntegrator::pixelSampleState" class="code">pixelSampleState</a>.<a href="#PixelSampleState::pPixel" class="code">pPixel</a>[w.<a href="#RayWorkItem::pixelIndex" class="code">pixelIndex</a>];
pixelSampler.<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::StartPixelSample" class="code">StartPixelSample</a>(<a href="#PixelSampleState::pPixel" class="code">pPixel</a>, sampleIndex, dimension);</div><p>


</p>
<p>The <tt>RaySamples</tt> structure bundles up the samples needed for a ray.  A
series of <tt>Get1D()</tt> and <tt>Get2D()</tt> calls initializes its member
variables.  We omit the fragment that initializes the indirect


as it is more of the same.  We
have carefully ordered the sample generation method calls below to match
their use in the <a href="../Light_Transport_II_Volume_Rendering/Volume_Scattering_Integrators.html#VolPathIntegrator"><tt>VolPathIntegrator</tt></a> so that the two integrators use
the same sample values for their sampling tasks at each pixel sample.

</p>
<p></p>
<span class="anchor" id="fragment-InitializemonoRaySamplesstructurewithsamplevalues-0"></span><div class="fragmentname">&lt;&lt;Initialize <tt>RaySamples</tt> structure with sample values&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">RaySamples rs;
rs.<a href="#RaySamples::direct" class="code">direct</a>.<a href="#RaySamples::direct::uc" class="code">uc</a> = pixelSampler.<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::Get1D" class="code">Get1D</a>();
rs.<a href="#RaySamples::direct" class="code">direct</a>.<a href="#RaySamples::direct::u" class="code">u</a> = pixelSampler.<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::Get2D" class="code">Get2D</a>();
&lt;&lt;<span class="fragmentname">Initialize remaining samples in <tt>rs</tt></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2482" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2482"><i></i></a><div id="fragbit-2482" class="collapse"><div class="fragmentcode">   rs.indirect.uc = pixelSampler.Get1D();
   rs.indirect.u = pixelSampler.Get2D();
   rs.indirect.rr = pixelSampler.Get1D();
   rs.haveMedia = haveMedia;
   if (haveMedia) {
       rs.media.uDist = pixelSampler.Get1D();
       rs.media.uMode = pixelSampler.Get1D();
   }</div></div></div><p>


</p>
<p>

</p>
<p></p>
<span class="anchor" id="fragment-RaySamplesDefinition-0"></span><div class="fragmentname">&lt;&lt;RaySamples Definition&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">struct <span class="anchor" id="RaySamples"></span>RaySamples {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-RaySamplesPublicMembers-0">RaySamples Public Members</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2483" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2483"><i></i></a><div id="fragbit-2483" class="collapse"><div class="fragmentcode">       struct {
           <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a> u;
           Float uc;
       } direct;
       struct {
           Float uc, rr;
           <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a> u;
       } indirect;
       bool haveSubsurface;
       struct {
           Float uc;
           <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a> u;
       } subsurface;
       bool haveMedia;
       struct {
           Float uDist, uMode;
       } media;</div></div>
};</div><p>


</p>
<p>The three sample dimensions for sampling the light source are available in
the <tt>direct</tt> substructure.

</p>
<p></p>
<span class="anchor" id="fragment-RaySamplesPublicMembers-0"></span><div class="fragmentname">&lt;&lt;RaySamples Public Members&gt;&gt;=&nbsp;<a href="#fragment-RaySamplesPublicMembers-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">struct {
    <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a> <span class="anchor" id="RaySamples::direct::u"></span>u;
    Float <span class="anchor" id="RaySamples::direct::uc"></span>uc;
} <span class="anchor" id="RaySamples::direct"></span>direct;</div><p>


</p>
<p>Similarly, the dimensions for BSDF sampling and Russian roulette are
available in <tt>indirect</tt>.

</p>
<p></p>
<span class="anchor" id="fragment-RaySamplesPublicMembers-1"></span><div class="fragmentname">&lt;&lt;RaySamples Public Members&gt;&gt;+=&nbsp;<a href="#fragment-RaySamplesPublicMembers-0"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-RaySamplesPublicMembers-2"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">struct {
    Float <span class="anchor" id="RaySamples::indirect::uc"></span>uc, <span class="anchor" id="RaySamples::indirect::rr"></span>rr;
    <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a> <span class="anchor" id="RaySamples::indirect::u"></span>u;
} <span class="anchor" id="RaySamples::indirect"></span>indirect;</div><p>


</p>
<p>

</p>
<p><tt>haveMedia</tt> indicates whether medium samples have been stored, which makes
it possible to save bandwidth when they are unset.

</p>
<p></p>
<span class="anchor" id="fragment-RaySamplesPublicMembers-2"></span><div class="fragmentname">&lt;&lt;RaySamples Public Members&gt;&gt;+=&nbsp;<a href="#fragment-RaySamplesPublicMembers-1"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode">bool <span class="anchor" id="RaySamples::haveMedia"></span>haveMedia;
struct {
    Float <span class="anchor" id="RaySamples::media::uDist"></span>uDist, <span class="anchor" id="RaySamples::media::uMode"></span>uMode;
} <span class="anchor" id="RaySamples::media"></span>media;</div><p>

 
Sample values are squirreled away in <a href="#PixelSampleState"><tt>PixelSampleState</tt></a> rather than
being passed along via work queues.  This does mean that both storing sample
values here and reading them in subsequent kernels is not done with
coherent memory accesses, since a thread group&rsquo;s <tt>pixelIndex</tt> values
will not necessarily be contiguous after the initial camera rays.  However,
because they are not used in many kernels, passing them along through work
queues would entail multiple instances of reading them from one queue just
to write them to another, which would be a waste of bandwidth.  We have found
that the current approach gives marginally better performance in practice.

</p>
<p></p>
<span class="anchor" id="fragment-StoremonoRaySamplesinpixelsamplestate-0"></span><div class="fragmentname">&lt;&lt;Store <tt>RaySamples</tt> in pixel sample state&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="#WavefrontPathIntegrator::pixelSampleState" class="code">pixelSampleState</a>.<a href="#PixelSampleState::samples" class="code">samples</a>[w.<a href="#RayWorkItem::pixelIndex" class="code">pixelIndex</a>] = rs;</div><p>


</p>
<p></p>
<span class="anchor" id="fragment-PixelSampleStatePublicMembers-3"></span><div class="fragmentname">&lt;&lt;PixelSampleState Public Members&gt;&gt;+=&nbsp;<a href="#fragment-PixelSampleStatePublicMembers-2"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode">RaySamples <span class="anchor" id="PixelSampleState::samples"></span>samples;</div><p>


</p>
<p>One shortcoming of the approach implemented in this section is that samples
are still generated for rays that do not intersect anything.  A more
optimized implementation might try to defer sample generation until the
specific samples required were known, though the benefits are likely to be
marginal: on the GPU, if the samples needed vary over the rays in a thread
group, then&mdash;given the GPU&rsquo;s thread group execution model&mdash;there may be no
savings from skipping the work for some threads if it is still needed by
others.  Further, sample generation is normally just a few percent of
overall rendering time, and so anything more sophisticated is not worth bothering
with, at least for <tt>pbrt</tt>&rsquo;s requirements.

</p>
<p>

</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#IntersectionTesting"><i class="fas fa-link h3h4marginlink"></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span class="anchor" id="sec:gpu-intersection-testing"></span><span id="IntersectionTesting"></span><h3>15.3.6  Intersection Testing</h3><p>



</p>
<p>Ray intersections are handled differently depending on whether the wavefront
integrator is running on the CPU or the GPU.  On the CPU, the ray
queues are consumed using <a href="../Utilities/Parallelism.html#ParallelFor"><tt>ParallelFor()</tt></a> calls and <tt>pbrt</tt>&rsquo;s regular
acceleration structures from Chapter&nbsp;<a href="../Primitives_and_Intersection_Acceleration.html#chap:acceleration">7</a> are used to find
intersections.  On the GPU, platform-specific functionality is used to do
so.  In order to abstract the differences between these approaches (and to
make it easier to add support for additional GPU architectures), ray
intersection work done by the <a href="#WavefrontPathIntegrator"><tt>WavefrontPathIntegrator</tt></a> is handled by
an implementation of the <a href="#WavefrontAggregate"><tt>WavefrontAggregate</tt></a> class, which defines an
interface that reflects the integrator&rsquo;s needs.

</p>
<p></p>
<span class="anchor" id="fragment-WavefrontAggregateDefinition-0"></span><div class="fragmentname">&lt;&lt;WavefrontAggregate Definition&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">class <span class="anchor" id="WavefrontAggregate"></span>WavefrontAggregate {
public:
    &lt;&lt;<span class="fragmentname"><a href="#fragment-WavefrontAggregateInterface-0">WavefrontAggregate Interface</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2484" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2484"><i></i></a><div id="fragbit-2484" class="collapse"><div class="fragmentcode">       virtual ~WavefrontAggregate() = default;
       virtual <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> Bounds() const = 0;
       virtual void IntersectClosest(int maxRays, const RayQueue *rayQ,
           EscapedRayQueue *escapedRayQ, HitAreaLightQueue *hitAreaLightQ,
           MaterialEvalQueue *basicMtlQ, MaterialEvalQueue *universalMtlQ,
           MediumSampleQueue *mediumSampleQ, RayQueue *nextRayQ) const = 0;
       virtual void IntersectShadow(int maxRays, ShadowRayQueue *shadowRayQueue,
           SOA&lt;<a href="#PixelSampleState" class="code">PixelSampleState</a>&gt; *pixelSampleState) const = 0;
       virtual void IntersectShadowTr(int maxRays, ShadowRayQueue *shadowRayQueue,
           SOA&lt;<a href="#PixelSampleState" class="code">PixelSampleState</a>&gt; *pixelSampleState) const = 0;
       virtual void IntersectOneRandom(int maxRays,
           SubsurfaceScatterQueue *subsurfaceScatterQueue) const = 0;</div></div>
};</div><p>


</p>
<p>The <tt>WavefrontPathIntegrator</tt> stores a <tt>WavefrontAggregate</tt> in
its <tt>aggregate</tt> member variable.  The CPU implementation,
<tt>CPUAggregate</tt><span class="anchor" id="CPUAggregate"></span>, is found in the source files
<a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/[EntityList: wavefront/cmd: -:
aggregate.h]"><tt>[EntityList: wavefront/cmd: -:
aggregate.h]</tt></a> and
<a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/wavefront/aggregate.cpp"><tt>wavefront/aggregate.cpp</tt></a>.  The implementation for NVIDIA
GPUs,
<tt>OptiXAggregate</tt><span class="anchor" id="OptiXAggregate"></span>, is found in
<a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/gpu/aggregate.h"><tt>gpu/aggregate.h</tt></a> and <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/gpu/aggregate.cpp"><tt>gpu/aggregate.cpp</tt></a>.

</p>
<p></p>
<span class="anchor" id="fragment-WavefrontPathIntegratorMemberVariables-6"></span><div class="fragmentname">&lt;&lt;WavefrontPathIntegrator Member Variables&gt;&gt;+=&nbsp;<a href="#fragment-WavefrontPathIntegratorMemberVariables-5"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-WavefrontPathIntegratorMemberVariables-7"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">WavefrontAggregate *<span class="anchor" id="WavefrontPathIntegrator::aggregate"></span>aggregate = nullptr;</div><p>


</p>
<p>

</p>
<p>All <tt>WavefrontAggregate</tt>s must provide a method that returns the
bounds of the entire scene.

</p>
<p></p>
<span class="anchor" id="fragment-WavefrontAggregateInterface-0"></span><div class="fragmentname">&lt;&lt;WavefrontAggregate Interface&gt;&gt;=&nbsp;<a href="#fragment-WavefrontAggregateInterface-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">virtual <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> <span class="anchor" id="WavefrontAggregate::Bounds"></span>Bounds() const = 0;</div><p>


</p>
<p><tt>IntersectClosest()</tt> traces a set of rays and finds their closest
surface intersections.  Beyond the queue that provides the rays to be
traced, a number of additional queues must be provided to it.  Further work
for a ray may be added to multiple queues depending on the specifics of its
surface intersection.

</p>
<p></p>
<span class="anchor" id="fragment-WavefrontAggregateInterface-1"></span><div class="fragmentname">&lt;&lt;WavefrontAggregate Interface&gt;&gt;+=&nbsp;<a href="#fragment-WavefrontAggregateInterface-0"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-WavefrontAggregateInterface-2"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">virtual void <span class="anchor" id="WavefrontAggregate::IntersectClosest"></span>IntersectClosest(int maxRays, const RayQueue *rayQ,
    EscapedRayQueue *escapedRayQ, HitAreaLightQueue *hitAreaLightQ,
    MaterialEvalQueue *basicMtlQ, MaterialEvalQueue *universalMtlQ,
    MediumSampleQueue *mediumSampleQ, RayQueue *nextRayQ) const = 0;</div><p>


</p>
<p>The <a href="#WavefrontPathIntegrator"><tt>WavefrontPathIntegrator</tt></a>&rsquo;s call to <tt>IntersectClosest()</tt>
mostly passes the corresponding queues from its member variables, though
calls to <tt>GetCurrentQueue()</tt> and <tt>NextRayQueue()</tt> are necessary
to get the appropriate instances of those queues.

</p>
<p></p>
<span class="anchor" id="fragment-Findclosestintersectionsalongactiverays-0"></span><div class="fragmentname">&lt;&lt;Find closest intersections along active rays&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="#WavefrontPathIntegrator::aggregate" class="code">aggregate</a>-&gt;<a href="#WavefrontAggregate::IntersectClosest" class="code">IntersectClosest</a>(<a href="#WavefrontPathIntegrator::maxQueueSize" class="code">maxQueueSize</a>, <a href="#WavefrontPathIntegrator::CurrentRayQueue" class="code">CurrentRayQueue</a>(wavefrontDepth),
    <a href="#WavefrontPathIntegrator::escapedRayQueue" class="code">escapedRayQueue</a>, <a href="#WavefrontPathIntegrator::hitAreaLightQueue" class="code">hitAreaLightQueue</a>, <a href="#WavefrontPathIntegrator::basicEvalMaterialQueue" class="code">basicEvalMaterialQueue</a>,
    <a href="#WavefrontPathIntegrator::universalEvalMaterialQueue" class="code">universalEvalMaterialQueue</a>, <a href="#WavefrontPathIntegrator::mediumSampleQueue" class="code">mediumSampleQueue</a>,
    <a href="#WavefrontPathIntegrator::NextRayQueue" class="code">NextRayQueue</a>(wavefrontDepth));</div><p>


</p>
<p>

</p>
<p>In order to discuss the responsibilities of <tt>IntersectClosest()</tt>
implementations, we will focus on its implementation in
<a href="#CPUAggregate"><tt>CPUAggregate</tt></a>.  Rather than once again repeating the unwieldy list of
arguments here, we will proceed directly to the method implementation,
which starts with a parallel <tt>for</tt> loop over the items in the queue.

</p>
<p></p>
<span class="anchor" id="fragment-monoCPUAggregate::IntersectClosestmethodimplementation-0"></span><div class="fragmentname">&lt;&lt;<tt>CPUAggregate::IntersectClosest()</tt> method implementation&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Utilities/Parallelism.html#ParallelFor" class="code">ParallelFor</a>(0, rayQueue-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#WorkQueue::Size" class="code">Size</a>(), [=] (int index) {
    const RayWorkItem r = (*rayQueue)[index];
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Intersectmonorsraywiththesceneandenqueueresultingwork-0">Intersect <tt>r</tt>&rsquo;s ray with the scene and enqueue resulting work</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2485" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2485"><i></i></a><div id="fragbit-2485" class="collapse"><div class="fragmentcode">       pstd::optional&lt;ShapeIntersection&gt; si = aggregate.<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive::Intersect" class="code">Intersect</a>(r.<a href="#RayWorkItem::ray" class="code">ray</a>);
       if (!si)
           <a href="#EnqueueWorkAfterMiss" class="code">EnqueueWorkAfterMiss</a>(r, mediumSampleQueue, escapedRayQueue);
       else
           <a href="#EnqueueWorkAfterIntersection" class="code">EnqueueWorkAfterIntersection</a>(r, r.<a href="#RayWorkItem::ray" class="code">ray</a>.<a href="../Geometry_and_Transformations/Rays.html#Ray::medium" class="code">medium</a>, si-&gt;<a href="../Shapes/Basic_Shape_Interface.html#ShapeIntersection::tHit" class="code">tHit</a>, si-&gt;<a href="../Shapes/Basic_Shape_Interface.html#ShapeIntersection::intr" class="code">intr</a>,
               mediumSampleQueue, nextRayQueue, hitAreaLightQueue,
               basicEvalMaterialQueue, universalEvalMaterialQueue);</div></div>
});</div><p>


</p>
<p>A regular aggregate stored in <a href="#CPUAggregate"><tt>CPUAggregate</tt></a> handles the ray
intersection test, with different cases afterward for rays that have an
intersection with a surface and rays that do not.

</p>
<p></p>
<span class="anchor" id="fragment-Intersectmonorsraywiththesceneandenqueueresultingwork-0"></span><div class="fragmentname">&lt;&lt;Intersect <tt>r</tt>&rsquo;s ray with the scene and enqueue resulting work&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">pstd::optional&lt;ShapeIntersection&gt; si = aggregate.<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive::Intersect" class="code">Intersect</a>(r.<a href="#RayWorkItem::ray" class="code">ray</a>);
if (!si)
    <a href="#EnqueueWorkAfterMiss" class="code">EnqueueWorkAfterMiss</a>(r, mediumSampleQueue, escapedRayQueue);
else
    <a href="#EnqueueWorkAfterIntersection" class="code">EnqueueWorkAfterIntersection</a>(r, r.<a href="#RayWorkItem::ray" class="code">ray</a>.<a href="../Geometry_and_Transformations/Rays.html#Ray::medium" class="code">medium</a>, si-&gt;<a href="../Shapes/Basic_Shape_Interface.html#ShapeIntersection::tHit" class="code">tHit</a>, si-&gt;<a href="../Shapes/Basic_Shape_Interface.html#ShapeIntersection::intr" class="code">intr</a>,
        mediumSampleQueue, nextRayQueue, hitAreaLightQueue,
        basicEvalMaterialQueue, universalEvalMaterialQueue);</div><p>


</p>
<p>The details of enqueuing further work for rays that have no intersections
are handled by the <tt>EnqueueWorkAfterMiss()</tt> function, which is defined
in the file <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/wavefront/intersect.h"><tt>wavefront/intersect.h</tt></a>.  That header file provides
a number of functions that are used by both the CPU- and GPU-based ray
intersection code.  Gathering them there allows a single implementation to
be used by both, which in turn reduces the complexity of those
<tt>WavefrontAggregate</tt> implementations.

</p>
<p>Unlike many of the other functions in <a href="https://github.com/mmp/pbrt-v4/tree/master/src/wavefront/intersect.h"><tt>wavefront/intersect.h</tt></a>,
<tt>EnqueueWorkAfterMiss()</tt> is simple enough that it barely merits its
own function&mdash;if the ray is passing through participating media, it is
enqueued for medium sampling, and otherwise it is enqueued for evaluating
infinite light sources&rsquo; contribution to its radiance, if there are any in
the scene.

</p>
<p></p>
<span class="anchor" id="fragment-WavefrontRayIntersectionEnqueuingFunctions-0"></span><div class="fragmentname">&lt;&lt;Wavefront Ray Intersection Enqueuing Functions&gt;&gt;=&nbsp;<a href="#fragment-WavefrontRayIntersectionEnqueuingFunctions-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">void <span class="anchor" id="EnqueueWorkAfterMiss"></span>EnqueueWorkAfterMiss(RayWorkItem r,
                          MediumSampleQueue *mediumSampleQueue,
                          EscapedRayQueue *escapedRayQueue) {
    if (r.<a href="#RayWorkItem::ray" class="code">ray</a>.<a href="../Geometry_and_Transformations/Rays.html#Ray::medium" class="code">medium</a>)
        mediumSampleQueue-&gt;<a href="#EscapedRayQueue::Push" class="code">Push</a>(r, <a href="../Shapes/Managing_Rounding_Error.html#Infinity" class="code">Infinity</a>);
    else if (escapedRayQueue)
        escapedRayQueue-&gt;<a href="#EscapedRayQueue::Push" class="code">Push</a>(r);
}</div><p>


</p>
<p>For rays that do intersect a surface, there is more to be done.  The
<tt>EnqueueWorkAfterIntersection()</tt><span class="anchor" id="EnqueueWorkAfterIntersection"></span>
function, which is not included in the text, handles all the following
details.

</p>
<p>If the ray is passing through participating media, it is enqueued for
medium sampling.  Only if the ray is not absorbed or scattered in the
medium sampling kernel is work then queued for the surface intersection to
be processed.

</p>
<p>If a ray with an associated intersection is not scattered or absorbed by
participating media and hits an emissive surface, it is added to a queue so
that the surface&rsquo;s scattered radiance will be
added to the ray&rsquo;s radiance estimate.  Rays
hitting surfaces are also sorted by the surfaces&rsquo; materials and the
complexity of their textures into <tt>basicEvalMaterialQueue</tt> or
<tt>universalEvalMaterialQueue</tt>, both of which are <a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue"><tt>MultiWorkQueue</tt></a>s.
(Section&nbsp;<a href="#sec:gpu-surface-scatter">15.3.9</a> describes how the material queues
are organized.)  Finally, rays that hit surfaces with no materials that
represent medium transitions are pushed on to the <tt>nextRayQueue</tt> to be
continued in the next iteration, on the other side of the surface
intersection with their <tt>medium</tt> member variable updated accordingly.

</p>
<p>

</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#x6-GPURayIntersections"><i class="fas fa-link h3h4marginlink"></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span id="x6-GPURayIntersections"></span><h4>GPU Ray Intersections</h4><p>


</p>
<p>Following our custom of not including platform-specific code in the book
text, we will not discuss the details of <tt>pbrt</tt>&rsquo;s use of CUDA and the OptiX
API for its GPU ray-tracing implementation, but we will summarize the
abstractions currently used for GPU ray tracing.  See the files
<a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/gpu/optix.h"><tt>gpu/optix.h</tt></a> and <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/gpu/optix.cu"><tt>gpu/optix.cu</tt></a> 
for details, however.

</p>
<p>Current GPU ray intersection APIs follow a different model than the
CPU-focused accelerators in Chapter&nbsp;<a href="../Primitives_and_Intersection_Acceleration.html#chap:acceleration">7</a>.  Those
accelerators provide a fully procedural model, where the user calls
functions that take a single ray and execute synchronously before returning
their results.  GPU ray tracing is based on a programmable pipeline, where
some functionality is provided by the GPU vendor (either in hardware or in
software), and some is provided by the user in the form of code that is
executed at particular points in the pipeline.

</p>
<p>The user-supplied code is in the form of a series of <em>shaders</em>, each
of which is a function that is invoked in specific cases.  In
practice, many instances of these shaders run concurrently,
following the GPU&rsquo;s thread group execution model.
Ray tracing
starts with a <em>ray generation shader</em> that is responsible for
generating a ray and submitting it to the GPU ray-tracing function.  In <tt>pbrt</tt>&rsquo;s
implementation, the ray generation shader retrieves the ray from the
<a href="#RayQueue"><tt>RayQueue</tt></a>.

</p>
<p>GPUs currently only have native support for intersecting rays with
triangles.  If a scene has no other types of shapes, then the intersection
tests are handled entirely by the GPU&rsquo;s ray-tracing implementation.  For
other types of shapes, custom <em>intersection shaders</em> can be provided
by the user.  The user specifies a shape&rsquo;s axis-aligned bounding box and
associates an intersection shader with it.  When a ray intersects that box,
the intersection shader is invoked to determine if there is an
intersection.  If there is, both the parametric <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="0.84ex" height="2.009ex" style="vertical-align: -0.338ex;" viewBox="0 -719.6 361.5 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">t</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D461" d="M330 420c0 -20 -10 -20 -30 -20h-94l-74 -295c-4 -17 -6 -24 -6 -48c0 -33 10 -46 31 -46c34 0 87 24 130 128c5 11 6 14 15 14c4 0 12 0 12 -10c0 -8 -57 -154 -159 -154c-54 0 -92 38 -92 92c0 18 4 35 76 319h-88c-20 0 -28 0 -28 12c0 19 10 19 30 19h94l39 159 c9 35 37 36 40 36c17 0 29 -10 29 -27c0 -6 -5 -26 -41 -168h88c18 0 28 0 28 -11Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D461" x="0" y="0"></use>
</g>
</svg> value along the ray and
a handful of additional user-defined values can be returned to associate
with the intersection.

</p>
<p><tt>pbrt</tt> uses custom intersection shaders for all the quadric shapes as
well as for the <a href="../Shapes/Bilinear_Patches.html#BilinearPatch"><tt>BilinearPatch</tt></a>.  All follow the same pattern.  For
example, for bilinear patches, the intersection shader calls the
previously defined <a href="../Shapes/Bilinear_Patches.html#IntersectBilinearPatch"><tt>IntersectBilinearPatch()</tt></a> function.  Recall that in
the event of an intersection, it returns a <a href="../Shapes/Bilinear_Patches.html#BilinearIntersection"><tt>BilinearIntersection</tt></a>, not
a full <a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction"><tt>SurfaceInteraction</tt></a>.  This design is intentional, as a
<a href="../Shapes/Bilinear_Patches.html#BilinearIntersection"><tt>BilinearIntersection</tt></a> is much smaller&mdash;just 3 <tt>Float</tt>s.
Returning a small representation of the intersection is beneficial for
performance, as it reduces how much information must be written to memory.

</p>
<p>Alpha testing adds an additional complication to intersection testing
(recall the discussion of alpha textures in Section&nbsp;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#sec:gprim">7.1.1</a>).  An
<em>any hit shader</em> is applied to any primitives with alpha textures,
such as leaves with alpha masks.  The any hit shader executes for all
intersections with such primitives, before it is known if an intersection
is the closest.  Our implementation uses the any hit shader to evaluate the
alpha texture and apply a stochastic test, just like the &lt;&lt;<span class="fragmentname"><a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#fragment-Possiblyignoreintersectionbasedonstochasticalphatest-0">Possibly
ignore intersection based on stochastic alpha test</a></span>&gt;&gt; fragment in the
<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#GeometricPrimitive"><tt>GeometricPrimitive</tt></a> class used by the CPU.  If the test fails, then
the GPU is instructed to ignore the intersection completely.

</p>
<p>Once ray intersection testing has been completed, one of two shaders is
invoked.  For rays that have no intersections, a <em>miss shader</em> is
called.  Otherwise, a <em>closest hit shader</em> is invoked for processing
at the intersection point. Now a full <a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction"><tt>SurfaceInteraction</tt></a>
is needed.  All the shapes that are handled with custom intersection
shaders have a method that converts their compact intersection
representation to a <a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction"><tt>SurfaceInteraction</tt></a>; for example, it is
<a href="../Shapes/Bilinear_Patches.html#BilinearPatch::InteractionFromIntersection"><tt>BilinearPatch::InteractionFromIntersection()</tt></a> for bilinear patches.
The GPU reports the barycentric coordinates of triangle intersections,
which are sufficient for the <a href="../Shapes/Triangle_Meshes.html#Triangle::InteractionFromIntersection"><tt>Triangle::InteractionFromIntersection()</tt></a>
method to do its work.

</p>
<p>Given final intersections (or the determination that a ray does not
intersect anything), additional work is enqueued using functions from
<a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/wavefront/intersection.h"><tt>wavefront/intersection.h</tt></a>, as is the case for the wavefront CPU
ray-tracing aggregate.

</p>
<p>

</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#ParticipatingMedia"><i class="fas fa-link h3h4marginlink"></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span id="ParticipatingMedia"></span><h3>15.3.7  Participating Media</h3><p>


</p>
<p>In the interest of space, we will not walk through the code for the
kernels launched by the medium sampling method,
<tt>SampleMediumInteraction()</tt><span class="anchor" id="WavefrontPathIntegrator::SampleMediumInteraction"></span>.
Algorithmically, it matches the corresponding code in
<a href="../Light_Transport_II_Volume_Rendering/Volume_Scattering_Integrators.html#VolPathIntegrator"><tt>VolPathIntegrator</tt></a>, so we will just summarize the queues and types of
work involved.

</p>
<p>For any ray with a non-<tt>nullptr</tt> <a href="../Volume_Scattering/Media.html#Medium"><tt>Medium</tt></a>, the ray
intersection code enqueues a
<tt>MediumSampleWorkItem</tt><span class="anchor" id="MediumSampleWorkItem"></span> in the
<tt>mediumSampleQueue</tt><span class="anchor" id="WavefrontPathIntegrator::mediumSampleQueue"></span>.
A first medium-related kernel processes all the entries on this queue.
Its task is to call the ray medium&rsquo;s
<tt>SampleT_maj()</tt> method, adding
emission at each sampled point before sampling one of absorption, real
scattering, or null scattering.  Absorption causes path termination; real
scattering causes work to be added to another queue,
<tt>mediumScatterQueue</tt><span class="anchor" id="WavefrontPathIntegrator::mediumScatterQueue"></span>,
that holds <tt>MediumScatterWorkItem</tt><span class="anchor" id="MediumScatterWorkItem"></span>s;
and null scattering causes medium sampling to continue.  The path
throughput <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.636ex" height="2.843ex" style="vertical-align: -0.338ex;" viewBox="0 -1078.4 704.5 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">ModifyingAbove upper T With caret</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D447" d="M704 666c0 -3 -1 -13 -2 -17l-27 -174c-2 -15 -4 -23 -15 -23c-9 0 -12 7 -12 13c0 3 2 15 3 19c4 26 8 65 8 80c0 78 -45 82 -146 82c-21 0 -54 0 -63 -2c-12 -3 -16 -9 -23 -37l-133 -531c-4 -15 -4 -21 -4 -21c0 -16 8 -19 37 -22c26 -2 39 -2 64 -2c26 0 34 0 34 -11 c0 -20 -12 -20 -22 -20c-28 0 -58 2 -87 2l-83 1l-85 -1c-27 0 -55 -2 -82 -2c-6 0 -17 0 -17 12c0 19 6 19 42 19c107 0 110 11 119 48l134 534c1 3 4 15 4 21c0 8 0 12 -28 12h-39c-148 0 -174 -18 -228 -173c-6 -16 -7 -21 -17 -21c-7 0 -12 5 -12 11c0 0 5 16 6 18 l60 176c7 19 8 20 32 20h555c17 0 27 0 27 -11Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-302" d="M-82 607l-12 -20c-58 25 -115 54 -170 85c-55 -31 -112 -60 -170 -85l-12 20c56 49 117 91 182 127c65 -36 126 -78 182 -127Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D447" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-302" x="652" y="199"></use>
</g>
</svg> and path sampling PDFs are updated along the way.  In
the end, if the ray is neither scattered nor absorbed, then work is added
to queues in the same manner as for rays that are not passing through media
in the closest hit shader.

</p>
<p>A second kernel is then launched to process all the medium scattering
events in the
<tt>mediumScatterQueue</tt>.
The usual sampling process ensues: a light and then a point on it are
sampled, path sampling PDFs are computed, and a shadow ray is enqueued.
Next, the phase function is sampled to generate an indirect ray direction.
Work for that ray is then added to the next wavefront depth&rsquo;s
<a href="#RayQueue"><tt>RayQueue</tt></a> via a call to
<tt>PushIndirectRay()</tt>.

</p>
<p>

</p>
<p>

</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#Ray-FoundEmission"><i class="fas fa-link h3h4marginlink"></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span id="Ray-FoundEmission"></span><h3>15.3.8  Ray-Found Emission</h3><p>


</p>
<p>Two kernels handle rays that may add emission to their radiance estimates due
to their interaction with emissive entities.  The first processes rays that
have left the scene and the second handles rays
that intersect emissive surfaces.

</p>
<p><tt>escapedRayQueue</tt> is only allocated if the scene has one or more
infinite area lights; there is otherwise no work to be done for such rays.

</p>
<p></p>
<span class="anchor" id="fragment-WavefrontPathIntegratorMemberVariables-7"></span><div class="fragmentname">&lt;&lt;WavefrontPathIntegrator Member Variables&gt;&gt;+=&nbsp;<a href="#fragment-WavefrontPathIntegratorMemberVariables-6"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-WavefrontPathIntegratorMemberVariables-8"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">EscapedRayQueue *<span class="anchor" id="WavefrontPathIntegrator::escapedRayQueue"></span>escapedRayQueue = nullptr;</div><p>


</p>
<p>Note that <tt>HandleEscapedRays()</tt> returns immediately if there is no
queue and thus no infinite area lights, saving the cost of an
unnecessary kernel launch in that case. 

</p>
<p></p>
<span class="anchor" id="fragment-WavefrontPathIntegratorMethodDefinitions-1"></span><div class="fragmentname">&lt;&lt;WavefrontPathIntegrator Method Definitions&gt;&gt;+=&nbsp;<a href="#fragment-WavefrontPathIntegratorMethodDefinitions-0"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-WavefrontPathIntegratorMethodDefinitions-2"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">void <span class="anchor" id="WavefrontPathIntegrator::HandleEscapedRays"></span>WavefrontPathIntegrator::HandleEscapedRays() {
    if (!<a href="#WavefrontPathIntegrator::escapedRayQueue" class="code">escapedRayQueue</a>) return;
    <a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#ForAllQueued" class="code">ForAllQueued</a>("Handle escaped rays", <a href="#WavefrontPathIntegrator::escapedRayQueue" class="code">escapedRayQueue</a>, <a href="#WavefrontPathIntegrator::maxQueueSize" class="code">maxQueueSize</a>,
        PBRT_CPU_GPU_LAMBDA (const EscapedRayWorkItem w) {
            &lt;&lt;<span class="fragmentname"><a href="#fragment-Computeweightedradianceforescapedray-0">Compute weighted radiance for escaped ray</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2486" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2486"><i></i></a><div id="fragbit-2486" class="collapse"><div class="fragmentcode">               <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> L(0.f);
               for (const auto &amp;light : *<a href="#WavefrontPathIntegrator::infiniteLights" class="code">infiniteLights</a>) {
                   if (<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <a href="../Light_Sources/Light_Interface.html#Light::Le" class="code">Le</a> = light.<a href="../Light_Sources/Light_Interface.html#Light::Le" class="code">Le</a>(<a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a>(w.<a href="#EscapedRayWorkItem::rayo" class="code">rayo</a>, w.<a href="#EscapedRayWorkItem::rayd" class="code">rayd</a>), w.<a href="#EscapedRayWorkItem::lambda" class="code">lambda</a>); <a href="../Light_Sources/Light_Interface.html#Light::Le" class="code">Le</a>) {
                       &lt;&lt;<span class="fragmentname"><a href="#fragment-Computepathradiancecontributionfrominfinitelight-0">Compute path radiance contribution from infinite light</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2487" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2487"><i></i></a><div id="fragbit-2487" class="collapse"><div class="fragmentcode">                          if (w.<a href="#EscapedRayWorkItem::depth" class="code">depth</a> == 0 || w.<a href="#EscapedRayWorkItem::specularBounce" class="code">specularBounce</a>) {
                              L += w.<a href="#EscapedRayWorkItem::beta" class="code">beta</a> * Le / w.<a href="#EscapedRayWorkItem::r_u" class="code">r_u</a>.<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum::Average" class="code">Average</a>();
                          } else {
                              &lt;&lt;<span class="fragmentname"><a href="#fragment-ComputeMIS-weightedradiancecontributionfrominfinitelight-0">Compute MIS-weighted radiance contribution from infinite light</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2488" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2488"><i></i></a><div id="fragbit-2488" class="collapse"><div class="fragmentcode">                                 <a href="../Light_Sources/Light_Interface.html#LightSampleContext" class="code">LightSampleContext</a> ctx = w.<a href="#EscapedRayWorkItem::prevIntrCtx" class="code">prevIntrCtx</a>;
                                 Float lightChoicePDF = lightSampler.<a href="../Light_Sources/Light_Sampling.html#LightSampler::PMF" class="code">PMF</a>(ctx, light);
                                 <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <a href="#EscapedRayWorkItem::r_l" class="code">r_l</a> = w.<a href="#EscapedRayWorkItem::r_l" class="code">r_l</a> * lightChoicePDF *
                                     light.<a href="../Light_Sources/Light_Interface.html#Light::PDF_Li" class="code">PDF_Li</a>(ctx, w.<a href="#EscapedRayWorkItem::rayd" class="code">rayd</a>, true);
                                 L += w.<a href="#EscapedRayWorkItem::beta" class="code">beta</a> * Le / (w.<a href="#EscapedRayWorkItem::r_u" class="code">r_u</a> + <a href="#EscapedRayWorkItem::r_l" class="code">r_l</a>).<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum::Average" class="code">Average</a>();</div></div>
                          }</div></div>
                   }
               }</div></div>
            &lt;&lt;<span class="fragmentname"><a href="#fragment-Updatepixelradianceifraysradianceisnonzero-0">Update pixel radiance if ray&rsquo;s radiance is nonzero</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2489" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2489"><i></i></a><div id="fragbit-2489" class="collapse"><div class="fragmentcode">               if (<a href="#PixelSampleState::L" class="code">L</a>) {
                   <a href="#PixelSampleState::L" class="code">L</a> += <a href="#WavefrontPathIntegrator::pixelSampleState" class="code">pixelSampleState</a>.<a href="#PixelSampleState::L" class="code">L</a>[w.<a href="#EscapedRayWorkItem::pixelIndex" class="code">pixelIndex</a>];
                   <a href="#WavefrontPathIntegrator::pixelSampleState" class="code">pixelSampleState</a>.<a href="#PixelSampleState::L" class="code">L</a>[w.<a href="#EscapedRayWorkItem::pixelIndex" class="code">pixelIndex</a>] = <a href="#PixelSampleState::L" class="code">L</a>;
               }</div></div>
        });
}</div><p>


</p>
<p><tt>EscapedRayQueue</tt><span class="anchor" id="EscapedRayQueue"></span>, not included here, is a
<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#WorkQueue"><tt>WorkQueue</tt></a> of <a href="#EscapedRayWorkItem"><tt>EscapedRayWorkItem</tt></a>s.  It provides
a <tt>Push()</tt><span class="anchor" id="EscapedRayQueue::Push"></span> method that takes a
<a href="#RayWorkItem"><tt>RayWorkItem</tt></a> and copies the values from it that are needed in the
kernel.

</p>
<p>

</p>
<p></p>
<span class="anchor" id="fragment-EscapedRayWorkItemDefinition-0"></span><div class="fragmentname">&lt;&lt;EscapedRayWorkItem Definition&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">struct <span class="anchor" id="EscapedRayWorkItem"></span>EscapedRayWorkItem {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-EscapedRayWorkItemPublicMembers-0">EscapedRayWorkItem Public Members</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2490" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2490"><i></i></a><div id="fragbit-2490" class="collapse"><div class="fragmentcode">       <a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a> rayo;
       <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> rayd;
       int depth;
       <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> lambda;
       int pixelIndex;
       <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> beta;
       int specularBounce;
       <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> r_u, r_l;
       <a href="../Light_Sources/Light_Interface.html#LightSampleContext" class="code">LightSampleContext</a> prevIntrCtx;</div></div>
};</div><p>


</p>
<p>The work item for escaped rays stores the ray origin, direction, and depth
as well as its wavelengths.  The ray&rsquo;s associated pixel index makes it
possible to add any found emission to its radiance estimate.

</p>
<p></p>
<span class="anchor" id="fragment-EscapedRayWorkItemPublicMembers-0"></span><div class="fragmentname">&lt;&lt;EscapedRayWorkItem Public Members&gt;&gt;=&nbsp;<a href="#fragment-EscapedRayWorkItemPublicMembers-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode"><a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a> <span class="anchor" id="EscapedRayWorkItem::rayo"></span>rayo;
<a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> <span class="anchor" id="EscapedRayWorkItem::rayd"></span>rayd;
int <span class="anchor" id="EscapedRayWorkItem::depth"></span>depth;
<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> <span class="anchor" id="EscapedRayWorkItem::lambda"></span>lambda;
int <span class="anchor" id="EscapedRayWorkItem::pixelIndex"></span>pixelIndex;</div><p>


</p>
<p>The kernel&rsquo;s implementation parallels the &lt;&lt;<span class="fragmentname">Accumulate
contributions from infinite light sources</span>&gt;&gt; fragment in the
<a href="../Light_Transport_II_Volume_Rendering/Volume_Scattering_Integrators.html#VolPathIntegrator"><tt>VolPathIntegrator</tt></a>, just using the information about the ray from the
<tt>EscapedRayWorkItem</tt>.

</p>
<p></p>
<span class="anchor" id="fragment-Computeweightedradianceforescapedray-0"></span><div class="fragmentname">&lt;&lt;Compute weighted radiance for escaped ray&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> L(0.f);
for (const auto &amp;light : *<a href="#WavefrontPathIntegrator::infiniteLights" class="code">infiniteLights</a>) {
    if (<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <a href="../Light_Sources/Light_Interface.html#Light::Le" class="code">Le</a> = light.<a href="../Light_Sources/Light_Interface.html#Light::Le" class="code">Le</a>(<a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a>(w.<a href="#EscapedRayWorkItem::rayo" class="code">rayo</a>, w.<a href="#EscapedRayWorkItem::rayd" class="code">rayd</a>), w.<a href="#EscapedRayWorkItem::lambda" class="code">lambda</a>); <a href="../Light_Sources/Light_Interface.html#Light::Le" class="code">Le</a>) {
        &lt;&lt;<span class="fragmentname"><a href="#fragment-Computepathradiancecontributionfrominfinitelight-0">Compute path radiance contribution from infinite light</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2491" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2491"><i></i></a><div id="fragbit-2491" class="collapse"><div class="fragmentcode">           if (w.<a href="#EscapedRayWorkItem::depth" class="code">depth</a> == 0 || w.<a href="#EscapedRayWorkItem::specularBounce" class="code">specularBounce</a>) {
               L += w.<a href="#EscapedRayWorkItem::beta" class="code">beta</a> * Le / w.<a href="#EscapedRayWorkItem::r_u" class="code">r_u</a>.<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum::Average" class="code">Average</a>();
           } else {
               &lt;&lt;<span class="fragmentname"><a href="#fragment-ComputeMIS-weightedradiancecontributionfrominfinitelight-0">Compute MIS-weighted radiance contribution from infinite light</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2492" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2492"><i></i></a><div id="fragbit-2492" class="collapse"><div class="fragmentcode">                  <a href="../Light_Sources/Light_Interface.html#LightSampleContext" class="code">LightSampleContext</a> ctx = w.<a href="#EscapedRayWorkItem::prevIntrCtx" class="code">prevIntrCtx</a>;
                  Float lightChoicePDF = lightSampler.<a href="../Light_Sources/Light_Sampling.html#LightSampler::PMF" class="code">PMF</a>(ctx, light);
                  <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <a href="#EscapedRayWorkItem::r_l" class="code">r_l</a> = w.<a href="#EscapedRayWorkItem::r_l" class="code">r_l</a> * lightChoicePDF *
                      light.<a href="../Light_Sources/Light_Interface.html#Light::PDF_Li" class="code">PDF_Li</a>(ctx, w.<a href="#EscapedRayWorkItem::rayd" class="code">rayd</a>, true);
                  L += w.<a href="#EscapedRayWorkItem::beta" class="code">beta</a> * Le / (w.<a href="#EscapedRayWorkItem::r_u" class="code">r_u</a> + <a href="#EscapedRayWorkItem::r_l" class="code">r_l</a>).<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum::Average" class="code">Average</a>();</div></div>
           }</div></div>
    }
}</div><p>


</p>
<p>The final result is then added to the ray&rsquo;s associated
<a href="#PixelSampleState::L"><tt>PixelSampleState::L</tt></a> value, so long as <tt>L</tt> is nonzero.  If it is
zero, skipping the unnecessary update may not lead to fewer instructions
being executed, given the GPU&rsquo;s execution model, but it will save memory
bandwidth, which can be just as important to performance.

</p>
<p></p>
<span class="anchor" id="fragment-Updatepixelradianceifraysradianceisnonzero-0"></span><div class="fragmentname">&lt;&lt;Update pixel radiance if ray&rsquo;s radiance is nonzero&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">if (<a href="#PixelSampleState::L" class="code">L</a>) {
    <a href="#PixelSampleState::L" class="code">L</a> += <a href="#WavefrontPathIntegrator::pixelSampleState" class="code">pixelSampleState</a>.<a href="#PixelSampleState::L" class="code">L</a>[w.<a href="#EscapedRayWorkItem::pixelIndex" class="code">pixelIndex</a>];
    <a href="#WavefrontPathIntegrator::pixelSampleState" class="code">pixelSampleState</a>.<a href="#PixelSampleState::L" class="code">L</a>[w.<a href="#EscapedRayWorkItem::pixelIndex" class="code">pixelIndex</a>] = <a href="#PixelSampleState::L" class="code">L</a>;
}</div><p>


</p>
<p>For infinite area lights that are directly visible or are encountered
through specular reflection, MIS is performed using only the unidirectional
path PDF, since that is the only way the path could have been
sampled.

</p>
<p></p>
<span class="anchor" id="fragment-Computepathradiancecontributionfrominfinitelight-0"></span><div class="fragmentname">&lt;&lt;Compute path radiance contribution from infinite light&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">if (w.<a href="#EscapedRayWorkItem::depth" class="code">depth</a> == 0 || w.<a href="#EscapedRayWorkItem::specularBounce" class="code">specularBounce</a>) {
    L += w.<a href="#EscapedRayWorkItem::beta" class="code">beta</a> * Le / w.<a href="#EscapedRayWorkItem::r_u" class="code">r_u</a>.<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum::Average" class="code">Average</a>();
} else {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-ComputeMIS-weightedradiancecontributionfrominfinitelight-0">Compute MIS-weighted radiance contribution from infinite light</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2493" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2493"><i></i></a><div id="fragbit-2493" class="collapse"><div class="fragmentcode">       <a href="../Light_Sources/Light_Interface.html#LightSampleContext" class="code">LightSampleContext</a> ctx = w.<a href="#EscapedRayWorkItem::prevIntrCtx" class="code">prevIntrCtx</a>;
       Float lightChoicePDF = lightSampler.<a href="../Light_Sources/Light_Sampling.html#LightSampler::PMF" class="code">PMF</a>(ctx, light);
       <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <a href="#EscapedRayWorkItem::r_l" class="code">r_l</a> = w.<a href="#EscapedRayWorkItem::r_l" class="code">r_l</a> * lightChoicePDF *
           light.<a href="../Light_Sources/Light_Interface.html#Light::PDF_Li" class="code">PDF_Li</a>(ctx, w.<a href="#EscapedRayWorkItem::rayd" class="code">rayd</a>, true);
       L += w.<a href="#EscapedRayWorkItem::beta" class="code">beta</a> * Le / (w.<a href="#EscapedRayWorkItem::r_u" class="code">r_u</a> + <a href="#EscapedRayWorkItem::r_l" class="code">r_l</a>).<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum::Average" class="code">Average</a>();</div></div>
}</div><p>


</p>
<p>The path throughput <tt>beta</tt> is needed to weight the light&rsquo;s
contribution.  Further, whether or not the previous bounce was due to
specular reflection must be tracked.  Note that this value only requires a
single bit; using a full 32-bit <tt>int</tt> is wasteful.  A more optimized
implementation might save some bandwidth by stealing one of the bits from
<tt>pixelIndex</tt>, which does not need all 32 of them.

</p>
<p></p>
<span class="anchor" id="fragment-EscapedRayWorkItemPublicMembers-1"></span><div class="fragmentname">&lt;&lt;EscapedRayWorkItem Public Members&gt;&gt;+=&nbsp;<a href="#fragment-EscapedRayWorkItemPublicMembers-0"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-EscapedRayWorkItemPublicMembers-2"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode"><a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <span class="anchor" id="EscapedRayWorkItem::beta"></span>beta;
int <span class="anchor" id="EscapedRayWorkItem::specularBounce"></span>specularBounce;</div><p>


</p>
<p>If other types of scattering preceded the ray&rsquo;s escape, MIS weights are
computed using both the light and unidirectional sampling PDFs, following
the same approach as is implemented in the &lt;&lt;<span class="fragmentname"><a href="../Light_Transport_II_Volume_Rendering/Volume_Scattering_Integrators.html#fragment-AddinfinitelightcontributionusingbothPDFswithMIS-0">Add infinite light
contribution using both PDFs with MIS</a></span>&gt;&gt; fragment in the
<a href="../Light_Transport_II_Volume_Rendering/Volume_Scattering_Integrators.html#VolPathIntegrator"><tt>VolPathIntegrator</tt></a>.

</p>
<p></p>
<span class="anchor" id="fragment-ComputeMIS-weightedradiancecontributionfrominfinitelight-0"></span><div class="fragmentname">&lt;&lt;Compute MIS-weighted radiance contribution from infinite light&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Light_Sources/Light_Interface.html#LightSampleContext" class="code">LightSampleContext</a> ctx = w.<a href="#EscapedRayWorkItem::prevIntrCtx" class="code">prevIntrCtx</a>;
Float lightChoicePDF = lightSampler.<a href="../Light_Sources/Light_Sampling.html#LightSampler::PMF" class="code">PMF</a>(ctx, light);
<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <a href="#EscapedRayWorkItem::r_l" class="code">r_l</a> = w.<a href="#EscapedRayWorkItem::r_l" class="code">r_l</a> * lightChoicePDF *
    light.<a href="../Light_Sources/Light_Interface.html#Light::PDF_Li" class="code">PDF_Li</a>(ctx, w.<a href="#EscapedRayWorkItem::rayd" class="code">rayd</a>, true);
L += w.<a href="#EscapedRayWorkItem::beta" class="code">beta</a> * Le / (w.<a href="#EscapedRayWorkItem::r_u" class="code">r_u</a> + <a href="#EscapedRayWorkItem::r_l" class="code">r_l</a>).<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum::Average" class="code">Average</a>();</div><p>


</p>
<p>In order to compute MIS weights, the <a href="#EscapedRayWorkItem"><tt>EscapedRayWorkItem</tt></a> must provide
not only rescaled path probabilities but also geometric information about the previous path
scattering vertex.

</p>
<p></p>
<span class="anchor" id="fragment-EscapedRayWorkItemPublicMembers-2"></span><div class="fragmentname">&lt;&lt;EscapedRayWorkItem Public Members&gt;&gt;+=&nbsp;<a href="#fragment-EscapedRayWorkItemPublicMembers-1"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode"><a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <span class="anchor" id="EscapedRayWorkItem::r_u"></span>r_u, <span class="anchor" id="EscapedRayWorkItem::r_l"></span>r_l;
<a href="../Light_Sources/Light_Interface.html#LightSampleContext" class="code">LightSampleContext</a> <span class="anchor" id="EscapedRayWorkItem::prevIntrCtx"></span>prevIntrCtx;</div><p>


</p>
<p>The second kernel handles rays that intersect emissive surfaces.

</p>
<p></p>
<span class="anchor" id="fragment-WavefrontPathIntegratorMethodDefinitions-2"></span><div class="fragmentname">&lt;&lt;WavefrontPathIntegrator Method Definitions&gt;&gt;+=&nbsp;<a href="#fragment-WavefrontPathIntegratorMethodDefinitions-1"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode">void <span class="anchor" id="WavefrontPathIntegrator::HandleEmissiveIntersection"></span>WavefrontPathIntegrator::HandleEmissiveIntersection() {
    <a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#ForAllQueued" class="code">ForAllQueued</a>("Handle emitters hit by indirect rays", <a href="#WavefrontPathIntegrator::hitAreaLightQueue" class="code">hitAreaLightQueue</a>,
                 <a href="#WavefrontPathIntegrator::maxQueueSize" class="code">maxQueueSize</a>,
        PBRT_CPU_GPU_LAMBDA (const HitAreaLightWorkItem w) {
            &lt;&lt;<span class="fragmentname"><a href="#fragment-Findemittedradiancefromsurfacethatrayhit-0">Find emitted radiance from surface that ray hit</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2494" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2494"><i></i></a><div id="fragbit-2494" class="collapse"><div class="fragmentcode">               <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> Le = w.<a href="#HitAreaLightWorkItem::areaLight" class="code">areaLight</a>.<a href="../Light_Sources/Light_Interface.html#Light::L" class="code">L</a>(w.<a href="#HitAreaLightWorkItem::p" class="code">p</a>, w.<a href="#HitAreaLightWorkItem::n" class="code">n</a>, w.<a href="#HitAreaLightWorkItem::uv" class="code">uv</a>, w.<a href="#HitAreaLightWorkItem::wo" class="code">wo</a>, w.<a href="#HitAreaLightWorkItem::lambda" class="code">lambda</a>);
               if (!Le)
                   return;
               </div></div>
            &lt;&lt;<span class="fragmentname"><a href="#fragment-Computearealightsweightedradiancecontributiontothepath-0">Compute area light&rsquo;s weighted radiance contribution to the path</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2495" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2495"><i></i></a><div id="fragbit-2495" class="collapse"><div class="fragmentcode">               <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> L(0.f);
               if (w.<a href="#HitAreaLightWorkItem::depth" class="code">depth</a> == 0 || w.<a href="#HitAreaLightWorkItem::specularBounce" class="code">specularBounce</a>) {
                   L = w.<a href="#HitAreaLightWorkItem::beta" class="code">beta</a> * Le / w.<a href="#HitAreaLightWorkItem::r_u" class="code">r_u</a>.<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum::Average" class="code">Average</a>();
               } else {
                   &lt;&lt;<span class="fragmentname">Compute MIS-weighted radiance contribution from area light</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2496" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2496"><i></i></a><div id="fragbit-2496" class="collapse"><div class="fragmentcode">                      <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> wi = -w.wo;
                      <a href="../Light_Sources/Light_Interface.html#LightSampleContext" class="code">LightSampleContext</a> ctx = w.prevIntrCtx;
                      Float lightChoicePDF = lightSampler.PMF(ctx, w.areaLight);
                      Float lightPDF = lightChoicePDF *
                                       w.areaLight.PDF_Li(ctx, wi, true);
                      
                      <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> r_u = w.r_u;
                      <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> r_l = w.r_l * lightPDF;
                      L = w.beta * Le / (r_u + r_l).Average();</div></div>
               }
               </div></div>
            &lt;&lt;<span class="fragmentname"><a href="#fragment-UpdatemonoLinmonoPixelSampleStateforarealightsradiance-0">Update <tt>L</tt> in <tt>PixelSampleState</tt> for area light&rsquo;s radiance</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2497" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2497"><i></i></a><div id="fragbit-2497" class="collapse"><div class="fragmentcode">               L += <a href="#WavefrontPathIntegrator::pixelSampleState" class="code">pixelSampleState</a>.L[w.<a href="#HitAreaLightWorkItem::pixelIndex" class="code">pixelIndex</a>];
               <a href="#WavefrontPathIntegrator::pixelSampleState" class="code">pixelSampleState</a>.L[w.<a href="#HitAreaLightWorkItem::pixelIndex" class="code">pixelIndex</a>] = L;</div></div>
        });
}</div><p>


</p>
<p>The <tt>HitAreaLightQueue</tt> stores <tt>HitAreaLightWorkItem</tt>s.

</p>
<p></p>
<span class="anchor" id="fragment-HitAreaLightQueueDefinition-0"></span><div class="fragmentname">&lt;&lt;HitAreaLightQueue Definition&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">using <span class="anchor" id="HitAreaLightQueue"></span>HitAreaLightQueue = <a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#WorkQueue" class="code">WorkQueue</a>&lt;<a href="#HitAreaLightWorkItem" class="code">HitAreaLightWorkItem</a>&gt;;</div><p>


</p>
<p></p>
<span class="anchor" id="fragment-WavefrontPathIntegratorMemberVariables-8"></span><div class="fragmentname">&lt;&lt;WavefrontPathIntegrator Member Variables&gt;&gt;+=&nbsp;<a href="#fragment-WavefrontPathIntegratorMemberVariables-7"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-WavefrontPathIntegratorMemberVariables-9"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">HitAreaLightQueue *<span class="anchor" id="WavefrontPathIntegrator::hitAreaLightQueue"></span>hitAreaLightQueue = nullptr;</div><p>


</p>
<p></p>
<span class="anchor" id="fragment-HitAreaLightWorkItemDefinition-0"></span><div class="fragmentname">&lt;&lt;HitAreaLightWorkItem Definition&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">struct <span class="anchor" id="HitAreaLightWorkItem"></span>HitAreaLightWorkItem {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-HitAreaLightWorkItemPublicMembers-0">HitAreaLightWorkItem Public Members</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2498" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2498"><i></i></a><div id="fragbit-2498" class="collapse"><div class="fragmentcode">       <a href="../Light_Sources/Light_Interface.html#Light" class="code">Light</a> areaLight;
       <a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a> p;
       <a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a> n;
       <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a> uv;
       <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> wo;
       <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> lambda;
       int depth;
       <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> beta, r_u, r_l;
       <a href="../Light_Sources/Light_Interface.html#LightSampleContext" class="code">LightSampleContext</a> prevIntrCtx;
       int specularBounce;
       int pixelIndex;</div></div>
};</div><p>


</p>
<p>The first step in the kernel is to compute the emitted radiance at the
ray&rsquo;s intersection point.  If there is none, the kernel can return
immediately.  Note that it thus could be beneficial if a <a href="../Light_Sources/Light_Interface.html#Light"><tt>Light</tt></a> method
was added that did a quick conservative test for this case.  Such a method
could make it possible not to pay the cost of enqueuing work for cases such
as a one-sided light source that was intersected on its non-emissive side.
With the current implementation, that case is detected only here, costing
both bandwidth for the queue work and execution divergence from the threads
that return.  (Such a method should be simple, deferring more complex tasks
like performing texture lookups for surfaces that use image maps to
modulate their emission, in order not to harm performance.)

</p>
<p>We also note that the call to <a href="../Light_Sources/Light_Interface.html#Light::L"><tt>Light::L()</tt></a> would be a potential
source of execution divergence if <tt>pbrt</tt> had more than one <a href="../Light_Sources/Light_Interface.html#Light"><tt>Light</tt></a>
implementation that could be used for emissive surfaces.  Currently, there
is only <a href="../Light_Sources/Area_Lights.html#DiffuseAreaLight"><tt>DiffuseAreaLight</tt></a>, so this is not a concern, but if there were
more, it might be worthwhile to have a separate queue for each type of area
light in order to avoid this divergence.

</p>
<p></p>
<span class="anchor" id="fragment-Findemittedradiancefromsurfacethatrayhit-0"></span><div class="fragmentname">&lt;&lt;Find emitted radiance from surface that ray hit&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> Le = w.<a href="#HitAreaLightWorkItem::areaLight" class="code">areaLight</a>.<a href="../Light_Sources/Light_Interface.html#Light::L" class="code">L</a>(w.<a href="#HitAreaLightWorkItem::p" class="code">p</a>, w.<a href="#HitAreaLightWorkItem::n" class="code">n</a>, w.<a href="#HitAreaLightWorkItem::uv" class="code">uv</a>, w.<a href="#HitAreaLightWorkItem::wo" class="code">wo</a>, w.<a href="#HitAreaLightWorkItem::lambda" class="code">lambda</a>);
if (!Le)
    return;
</div><p>


</p>
<p>The following <tt>HitAreaLightWorkItem</tt> member variables provide the
information necessary to compute the emitted radiance from the intersection
point back along the ray.
 
</p>
<span class="anchor" id="fragment-HitAreaLightWorkItemPublicMembers-0"></span><div class="fragmentname">&lt;&lt;HitAreaLightWorkItem Public Members&gt;&gt;=&nbsp;<a href="#fragment-HitAreaLightWorkItemPublicMembers-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode"><a href="../Light_Sources/Light_Interface.html#Light" class="code">Light</a> <span class="anchor" id="HitAreaLightWorkItem::areaLight"></span>areaLight;
<a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a> <span class="anchor" id="HitAreaLightWorkItem::p"></span>p;
<a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a> <span class="anchor" id="HitAreaLightWorkItem::n"></span>n;
<a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a> <span class="anchor" id="HitAreaLightWorkItem::uv"></span>uv;
<a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> <span class="anchor" id="HitAreaLightWorkItem::wo"></span>wo;
<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> <span class="anchor" id="HitAreaLightWorkItem::lambda"></span>lambda;</div><p>


</p>
<p>The final path contribution is found similarly to how it is for escaped
rays and infinite area lights.

</p>
<p></p>
<span class="anchor" id="fragment-Computearealightsweightedradiancecontributiontothepath-0"></span><div class="fragmentname">&lt;&lt;Compute area light&rsquo;s weighted radiance contribution to the path&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> L(0.f);
if (w.<a href="#HitAreaLightWorkItem::depth" class="code">depth</a> == 0 || w.<a href="#HitAreaLightWorkItem::specularBounce" class="code">specularBounce</a>) {
    L = w.<a href="#HitAreaLightWorkItem::beta" class="code">beta</a> * Le / w.<a href="#HitAreaLightWorkItem::r_u" class="code">r_u</a>.<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum::Average" class="code">Average</a>();
} else {
    &lt;&lt;<span class="fragmentname">Compute MIS-weighted radiance contribution from area light</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2499" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2499"><i></i></a><div id="fragbit-2499" class="collapse"><div class="fragmentcode">       <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> wi = -w.wo;
       <a href="../Light_Sources/Light_Interface.html#LightSampleContext" class="code">LightSampleContext</a> ctx = w.prevIntrCtx;
       Float lightChoicePDF = lightSampler.PMF(ctx, w.areaLight);
       Float lightPDF = lightChoicePDF *
                        w.areaLight.PDF_Li(ctx, wi, true);
       
       <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> r_u = w.r_u;
       <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> r_l = w.r_l * lightPDF;
       L = w.beta * Le / (r_u + r_l).Average();</div></div>
}
</div><p>


</p>
<p>Once again, the <tt>specularBounce</tt> member could be packed in elsewhere
in order to save storage and reduce bandwidth requirements. 

</p>
<p></p>
<span class="anchor" id="fragment-HitAreaLightWorkItemPublicMembers-1"></span><div class="fragmentname">&lt;&lt;HitAreaLightWorkItem Public Members&gt;&gt;+=&nbsp;<a href="#fragment-HitAreaLightWorkItemPublicMembers-0"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode">int <span class="anchor" id="HitAreaLightWorkItem::depth"></span>depth;
<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <span class="anchor" id="HitAreaLightWorkItem::beta"></span>beta, <span class="anchor" id="HitAreaLightWorkItem::r_u"></span>r_u, <span class="anchor" id="HitAreaLightWorkItem::r_l"></span>r_l;
<a href="../Light_Sources/Light_Interface.html#LightSampleContext" class="code">LightSampleContext</a> <span class="anchor" id="HitAreaLightWorkItem::prevIntrCtx"></span>prevIntrCtx;
int <span class="anchor" id="HitAreaLightWorkItem::specularBounce"></span>specularBounce;
int <span class="anchor" id="HitAreaLightWorkItem::pixelIndex"></span>pixelIndex;</div><p>


</p>
<p>We will not
include the &lt;&lt;<span class="fragmentname">Compute MIS-weighted radiance contribution from area
light</span>&gt;&gt; fragment here, which closely parallels the corresponding case in the
<a href="../Light_Transport_II_Volume_Rendering/Volume_Scattering_Integrators.html#VolPathIntegrator"><tt>VolPathIntegrator</tt></a> as well as the earlier fragment &lt;&lt;<span class="fragmentname"><a href="#fragment-ComputeMIS-weightedradiancecontributionfrominfinitelight-0">Compute
MIS-weighted radiance contribution from infinite light</a></span>&gt;&gt;.

</p>
<p>

</p>
<p>The final weighted radiance value is then accumulated in the ray&rsquo;s
<a href="#PixelSampleState"><tt>PixelSampleState</tt></a>.

</p>
<p></p>
<span class="anchor" id="fragment-UpdatemonoLinmonoPixelSampleStateforarealightsradiance-0"></span><div class="fragmentname">&lt;&lt;Update <tt>L</tt> in <tt>PixelSampleState</tt> for area light&rsquo;s radiance&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">L += <a href="#WavefrontPathIntegrator::pixelSampleState" class="code">pixelSampleState</a>.L[w.<a href="#HitAreaLightWorkItem::pixelIndex" class="code">pixelIndex</a>];
<a href="#WavefrontPathIntegrator::pixelSampleState" class="code">pixelSampleState</a>.L[w.<a href="#HitAreaLightWorkItem::pixelIndex" class="code">pixelIndex</a>] = L;</div><p>


</p>
<p>The queues for both of these kernels need to be reset at the start of each
ray depth iteration, so we will add the corresponding <tt>Reset()</tt> calls to
the queue-resetting fragment defined earlier.

</p>
<p></p>
<span class="anchor" id="fragment-Resetqueuesbeforetracingnextbatchofrays-0"></span><div class="fragmentname">&lt;&lt;Reset queues before tracing next batch of rays&gt;&gt;=&nbsp;<a href="#fragment-Resetqueuesbeforetracingnextbatchofrays-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">if (<a href="#WavefrontPathIntegrator::escapedRayQueue" class="code">escapedRayQueue</a>) <a href="#WavefrontPathIntegrator::escapedRayQueue" class="code">escapedRayQueue</a>-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#WorkQueue::Reset" class="code">Reset</a>();
<a href="#WavefrontPathIntegrator::hitAreaLightQueue" class="code">hitAreaLightQueue</a>-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#WorkQueue::Reset" class="code">Reset</a>();</div><p>


</p>
<p>Having seen these two kernels, it is fair to ask: why not handle these
cases immediately in the ray intersection and medium sampling kernels,
rather than incurring the bandwidth costs of queuing up work there and then
consuming it here? This is yet another trade-off of bandwidth versus
execution convergence.  Doing this work in separate kernels for only the
cases where it is required means that the kernels both start execution
fully converged, with all threads doing useful work.  In the intersection
and medium scattering kernels, we would generally expect that only a subset
of the rays would leave the scene or intersect emissive surfaces.  In that
case, we would have control divergence and all rays in the thread
group that did not intersect an emissive surface would incur a performance
cost if even one of the others did.  The optimal trade-off depends on both
the complexity of the computation to be done in those cases and the
amount of bandwidth offered by the GPU.

</p>
<p>

</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#SurfaceScattering"><i class="fas fa-link h3h4marginlink"></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span class="anchor" id="sec:gpu-surface-scatter"></span><span id="SurfaceScattering"></span><h3>15.3.9  Surface Scattering</h3><p>



</p>
<p>With the <a href="#WavefrontPathIntegrator"><tt>WavefrontPathIntegrator</tt></a>, the majority of rendering time is
usually spent in the kernels responsible for surface scattering.  These
kernels are specialized by the surfaces&rsquo; materials and, in turn, the
type of <a href="../Reflection_Models/BSDF_Representation.html#BxDF"><tt>BxDF</tt></a> that each material uses for the <a href="../Reflection_Models/BSDF_Representation.html#BSDF"><tt>BSDF</tt></a> it returns.  Starting
from a ray&ndash;shape intersection, a surface-scattering kernel handles
everything from normal and bump mapping to material evaluation, light and
BSDF sampling, and queuing up shadow and indirect rays for later processing.

</p>
<p>All of this starts with the <tt>Render()</tt> method calling
<tt>EvaluateMaterialsAndBSDFs()</tt>, which is implemented in
<a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/wavefront/surfscatter.cpp"><tt>wavefront/surfscatter.cpp</tt></a>.  With this method&rsquo;s implementation,
we encounter a new idiom that orchestrates the kernel launches: a call to
<a href="../Utilities/Containers_and_Memory_Management.html#ForEachType"><tt>ForEachType()</tt></a>.  In its use here, that function iterates over all of
the types that a <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#Material"><tt>Material</tt></a> could be and calls a callback function
for each one of them.  Thus, if <tt>pbrt</tt> is extended with an additional
material, adding that one to the list of materials that <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#Material"><tt>Material</tt></a>
passes to the <a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer"><tt>TaggedPointer</tt></a> that it inherits from in its declaration
in <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/base/material.h"><tt>base/material.h</tt></a> automatically leads to a specialized kernel
for that material being generated here.

</p>
<p></p>
<span class="anchor" id="fragment-WavefrontPathIntegratorSurfaceScatteringMethods-0"></span><div class="fragmentname">&lt;&lt;WavefrontPathIntegrator Surface Scattering Methods&gt;&gt;=&nbsp;<a href="#fragment-WavefrontPathIntegratorSurfaceScatteringMethods-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">void <span class="anchor" id="WavefrontPathIntegrator::EvaluateMaterialsAndBSDFs"></span>WavefrontPathIntegrator::EvaluateMaterialsAndBSDFs(
        int wavefrontDepth) {
    <a href="../Utilities/Containers_and_Memory_Management.html#ForEachType" class="code">ForEachType</a>(EvaluateMaterialCallback{wavefrontDepth, this},
                <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#Material" class="code">Material</a>::<a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer::Types" class="code">Types</a>());
}</div><p>


</p>
<p>A lambda function is not sufficient to pass to <tt>ForEachType()</tt>, as it
does not pass a value of the given type to the callback but instead
invokes its function call operator, passing the type for use in a template
specialization.  Therefore, we wrap the values needed for the material
evaluation method call in a small structure.

</p>
<p></p>
<span class="anchor" id="fragment-EvaluateMaterialCallbackDefinition-0"></span><div class="fragmentname">&lt;&lt;EvaluateMaterialCallback Definition&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">struct <span class="anchor" id="EvaluateMaterialCallback"></span>EvaluateMaterialCallback {
    int <span class="anchor" id="EvaluateMaterialCallback::wavefrontDepth"></span>wavefrontDepth;
    WavefrontPathIntegrator *<span class="anchor" id="EvaluateMaterialCallback::integrator"></span>integrator;
    &lt;&lt;<span class="fragmentname"><a href="#fragment-EvaluateMaterialCallbackPublicMethods-0">EvaluateMaterialCallback Public Methods</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2500" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2500"><i></i></a><div id="fragbit-2500" class="collapse"><div class="fragmentcode">       template &lt;typename ConcreteMaterial&gt;
       void operator()() {
           if constexpr (!std::is_same_v&lt;ConcreteMaterial, <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#MixMaterial" class="code">MixMaterial</a>&gt;)
               integrator-&gt;<a href="#WavefrontPathIntegrator::EvaluateMaterialAndBSDF" class="code">EvaluateMaterialAndBSDF</a>&lt;ConcreteMaterial&gt;(wavefrontDepth);
       }</div></div>
};</div><p>


</p>
<p><tt>ForEachType()</tt> invokes the following method for each type of
material.  We skip over the <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#MixMaterial"><tt>MixMaterial</tt></a> here, since all instances of
it are resolved to one of the other material types before being enqueued
for the surface-shading kernels.  (See
Section&nbsp;<a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#sec:material-implementations">10.5.1</a> for a discussion of this detail
of <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#MixMaterial"><tt>MixMaterial</tt></a>&rsquo;s usage.)

</p>
<p></p>
<span class="anchor" id="fragment-EvaluateMaterialCallbackPublicMethods-0"></span><div class="fragmentname">&lt;&lt;EvaluateMaterialCallback Public Methods&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">template &lt;typename ConcreteMaterial&gt;
void operator()() {
    if constexpr (!std::is_same_v&lt;ConcreteMaterial, <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#MixMaterial" class="code">MixMaterial</a>&gt;)
        integrator-&gt;<a href="#WavefrontPathIntegrator::EvaluateMaterialAndBSDF" class="code">EvaluateMaterialAndBSDF</a>&lt;ConcreteMaterial&gt;(wavefrontDepth);
}</div><p>


</p>
<p>The <tt>EvaluateMaterialAndBSDF()</tt> method does not yet bring us to the
point of launching kernels&mdash;two considerations are handled beforehand.
First, the implementation skips launching the specialized
<tt>EvaluateMaterialAndBSDF()</tt> method for any material types that are not
present in the scene.  Such work queues will have no entries, so there is
no reason to bother with them.  This is handled using two arrays,
<tt>haveBasicEvalMaterial</tt><span class="anchor" id="WavefrontPathIntegrator::haveBasicEvalMaterial"></span>
and
<tt>haveUniversalEvalMaterial</tt><span class="anchor" id="WavefrontPathIntegrator::haveUniversalEvalMaterial"></span>,
that are initialized in the <a href="#WavefrontPathIntegrator"><tt>WavefrontPathIntegrator</tt></a> constructor.
(The two further distinguish the materials based on the complexity of their
textures, which is a topic that will be discussed immediately after the
following fragment.)  Both arrays are indexed using the <a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer"><tt>TaggedPointer</tt></a>
<tt>TypeIndex()</tt> method, which returns an integer index for each
representable type.

</p>
<p></p>
<span class="anchor" id="fragment-WavefrontPathIntegratorSurfaceScatteringMethods-1"></span><div class="fragmentname">&lt;&lt;WavefrontPathIntegrator Surface Scattering Methods&gt;&gt;+=&nbsp;<a href="#fragment-WavefrontPathIntegratorSurfaceScatteringMethods-0"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-WavefrontPathIntegratorSurfaceScatteringMethods-2"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">template &lt;typename ConcreteMaterial&gt;
void <span class="anchor" id="WavefrontPathIntegrator::EvaluateMaterialAndBSDF"></span>WavefrontPathIntegrator::EvaluateMaterialAndBSDF(int wavefrontDepth) {
    int index = <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#Material" class="code">Material</a>::<a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer::TypeIndex" class="code">TypeIndex</a>&lt;ConcreteMaterial&gt;();
    if (<a href="#WavefrontPathIntegrator::haveBasicEvalMaterial" class="code">haveBasicEvalMaterial</a>[index])
        EvaluateMaterialAndBSDF&lt;ConcreteMaterial, BasicTextureEvaluator&gt;(
                                  <a href="#WavefrontPathIntegrator::basicEvalMaterialQueue" class="code">basicEvalMaterialQueue</a>, wavefrontDepth);
    if (<a href="#WavefrontPathIntegrator::haveUniversalEvalMaterial" class="code">haveUniversalEvalMaterial</a>[index])
        EvaluateMaterialAndBSDF&lt;ConcreteMaterial, UniversalTextureEvaluator&gt;(
                                  <a href="#WavefrontPathIntegrator::universalEvalMaterialQueue" class="code">universalEvalMaterialQueue</a>, wavefrontDepth);
}</div><p>


</p>
<p>The <a href="#WavefrontPathIntegrator"><tt>WavefrontPathIntegrator</tt></a> maintains two work queues for materials,
partitioning them based on the complexity of their textures. Each queue is a
<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue"><tt>MultiWorkQueue</tt></a> with one entry for each material type.

</p>
<p></p>
<span class="anchor" id="fragment-WavefrontPathIntegratorMemberVariables-9"></span><div class="fragmentname">&lt;&lt;WavefrontPathIntegrator Member Variables&gt;&gt;+=&nbsp;<a href="#fragment-WavefrontPathIntegratorMemberVariables-8"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-WavefrontPathIntegratorMemberVariables-10"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">MaterialEvalQueue *<span class="anchor" id="WavefrontPathIntegrator::basicEvalMaterialQueue"></span>basicEvalMaterialQueue = nullptr;
MaterialEvalQueue *<span class="anchor" id="WavefrontPathIntegrator::universalEvalMaterialQueue"></span>universalEvalMaterialQueue = nullptr;</div><p>


</p>
<p>These give two more queues to add to the ones that are reset at the start
of tracing rays at each wavefront depth.

</p>
<p></p>
<span class="anchor" id="fragment-Resetqueuesbeforetracingnextbatchofrays-1"></span><div class="fragmentname">&lt;&lt;Reset queues before tracing next batch of rays&gt;&gt;+=&nbsp;<a href="#fragment-Resetqueuesbeforetracingnextbatchofrays-0"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode"><a href="#WavefrontPathIntegrator::basicEvalMaterialQueue" class="code">basicEvalMaterialQueue</a>-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue::Reset" class="code">Reset</a>();
<a href="#WavefrontPathIntegrator::universalEvalMaterialQueue" class="code">universalEvalMaterialQueue</a>-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue::Reset" class="code">Reset</a>();</div><p>


</p>
<p>Before continuing into the <tt>EvaluateMaterialAndBSDF()</tt> template
specialization, we will detour to discuss texture evaluation in the
wavefront integrator in more detail.  Recall that when the <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#Material"><tt>Material</tt></a>
interface was introduced in Section&nbsp;<a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#sec:material-interface">10.5</a>, it
included the notion of a <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#TextureEvaluator"><tt>TextureEvaluator</tt></a>.  Methods like
<tt>GetBxDF()</tt> and
<tt>GetBSSRDF()</tt> were templated on this
type, took an instance of it as a parameter, and used it to evaluate textures
rather than calling their <tt>Evaluate()</tt> methods directly.

</p>
<p>There was no point in doing that for CPU rendering: there, a
<a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#UniversalTextureEvaluator"><tt>UniversalTextureEvaluator</tt></a> is always used. It immediately forwards
texture evaluation requests on to the textures.  <tt>pbrt</tt>&rsquo;s full set of
textures spans a wide range of complexity, however, ranging from
trivial constant textures that return a fixed value to complex textures
that evaluate noise functions to ones like <a href="../Textures_and_Materials/Texture_Interface_and_Basic_Textures.html#SpectrumMixTexture"><tt>SpectrumMixTexture</tt></a> that
themselves recursively evaluate other textures.

</p>
<p>Not only do more complex textures require more registers on the GPU, but
the potential for unbounded recursion from the mixture textures requires
that the compiler allocate resources to be prepared for that case.  In
turn, the performance of evaluating the simpler textures can be harmed due
to choices the compiler has made for the more complex ones.
Because the simpler textures are common, it is thus
worthwhile to separate materials according to the complexity of their
textures and to have separate kernels for the materials that only use the
simpler ones.<button style="button" data-toggle="tooltip" data-placement="right" data-html="true" class="btn footnote-button" title="We have found that this partitioning of texture
evaluation work can give as much as a 20% improvement in
rendering performance on current GPUs.">
      <sup>&dagger;</sup>
    </button>
		  
Doing so can give further benefits from reducing control flow divergence.
The following
<a href="#BasicTextureEvaluator"><tt>BasicTextureEvaluator</tt></a> class helps with this task.

</p>
<p></p>
<span class="anchor" id="fragment-BasicTextureEvaluatorDefinition-0"></span><div class="fragmentname">&lt;&lt;BasicTextureEvaluator Definition&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">class <span class="anchor" id="BasicTextureEvaluator"></span>BasicTextureEvaluator {
  public:
    &lt;&lt;<span class="fragmentname"><a href="#fragment-BasicTextureEvaluatorPublicMethods-0">BasicTextureEvaluator Public Methods</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2501" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2501"><i></i></a><div id="fragbit-2501" class="collapse"><div class="fragmentcode">       bool CanEvaluate(std::initializer_list&lt;<a href="../Textures_and_Materials/Texture_Interface_and_Basic_Textures.html#FloatTexture" class="code">FloatTexture</a>&gt; ftex,
                        std::initializer_list&lt;<a href="../Textures_and_Materials/Texture_Interface_and_Basic_Textures.html#SpectrumTexture" class="code">SpectrumTexture</a>&gt; stex) const {
           &lt;&lt;<span class="fragmentname"><a href="#fragment-ReturnmonofalseifanymonoFloatTexturescannotbeevaluated-0">Return <tt>false</tt> if any <tt>FloatTexture</tt>s cannot be evaluated</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2502" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2502"><i></i></a><div id="fragbit-2502" class="collapse"><div class="fragmentcode">              for (<a href="../Textures_and_Materials/Texture_Interface_and_Basic_Textures.html#FloatTexture" class="code">FloatTexture</a> f : ftex)
                  if (f &amp;&amp; !f.<a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer::Is" class="code">Is</a>&lt;<a href="../Textures_and_Materials/Texture_Interface_and_Basic_Textures.html#FloatConstantTexture" class="code">FloatConstantTexture</a>&gt;() &amp;&amp; !f.<a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer::Is" class="code">Is</a>&lt;<a href="../Textures_and_Materials/Image_Texture.html#FloatImageTexture" class="code">FloatImageTexture</a>&gt;() &amp;&amp;
                      !f.<a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer::Is" class="code">Is</a>&lt;<a href="#GPUFloatImageTexture" class="code">GPUFloatImageTexture</a>&gt;())
                      return false;</div></div>
           &lt;&lt;<span class="fragmentname">Return <tt>false</tt> if any <tt>SpectrumTexture</tt>s cannot be evaluated</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2503" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2503"><i></i></a><div id="fragbit-2503" class="collapse"><div class="fragmentcode">              for (<a href="../Textures_and_Materials/Texture_Interface_and_Basic_Textures.html#SpectrumTexture" class="code">SpectrumTexture</a> s : stex)
                      if (s &amp;&amp; !s.<a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer::Is" class="code">Is</a>&lt;SpectrumConstantTexture&gt;() &amp;&amp;
                          !s.<a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer::Is" class="code">Is</a>&lt;SpectrumImageTexture&gt;() &amp;&amp;
                          !s.<a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer::Is" class="code">Is</a>&lt;GPUSpectrumImageTexture&gt;())
                          return false;</div></div>
           return true;
       }
       Float operator()(<a href="../Textures_and_Materials/Texture_Interface_and_Basic_Textures.html#FloatTexture" class="code">FloatTexture</a> tex, <a href="../Textures_and_Materials/Texture_Coordinate_Generation.html#TextureEvalContext" class="code">TextureEvalContext</a> ctx) {
           if (tex.<a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer::Is" class="code">Is</a>&lt;<a href="../Textures_and_Materials/Texture_Interface_and_Basic_Textures.html#FloatConstantTexture" class="code">FloatConstantTexture</a>&gt;())
               return tex.<a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer::Cast" class="code">Cast</a>&lt;<a href="../Textures_and_Materials/Texture_Interface_and_Basic_Textures.html#FloatConstantTexture" class="code">FloatConstantTexture</a>&gt;()-&gt;<a href="../Textures_and_Materials/Texture_Interface_and_Basic_Textures.html#FloatTexture::Evaluate" class="code">Evaluate</a>(ctx);
           else if (tex.<a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer::Is" class="code">Is</a>&lt;<a href="../Textures_and_Materials/Image_Texture.html#FloatImageTexture" class="code">FloatImageTexture</a>&gt;())
               return tex.<a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer::Cast" class="code">Cast</a>&lt;<a href="../Textures_and_Materials/Image_Texture.html#FloatImageTexture" class="code">FloatImageTexture</a>&gt;()-&gt;<a href="../Textures_and_Materials/Texture_Interface_and_Basic_Textures.html#FloatTexture::Evaluate" class="code">Evaluate</a>(ctx);
           else if (tex.<a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer::Is" class="code">Is</a>&lt;<a href="#GPUFloatImageTexture" class="code">GPUFloatImageTexture</a>&gt;())
               return tex.<a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer::Cast" class="code">Cast</a>&lt;<a href="#GPUFloatImageTexture" class="code">GPUFloatImageTexture</a>&gt;()-&gt;<a href="../Textures_and_Materials/Texture_Interface_and_Basic_Textures.html#FloatTexture::Evaluate" class="code">Evaluate</a>(ctx);
           else
               return 0.f;
       }
       <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> operator()(<a href="../Textures_and_Materials/Texture_Interface_and_Basic_Textures.html#SpectrumTexture" class="code">SpectrumTexture</a> tex, <a href="../Textures_and_Materials/Texture_Coordinate_Generation.html#TextureEvalContext" class="code">TextureEvalContext</a> ctx,
                                  <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> lambda) {
           if (tex.<a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer::Is" class="code">Is</a>&lt;SpectrumConstantTexture&gt;())
               return tex.<a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer::Cast" class="code">Cast</a>&lt;SpectrumConstantTexture&gt;()-&gt;<a href="../Textures_and_Materials/Texture_Interface_and_Basic_Textures.html#FloatTexture::Evaluate" class="code">Evaluate</a>(ctx, lambda);
           else if (tex.<a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer::Is" class="code">Is</a>&lt;SpectrumImageTexture&gt;())
               return tex.<a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer::Cast" class="code">Cast</a>&lt;SpectrumImageTexture&gt;()-&gt;<a href="../Textures_and_Materials/Texture_Interface_and_Basic_Textures.html#FloatTexture::Evaluate" class="code">Evaluate</a>(ctx, lambda);
           else if (tex.<a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer::Is" class="code">Is</a>&lt;GPUSpectrumImageTexture&gt;())
                return tex.<a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer::Cast" class="code">Cast</a>&lt;GPUSpectrumImageTexture&gt;()-&gt;<a href="../Textures_and_Materials/Texture_Interface_and_Basic_Textures.html#FloatTexture::Evaluate" class="code">Evaluate</a>(ctx, lambda);
           else
               return <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a>(0.f);
       }</div></div>
};</div><p>


</p>
<p>We will categorize constant textures and plain image map textures as
&ldquo;basic.&rdquo;  Thus, the <tt>BasicTextureEvaluator</tt>&rsquo;s <tt>CanEvaluate()</tt>
method iterates over all provided textures and checks that each
is one of those types.  When material evaluation work is to be enqueued
in the <a href="#EnqueueWorkAfterIntersection"><tt>EnqueueWorkAfterIntersection()</tt></a> function, the material&rsquo;s
<a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#Material::CanEvaluateTextures"><tt>Material::CanEvaluateTextures()</tt></a> method is called with a
<a href="#BasicTextureEvaluator"><tt>BasicTextureEvaluator</tt></a> to determine whether the work is valid for the
basic material evaluation queues.  If not, it goes on the appropriate
<tt>universalEvalMaterialQueue</tt>.

</p>
<p></p>
<span class="anchor" id="fragment-BasicTextureEvaluatorPublicMethods-0"></span><div class="fragmentname">&lt;&lt;BasicTextureEvaluator Public Methods&gt;&gt;=&nbsp;<a href="#fragment-BasicTextureEvaluatorPublicMethods-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">bool <span class="anchor" id="BasicTextureEvaluator::CanEvaluate"></span>CanEvaluate(std::initializer_list&lt;<a href="../Textures_and_Materials/Texture_Interface_and_Basic_Textures.html#FloatTexture" class="code">FloatTexture</a>&gt; ftex,
                 std::initializer_list&lt;<a href="../Textures_and_Materials/Texture_Interface_and_Basic_Textures.html#SpectrumTexture" class="code">SpectrumTexture</a>&gt; stex) const {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-ReturnmonofalseifanymonoFloatTexturescannotbeevaluated-0">Return <tt>false</tt> if any <tt>FloatTexture</tt>s cannot be evaluated</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2504" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2504"><i></i></a><div id="fragbit-2504" class="collapse"><div class="fragmentcode">       for (<a href="../Textures_and_Materials/Texture_Interface_and_Basic_Textures.html#FloatTexture" class="code">FloatTexture</a> f : ftex)
           if (f &amp;&amp; !f.<a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer::Is" class="code">Is</a>&lt;<a href="../Textures_and_Materials/Texture_Interface_and_Basic_Textures.html#FloatConstantTexture" class="code">FloatConstantTexture</a>&gt;() &amp;&amp; !f.<a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer::Is" class="code">Is</a>&lt;<a href="../Textures_and_Materials/Image_Texture.html#FloatImageTexture" class="code">FloatImageTexture</a>&gt;() &amp;&amp;
               !f.<a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer::Is" class="code">Is</a>&lt;<a href="#GPUFloatImageTexture" class="code">GPUFloatImageTexture</a>&gt;())
               return false;</div></div>
    &lt;&lt;<span class="fragmentname">Return <tt>false</tt> if any <tt>SpectrumTexture</tt>s cannot be evaluated</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2505" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2505"><i></i></a><div id="fragbit-2505" class="collapse"><div class="fragmentcode">       for (<a href="../Textures_and_Materials/Texture_Interface_and_Basic_Textures.html#SpectrumTexture" class="code">SpectrumTexture</a> s : stex)
               if (s &amp;&amp; !s.<a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer::Is" class="code">Is</a>&lt;SpectrumConstantTexture&gt;() &amp;&amp;
                   !s.<a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer::Is" class="code">Is</a>&lt;SpectrumImageTexture&gt;() &amp;&amp;
                   !s.<a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer::Is" class="code">Is</a>&lt;GPUSpectrumImageTexture&gt;())
                   return false;</div></div>
    return true;
}</div><p>


</p>
<p>The texture types are easily checked with the <a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer::Is"><tt>TaggedPointer::Is()</tt></a>
method. (The scene initialization code creates instances of
<tt>GPUFloatImageTexture</tt><span class="anchor" id="GPUFloatImageTexture"></span> in place of <a href="../Textures_and_Materials/Image_Texture.html#FloatImageTexture"><tt>FloatImageTexture</tt></a>s when GPU
rendering is being used.  That class uses platform-specific functionality
to perform filtered texture look-ups more efficiently than executing
<a href="../Utilities/Images.html#Image"><tt>Image</tt></a> methods would.
<a href="#GPUSpectrumImageTexture"><tt>GPUSpectrumImageTexture</tt></a><span class="anchor" id="GPUSpectrumImageTexture"></span> follows
equivalently.)

</p>
<p></p>
<span class="anchor" id="fragment-ReturnmonofalseifanymonoFloatTexturescannotbeevaluated-0"></span><div class="fragmentname">&lt;&lt;Return <tt>false</tt> if any <tt>FloatTexture</tt>s cannot be evaluated&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">for (<a href="../Textures_and_Materials/Texture_Interface_and_Basic_Textures.html#FloatTexture" class="code">FloatTexture</a> f : ftex)
    if (f &amp;&amp; !f.<a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer::Is" class="code">Is</a>&lt;<a href="../Textures_and_Materials/Texture_Interface_and_Basic_Textures.html#FloatConstantTexture" class="code">FloatConstantTexture</a>&gt;() &amp;&amp; !f.<a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer::Is" class="code">Is</a>&lt;<a href="../Textures_and_Materials/Image_Texture.html#FloatImageTexture" class="code">FloatImageTexture</a>&gt;() &amp;&amp;
        !f.<a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer::Is" class="code">Is</a>&lt;<a href="#GPUFloatImageTexture" class="code">GPUFloatImageTexture</a>&gt;())
        return false;</div><p>


</p>
<p>The corresponding fragment for <a href="../Textures_and_Materials/Texture_Interface_and_Basic_Textures.html#SpectrumTexture"><tt>SpectrumTexture</tt></a>s is equivalent and is
therefore not included here.

</p>
<p>

</p>
<p>The implementation of the <tt>TextureEvaluator</tt> evaluation
method is key to the efficiency benefits provided by this approach.  It
would do no good to sort materials based on their textures but to then use
<tt>pbrt</tt>&rsquo;s regular dynamic dispatch mechanism for texture evaluation: in that
case, the compiler would have no insight into the fact that the texture
being passed to it must be one of the simple types accepted by
<tt>CanEvaluate()</tt>.

</p>
<p>Therefore, the evaluation method instead tries casting the texture to each
of the supported types until it finds the correct one.  It then calls the
corresponding evaluation method directly.  In this way, the compiler can
easily tell that the only texture evaluation methods that might be called
are those for <a href="../Textures_and_Materials/Texture_Interface_and_Basic_Textures.html#FloatConstantTexture"><tt>FloatConstantTexture</tt></a>, <a href="../Textures_and_Materials/Image_Texture.html#FloatImageTexture"><tt>FloatImageTexture</tt></a>, and
<a href="#GPUFloatImageTexture"><tt>GPUFloatImageTexture</tt></a>, and it does not need to worry about resource
allocation for evaluating the more complex texture types.

</p>
<p></p>
<span class="anchor" id="fragment-BasicTextureEvaluatorPublicMethods-1"></span><div class="fragmentname">&lt;&lt;BasicTextureEvaluator Public Methods&gt;&gt;+=&nbsp;<a href="#fragment-BasicTextureEvaluatorPublicMethods-0"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode">Float <span class="anchor" id="BasicTextureEvaluator::operator"></span>operator()(<a href="../Textures_and_Materials/Texture_Interface_and_Basic_Textures.html#FloatTexture" class="code">FloatTexture</a> tex, <a href="../Textures_and_Materials/Texture_Coordinate_Generation.html#TextureEvalContext" class="code">TextureEvalContext</a> ctx) {
    if (tex.<a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer::Is" class="code">Is</a>&lt;<a href="../Textures_and_Materials/Texture_Interface_and_Basic_Textures.html#FloatConstantTexture" class="code">FloatConstantTexture</a>&gt;())
        return tex.<a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer::Cast" class="code">Cast</a>&lt;<a href="../Textures_and_Materials/Texture_Interface_and_Basic_Textures.html#FloatConstantTexture" class="code">FloatConstantTexture</a>&gt;()-&gt;<a href="../Textures_and_Materials/Texture_Interface_and_Basic_Textures.html#FloatTexture::Evaluate" class="code">Evaluate</a>(ctx);
    else if (tex.<a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer::Is" class="code">Is</a>&lt;<a href="../Textures_and_Materials/Image_Texture.html#FloatImageTexture" class="code">FloatImageTexture</a>&gt;())
        return tex.<a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer::Cast" class="code">Cast</a>&lt;<a href="../Textures_and_Materials/Image_Texture.html#FloatImageTexture" class="code">FloatImageTexture</a>&gt;()-&gt;<a href="../Textures_and_Materials/Texture_Interface_and_Basic_Textures.html#FloatTexture::Evaluate" class="code">Evaluate</a>(ctx);
    else if (tex.<a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer::Is" class="code">Is</a>&lt;<a href="#GPUFloatImageTexture" class="code">GPUFloatImageTexture</a>&gt;())
        return tex.<a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer::Cast" class="code">Cast</a>&lt;<a href="#GPUFloatImageTexture" class="code">GPUFloatImageTexture</a>&gt;()-&gt;<a href="../Textures_and_Materials/Texture_Interface_and_Basic_Textures.html#FloatTexture::Evaluate" class="code">Evaluate</a>(ctx);
    else
        return 0.f;
}</div><p>


</p>
<p>The evaluation method for spectrum textures is similar and therefore not
included here.

</p>
<p>With the motivation for the <a href="#BasicTextureEvaluator"><tt>BasicTextureEvaluator</tt></a> explained, it is
possible to better understand why <a href="../Textures_and_Materials/Image_Texture.html#ImageTextureBase"><tt>ImageTextureBase</tt></a> in
Section&nbsp;<a href="../Textures_and_Materials/Image_Texture.html#sec:texture-caching">10.4.1</a> offers <tt>scale</tt> and <tt>invert</tt>
parameters even though scale and mix textures could be used to achieve the
same results.  With that capability directly available in textures that can
be evaluated by the <a href="#BasicTextureEvaluator"><tt>BasicTextureEvaluator</tt></a>, the
<a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#UniversalTextureEvaluator"><tt>UniversalTextureEvaluator</tt></a> can be invoked less often.  <tt>pbrt</tt> actually
has a texture rewriting pass that, for example, converts a scale texture
with a constant scale applied to an image texture to just an image texture,
configured to apply that scale itself.  (See, for example, the
<tt>SpectrumScaledTexture::Create()</tt> method implementation for details.)

</p>
<p>

</p>
<p>The following definition of the <tt>MaterialEvalQueue</tt> type is admittedly
complex.  However, it is another key to <tt>pbrt</tt>&rsquo;s extensibility.  For
material and BSDF evaluation, we would like to have a <a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue"><tt>MultiWorkQueue</tt></a>
where there is a separate queue for each type of <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#Material"><tt>Material</tt></a> that <tt>pbrt</tt> supports, where the type of the work items is the template class
<a href="#MaterialEvalWorkItem"><tt>MaterialEvalWorkItem</tt></a>, specialized with each material type.  While we
could enumerate all the currently supported materials in template
parameters, to do so would mean that adding a new material to the system
would require editing an obscure part of the wavefront integrator
implementation for it to be available there as well.

</p>
<p>Therefore, we go through some gymnastics in order to define the type of the
<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue"><tt>MultiWorkQueue</tt></a> automatically.  First, the <a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer"><tt>TaggedPointer</tt></a> type
that <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#Material"><tt>Material</tt></a> inherits from includes a type declaration,
<tt>Types</tt>, that holds a <a href="../Utilities/Containers_and_Memory_Management.html#TypePack"><tt>TypePack</tt></a> of all types that the
pointer can represent.  We then use the <a href="../Utilities/Containers_and_Memory_Management.html#MapType"><tt>MapType</tt></a> functionality from
Section&nbsp;<a href="../Utilities/Containers_and_Memory_Management.html#sec:type-pack">A.4.3</a> to wrap each material type inside the
forthcoming <a href="#MaterialEvalWorkItem"><tt>MaterialEvalWorkItem</tt></a> template class.  This gives us the final
<a href="../Utilities/Containers_and_Memory_Management.html#TypePack"><tt>TypePack</tt></a> of types to provide to <tt>MultiWorkQueue</tt>.

</p>
<p></p>
<span class="anchor" id="fragment-MaterialEvalQueueDefinition-0"></span><div class="fragmentname">&lt;&lt;MaterialEvalQueue Definition&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">using <span class="anchor" id="MaterialEvalQueue"></span>MaterialEvalQueue =
    <a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue" class="code">MultiWorkQueue</a>&lt;typename <a href="../Utilities/Containers_and_Memory_Management.html#MapType" class="code">MapType</a>&lt;<a href="#MaterialEvalWorkItem" class="code">MaterialEvalWorkItem</a>,
                                    typename <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#Material" class="code">Material</a>::<a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer::Types" class="code">Types</a>&gt;::type&gt;;</div><p>


</p>
<p></p>
<span class="anchor" id="fragment-MaterialEvalWorkItemDefinition-0"></span><div class="fragmentname">&lt;&lt;MaterialEvalWorkItem Definition&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">template &lt;typename ConcreteMaterial&gt;
struct <span class="anchor" id="MaterialEvalWorkItem"></span>MaterialEvalWorkItem {
    &lt;&lt;<span class="fragmentname">MaterialEvalWorkItem Public Methods</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2506" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2506"><i></i></a><div id="fragbit-2506" class="collapse"><div class="fragmentcode">       PBRT_CPU_GPU
       NormalBumpEvalContext GetNormalBumpEvalContext(Float dudx, Float dudy, Float dvdx, Float dvdy) const {
           NormalBumpEvalContext ctx;
           ctx.p = <a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a>(pi);
           ctx.uv = uv;
           ctx.dudx = dudx;
           ctx.dudy = dudy;
           ctx.dvdx = dvdx;
           ctx.dvdy = dvdy;
           ctx.shading.n = ns;
           ctx.shading.dpdu = dpdus;
           ctx.shading.dpdv = dpdvs;
           ctx.shading.dndu = dndus;
           ctx.shading.dndv = dndvs;
           ctx.faceIndex = faceIndex;
           return ctx;
       }
       
       PBRT_CPU_GPU
       <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#MaterialEvalContext" class="code">MaterialEvalContext</a> GetMaterialEvalContext(Float dudx, Float dudy, Float dvdx, Float dvdy, <a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a> ns, <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> dpdus) const {
           <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#MaterialEvalContext" class="code">MaterialEvalContext</a> ctx;
           ctx.wo = wo;
           ctx.n = n;
           ctx.ns = ns;
           ctx.dpdus = dpdus;
           ctx.p = <a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a>(pi);
           ctx.uv = uv;
           ctx.dudx = dudx;
           ctx.dudy = dudy;
           ctx.dvdx = dvdx;
           ctx.dvdy = dvdy;
           ctx.faceIndex = faceIndex;
           return ctx;
       }</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-MaterialEvalWorkItemPublicMembers-0">MaterialEvalWorkItem Public Members</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2507" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2507"><i></i></a><div id="fragbit-2507" class="collapse"><div class="fragmentcode">       const ConcreteMaterial *material;
       Point3fi pi;
       <a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a> n;
       <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> dpdu, dpdv;
       Float time;
       int depth;
       <a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a> ns;
       <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> dpdus, dpdvs;
       <a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a> dndus, dndvs;
       <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a> uv;
       <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> lambda;
       int pixelIndex;
       int anyNonSpecularBounces;
       <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> wo;
       <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> beta, r_u;
       Float etaScale;
       <a href="../Volume_Scattering/Media.html#MediumInterface" class="code">MediumInterface</a> mediumInterface;</div></div>
};</div><p>


</p>
<p>It is crucial to have a pointer to the material in <a href="#MaterialEvalWorkItem"><tt>MaterialEvalWorkItem</tt></a>.
Note that this can be a pointer to a concrete material type such as
<a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#DiffuseMaterial"><tt>DiffuseMaterial</tt></a> due to <a href="#MaterialEvalWorkItem"><tt>MaterialEvalWorkItem</tt></a> being a template
class on the <tt>ConcreteMaterial</tt> type.  (We will introduce the rest of
the member variables of the <a href="#MaterialEvalWorkItem"><tt>MaterialEvalWorkItem</tt></a> as they are used in
code in the remainder of the section.)

</p>
<p></p>
<span class="anchor" id="fragment-MaterialEvalWorkItemPublicMembers-0"></span><div class="fragmentname">&lt;&lt;MaterialEvalWorkItem Public Members&gt;&gt;=&nbsp;<a href="#fragment-MaterialEvalWorkItemPublicMembers-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">const ConcreteMaterial *<span class="anchor" id="MaterialEvalWorkItem::material"></span>material;</div><p>


</p>
<p>With this context in hand, we can proceed to the implementation of the
<tt>EvaluateMaterialAndBSDF()</tt> method.  It is parameterized both by the
concrete type of material that is being evaluated and by a
<a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#TextureEvaluator"><tt>TextureEvaluator</tt></a>, which allows us to generate specializations based
not only on material but also on the two types of <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#TextureEvaluator"><tt>TextureEvaluator</tt></a>.

</p>
<p></p>
<span class="anchor" id="fragment-WavefrontPathIntegratorSurfaceScatteringMethods-2"></span><div class="fragmentname">&lt;&lt;WavefrontPathIntegrator Surface Scattering Methods&gt;&gt;+=&nbsp;<a href="#fragment-WavefrontPathIntegratorSurfaceScatteringMethods-1"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode">template &lt;typename ConcreteMaterial, typename <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#TextureEvaluator" class="code">TextureEvaluator</a>&gt;
void WavefrontPathIntegrator::EvaluateMaterialAndBSDF(
        MaterialEvalQueue *evalQueue, int wavefrontDepth) {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-GetBSDFforitemsinmonoevalQueueandsampleillumination-0">Get BSDF for items in <tt>evalQueue</tt> and sample illumination</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2508" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2508"><i></i></a><div id="fragbit-2508" class="collapse"><div class="fragmentcode">       &lt;&lt;<span class="fragmentname">Construct <tt>desc</tt> for material/texture evaluation kernel</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2509" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2509"><i></i></a><div id="fragbit-2509" class="collapse"><div class="fragmentcode">          std::string desc = <a href="../Utilities/User_Interaction.html#StringPrintf" class="code">StringPrintf</a>(
              "%s + <a href="../Reflection_Models/BSDF_Representation.html#BxDF" class="code">BxDF</a> eval (%s tex)", ConcreteMaterial::Name(),
              std::is_same_v&lt;<a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#TextureEvaluator" class="code">TextureEvaluator</a>, BasicTextureEvaluator&gt; ? "Basic" : "Universal");</div></div>
       <a href="#RayQueue" class="code">RayQueue</a> *nextRayQueue = <a href="#WavefrontPathIntegrator::NextRayQueue" class="code">NextRayQueue</a>(wavefrontDepth);
       auto queue = evalQueue-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue::Get" class="code">Get</a>&lt;MaterialEvalWorkItem&lt;ConcreteMaterial&gt;&gt;();
       <a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#ForAllQueued" class="code">ForAllQueued</a>(desc.c_str(), queue, <a href="#WavefrontPathIntegrator::maxQueueSize" class="code">maxQueueSize</a>,
           PBRT_CPU_GPU_LAMBDA (const MaterialEvalWorkItem&lt;ConcreteMaterial&gt; w) {
               &lt;&lt;<span class="fragmentname"><a href="#fragment-EvaluatematerialandBSDFforrayintersection-0">Evaluate material and BSDF for ray intersection</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2510" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2510"><i></i></a><div id="fragbit-2510" class="collapse"><div class="fragmentcode">                  <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#TextureEvaluator" class="code">TextureEvaluator</a> texEval;
                  &lt;&lt;<span class="fragmentname"><a href="#fragment-Computedifferentialsforpositionanduvatintersectionpoint-0">Compute differentials for position and <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.301ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 2282.2 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">left-parenthesis u comma v right-parenthesis</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-28" d="M332 -238c0 -5 -5 -10 -10 -10c-2 0 -4 1 -6 2c-110 83 -215 283 -215 454v84c0 171 105 371 215 454c2 1 4 2 6 2c5 0 10 -5 10 -10c0 -3 -2 -6 -4 -8c-104 -78 -173 -278 -173 -438v-84c0 -160 69 -360 173 -438c2 -2 4 -5 4 -8Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D462" d="M543 143c0 0 -13 -63 -30 -99c-16 -32 -39 -55 -74 -55c-43 0 -78 26 -89 67c-17 -22 -53 -67 -119 -67c-54 0 -123 25 -123 120c0 49 21 111 58 210c6 15 17 44 17 68c0 32 -16 33 -25 33c-38 0 -76 -37 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10 c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -17 -63c-26 -69 -54 -148 -54 -204c0 -37 10 -82 62 -82c73 0 113 80 114 84l75 301c8 34 34 35 39 35c15 0 29 -9 29 -27c0 -6 -10 -44 -15 -67c-4 -15 -14 -53 -17 -68l-28 -108c-8 -35 -20 -82 -20 -104 c0 -33 10 -46 31 -46c42 0 61 68 75 124c3 14 4 18 14 18c3 0 12 0 12 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2C" d="M203 1c0 -117 -80 -194 -91 -194c-5 0 -10 4 -10 11c0 3 0 5 11 16c33 33 68 93 68 167c0 14 -2 15 -2 15s-2 -1 -5 -3c-10 -9 -23 -13 -35 -13c-33 0 -53 26 -53 53c0 28 20 53 53 53c39 0 64 -39 64 -105Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D463" d="M468 372c0 -52 -57 -383 -225 -383c-46 0 -134 16 -134 124c0 43 13 89 57 205c7 18 17 45 17 70c0 32 -17 32 -25 32c-29 0 -72 -23 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 38 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -12 -50 c-31 -83 -58 -156 -58 -212c0 -52 23 -87 74 -87c117 0 178 229 178 271c0 36 -13 62 -34 82c-11 11 -16 17 -16 30c0 22 24 48 49 48c18 0 44 -16 44 -70Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-29" d="M288 208c0 -171 -105 -371 -215 -454c-2 -1 -4 -2 -6 -2c-5 0 -10 5 -10 10c0 3 2 6 4 8c104 78 173 278 173 438v84c0 160 -69 360 -173 438c-2 2 -4 5 -4 8c0 5 5 10 10 10c2 0 4 -1 6 -2c110 -83 215 -283 215 -454v-84Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-28" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D462" x="389" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="962" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D463" x="1407" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-29" x="1892" y="0"></use>
</g>
</svg> at intersection point</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2511" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2511"><i></i></a><div id="fragbit-2511" class="collapse"><div class="fragmentcode">                     <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> dpdx, dpdy;
                     Float dudx = 0, dudy = 0, dvdx = 0, dvdy = 0;
                     <a href="#WavefrontPathIntegrator::camera" class="code">camera</a>.<a href="../Textures_and_Materials/Texture_Sampling_and_Antialiasing.html#Camera::Approximate_dp_dxy" class="code">Approximate_dp_dxy</a>(<a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a>(w.<a href="#MaterialEvalWorkItem::pi" class="code">pi</a>), w.<a href="#MaterialEvalWorkItem::n" class="code">n</a>, w.<a href="#MaterialEvalWorkItem::time" class="code">time</a>, <a href="#WavefrontPathIntegrator::samplesPerPixel" class="code">samplesPerPixel</a>,
                                               &amp;dpdx, &amp;dpdy);
                     <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> <a href="#MaterialEvalWorkItem::dpdu" class="code">dpdu</a> = w.<a href="#MaterialEvalWorkItem::dpdu" class="code">dpdu</a>, <a href="#MaterialEvalWorkItem::dpdv" class="code">dpdv</a> = w.<a href="#MaterialEvalWorkItem::dpdv" class="code">dpdv</a>;
                     &lt;&lt;<span class="fragmentname"><a href="../Textures_and_Materials/Texture_Sampling_and_Antialiasing.html#fragment-Estimatescreen-spacechangeinuv-0">Estimate screen-space change in <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.301ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 2282.2 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">left-parenthesis u comma v right-parenthesis</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-28" d="M332 -238c0 -5 -5 -10 -10 -10c-2 0 -4 1 -6 2c-110 83 -215 283 -215 454v84c0 171 105 371 215 454c2 1 4 2 6 2c5 0 10 -5 10 -10c0 -3 -2 -6 -4 -8c-104 -78 -173 -278 -173 -438v-84c0 -160 69 -360 173 -438c2 -2 4 -5 4 -8Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D462" d="M543 143c0 0 -13 -63 -30 -99c-16 -32 -39 -55 -74 -55c-43 0 -78 26 -89 67c-17 -22 -53 -67 -119 -67c-54 0 -123 25 -123 120c0 49 21 111 58 210c6 15 17 44 17 68c0 32 -16 33 -25 33c-38 0 -76 -37 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10 c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -17 -63c-26 -69 -54 -148 -54 -204c0 -37 10 -82 62 -82c73 0 113 80 114 84l75 301c8 34 34 35 39 35c15 0 29 -9 29 -27c0 -6 -10 -44 -15 -67c-4 -15 -14 -53 -17 -68l-28 -108c-8 -35 -20 -82 -20 -104 c0 -33 10 -46 31 -46c42 0 61 68 75 124c3 14 4 18 14 18c3 0 12 0 12 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2C" d="M203 1c0 -117 -80 -194 -91 -194c-5 0 -10 4 -10 11c0 3 0 5 11 16c33 33 68 93 68 167c0 14 -2 15 -2 15s-2 -1 -5 -3c-10 -9 -23 -13 -35 -13c-33 0 -53 26 -53 53c0 28 20 53 53 53c39 0 64 -39 64 -105Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D463" d="M468 372c0 -52 -57 -383 -225 -383c-46 0 -134 16 -134 124c0 43 13 89 57 205c7 18 17 45 17 70c0 32 -17 32 -25 32c-29 0 -72 -23 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 38 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -12 -50 c-31 -83 -58 -156 -58 -212c0 -52 23 -87 74 -87c117 0 178 229 178 271c0 36 -13 62 -34 82c-11 11 -16 17 -16 30c0 22 24 48 49 48c18 0 44 -16 44 -70Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-29" d="M288 208c0 -171 -105 -371 -215 -454c-2 -1 -4 -2 -6 -2c-5 0 -10 5 -10 10c0 3 2 6 4 8c104 78 173 278 173 438v84c0 160 -69 360 -173 438c-2 2 -4 5 -4 8c0 5 5 10 10 10c2 0 4 -1 6 -2c110 -83 215 -283 215 -454v-84Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-28" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D462" x="389" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="962" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D463" x="1407" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-29" x="1892" y="0"></use>
</g>
</svg></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2512" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2512"><i></i></a><div id="fragbit-2512" class="collapse"><div class="fragmentcode">                        &lt;&lt;<span class="fragmentname"><a href="../Textures_and_Materials/Texture_Sampling_and_Antialiasing.html#fragment-ComputetransposeXFORMAXFORMAanditsdeterminant-0">Compute <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.428ex" height="2.676ex" style="vertical-align: -0.338ex;" viewBox="0 -1006.6 2337.2 1152.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">bold upper A Superscript upper T Baseline bold upper A</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D400" d="M827 0c-35 3 -123 3 -163 3c-43 0 -138 0 -176 -3v47h95l-60 146h-268l-50 -121l-4 -12c0 -13 89 -13 89 -13v-47c-37 3 -93 3 -132 3l-117 -3v47h21c76 0 79 8 85 23l248 602c7 18 11 26 39 26c17 0 29 0 40 -26l256 -625h97v-47zM503 240l-114 278l-114 -278h228Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D447" d="M704 666c0 -3 -1 -13 -2 -17l-27 -174c-2 -15 -4 -23 -15 -23c-9 0 -12 7 -12 13c0 3 2 15 3 19c4 26 8 65 8 80c0 78 -45 82 -146 82c-21 0 -54 0 -63 -2c-12 -3 -16 -9 -23 -37l-133 -531c-4 -15 -4 -21 -4 -21c0 -16 8 -19 37 -22c26 -2 39 -2 64 -2c26 0 34 0 34 -11 c0 -20 -12 -20 -22 -20c-28 0 -58 2 -87 2l-83 1l-85 -1c-27 0 -55 -2 -82 -2c-6 0 -17 0 -17 12c0 19 6 19 42 19c107 0 110 11 119 48l134 534c1 3 4 15 4 21c0 8 0 12 -28 12h-39c-148 0 -174 -18 -228 -173c-6 -16 -7 -21 -17 -21c-7 0 -12 5 -12 11c0 0 5 16 6 18 l60 176c7 19 8 20 32 20h555c17 0 27 0 27 -11Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D400" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D447" x="1229" y="602"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D400" x="1467" y="0"></use>
</g>
</svg> and its determinant</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2513" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2513"><i></i></a><div id="fragbit-2513" class="collapse"><div class="fragmentcode">                           Float ata00 = <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(dpdu, dpdu), ata01 = <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(dpdu, dpdv);
                           Float ata11 = <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(dpdv, dpdv);
                           Float invDet = 1 / <a href="../Utilities/Mathematical_Infrastructure.html#DifferenceOfProducts" class="code">DifferenceOfProducts</a>(ata00, ata11, ata01, ata01);
                           invDet = <a href="../Shapes/Managing_Rounding_Error.html#IsFinite" class="code">IsFinite</a>(invDet) ? invDet : 0.f;</div></div>
                        &lt;&lt;<span class="fragmentname"><a href="../Textures_and_Materials/Texture_Sampling_and_Antialiasing.html#fragment-ComputetransposeXFORMAVECbforxandy-0">Compute <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.894ex" height="2.676ex" style="vertical-align: -0.338ex;" viewBox="0 -1006.6 2107.2 1152.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">bold upper A Superscript upper T Baseline bold b</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D400" d="M827 0c-35 3 -123 3 -163 3c-43 0 -138 0 -176 -3v47h95l-60 146h-268l-50 -121l-4 -12c0 -13 89 -13 89 -13v-47c-37 3 -93 3 -132 3l-117 -3v47h21c76 0 79 8 85 23l248 602c7 18 11 26 39 26c17 0 29 0 40 -26l256 -625h97v-47zM503 240l-114 278l-114 -278h228Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D447" d="M704 666c0 -3 -1 -13 -2 -17l-27 -174c-2 -15 -4 -23 -15 -23c-9 0 -12 7 -12 13c0 3 2 15 3 19c4 26 8 65 8 80c0 78 -45 82 -146 82c-21 0 -54 0 -63 -2c-12 -3 -16 -9 -23 -37l-133 -531c-4 -15 -4 -21 -4 -21c0 -16 8 -19 37 -22c26 -2 39 -2 64 -2c26 0 34 0 34 -11 c0 -20 -12 -20 -22 -20c-28 0 -58 2 -87 2l-83 1l-85 -1c-27 0 -55 -2 -82 -2c-6 0 -17 0 -17 12c0 19 6 19 42 19c107 0 110 11 119 48l134 534c1 3 4 15 4 21c0 8 0 12 -28 12h-39c-148 0 -174 -18 -228 -173c-6 -16 -7 -21 -17 -21c-7 0 -12 5 -12 11c0 0 5 16 6 18 l60 176c7 19 8 20 32 20h555c17 0 27 0 27 -11Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D41B" d="M600 223c0 -139 -103 -229 -252 -229c-89 0 -138 54 -146 62c-16 -19 -33 -37 -49 -56h-47v600c0 39 -7 39 -69 39v47l177 8v-293c24 20 74 49 147 49c145 0 239 -94 239 -227zM472 223c0 70 0 191 -122 191c-55 0 -103 -29 -130 -64v-251c10 -15 49 -69 119 -69 c32 0 78 11 107 52c26 39 26 94 26 141Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D400" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D447" x="1229" y="602"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D41B" x="1467" y="0"></use>
</g>
</svg> for <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.33ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 572.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">x</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D465" d="M527 376c0 -40 -32 -58 -54 -58c-27 0 -38 19 -38 35c0 24 20 49 48 54c-21 13 -45 13 -50 13c-70 0 -93 -92 -99 -118l-34 -137c-11 -44 -17 -66 -17 -88c0 -34 16 -66 55 -66c32 0 100 24 133 131c2 7 4 11 13 11c3 0 12 0 12 -10c0 -25 -57 -154 -160 -154 c-60 0 -96 39 -108 76c-3 -6 -39 -76 -105 -76c-44 0 -94 20 -94 66c0 32 25 58 55 58c15 0 37 -8 37 -35c0 -28 -22 -49 -47 -54c21 -13 44 -13 50 -13c44 0 79 42 95 104c37 140 54 207 54 238c0 58 -35 67 -54 67c-34 0 -100 -25 -134 -131c-2 -9 -5 -11 -13 -11 c0 0 -12 0 -12 10c0 25 57 154 161 154c29 0 83 -10 108 -76c12 23 47 76 105 76c34 0 93 -14 93 -66Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D465" x="0" y="0"></use>
</g>
</svg> and <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.139ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 490.5 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">y</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D466" d="M490 404c0 -7 0 -9 -4 -23l-96 -382c-28 -113 -131 -204 -234 -204c-62 0 -106 37 -106 87c0 49 33 65 56 65c10 0 37 -4 37 -35c0 -19 -10 -32 -20 -41c-14 -12 -27 -12 -43 -12c17 -39 62 -42 76 -42c46 0 84 29 110 63c40 53 52 102 65 154c-28 -28 -62 -45 -101 -45 c-59 0 -122 30 -122 119c0 47 18 104 58 210c7 19 17 45 17 70c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -20 -4 -31 -20 -72c-34 -88 -51 -150 -51 -196c0 -37 11 -81 62 -81 c66 0 109 70 113 85l45 180l20 80c4 18 12 49 14 54c9 15 25 21 35 21c15 0 29 -9 29 -27Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D466" x="0" y="0"></use>
</g>
</svg></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2514" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2514"><i></i></a><div id="fragbit-2514" class="collapse"><div class="fragmentcode">                           Float atb0x = <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(dpdu, dpdx), atb1x = <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(dpdv, dpdx);
                           Float atb0y = <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(dpdu, dpdy), atb1y = <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(dpdv, dpdy);</div></div>
                        &lt;&lt;<span class="fragmentname"><a href="../Textures_and_Materials/Texture_Sampling_and_Antialiasing.html#fragment-Computeuandvderivativeswithrespecttoxandy-0">Compute <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.33ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 572.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">u</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D462" d="M543 143c0 0 -13 -63 -30 -99c-16 -32 -39 -55 -74 -55c-43 0 -78 26 -89 67c-17 -22 -53 -67 -119 -67c-54 0 -123 25 -123 120c0 49 21 111 58 210c6 15 17 44 17 68c0 32 -16 33 -25 33c-38 0 -76 -37 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10 c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -17 -63c-26 -69 -54 -148 -54 -204c0 -37 10 -82 62 -82c73 0 113 80 114 84l75 301c8 34 34 35 39 35c15 0 29 -9 29 -27c0 -6 -10 -44 -15 -67c-4 -15 -14 -53 -17 -68l-28 -108c-8 -35 -20 -82 -20 -104 c0 -33 10 -46 31 -46c42 0 61 68 75 124c3 14 4 18 14 18c3 0 12 0 12 -10Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D462" x="0" y="0"></use>
</g>
</svg> and <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.128ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 485.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">v</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D463" d="M468 372c0 -52 -57 -383 -225 -383c-46 0 -134 16 -134 124c0 43 13 89 57 205c7 18 17 45 17 70c0 32 -17 32 -25 32c-29 0 -72 -23 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 38 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -12 -50 c-31 -83 -58 -156 -58 -212c0 -52 23 -87 74 -87c117 0 178 229 178 271c0 36 -13 62 -34 82c-11 11 -16 17 -16 30c0 22 24 48 49 48c18 0 44 -16 44 -70Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D463" x="0" y="0"></use>
</g>
</svg> derivatives with respect to <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.33ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 572.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">x</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D465" d="M527 376c0 -40 -32 -58 -54 -58c-27 0 -38 19 -38 35c0 24 20 49 48 54c-21 13 -45 13 -50 13c-70 0 -93 -92 -99 -118l-34 -137c-11 -44 -17 -66 -17 -88c0 -34 16 -66 55 -66c32 0 100 24 133 131c2 7 4 11 13 11c3 0 12 0 12 -10c0 -25 -57 -154 -160 -154 c-60 0 -96 39 -108 76c-3 -6 -39 -76 -105 -76c-44 0 -94 20 -94 66c0 32 25 58 55 58c15 0 37 -8 37 -35c0 -28 -22 -49 -47 -54c21 -13 44 -13 50 -13c44 0 79 42 95 104c37 140 54 207 54 238c0 58 -35 67 -54 67c-34 0 -100 -25 -134 -131c-2 -9 -5 -11 -13 -11 c0 0 -12 0 -12 10c0 25 57 154 161 154c29 0 83 -10 108 -76c12 23 47 76 105 76c34 0 93 -14 93 -66Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D465" x="0" y="0"></use>
</g>
</svg> and <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.139ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 490.5 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">y</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D466" d="M490 404c0 -7 0 -9 -4 -23l-96 -382c-28 -113 -131 -204 -234 -204c-62 0 -106 37 -106 87c0 49 33 65 56 65c10 0 37 -4 37 -35c0 -19 -10 -32 -20 -41c-14 -12 -27 -12 -43 -12c17 -39 62 -42 76 -42c46 0 84 29 110 63c40 53 52 102 65 154c-28 -28 -62 -45 -101 -45 c-59 0 -122 30 -122 119c0 47 18 104 58 210c7 19 17 45 17 70c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -20 -4 -31 -20 -72c-34 -88 -51 -150 -51 -196c0 -37 11 -81 62 -81 c66 0 109 70 113 85l45 180l20 80c4 18 12 49 14 54c9 15 25 21 35 21c15 0 29 -9 29 -27Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D466" x="0" y="0"></use>
</g>
</svg></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2515" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2515"><i></i></a><div id="fragbit-2515" class="collapse"><div class="fragmentcode">                           dudx = <a href="../Utilities/Mathematical_Infrastructure.html#DifferenceOfProducts" class="code">DifferenceOfProducts</a>(ata11, atb0x, ata01, atb1x) * invDet;
                           dvdx = <a href="../Utilities/Mathematical_Infrastructure.html#DifferenceOfProducts" class="code">DifferenceOfProducts</a>(ata00, atb1x, ata01, atb0x) * invDet;
                           dudy = <a href="../Utilities/Mathematical_Infrastructure.html#DifferenceOfProducts" class="code">DifferenceOfProducts</a>(ata11, atb0y, ata01, atb1y) * invDet;
                           dvdy = <a href="../Utilities/Mathematical_Infrastructure.html#DifferenceOfProducts" class="code">DifferenceOfProducts</a>(ata00, atb1y, ata01, atb0y) * invDet;</div></div>
                        &lt;&lt;<span class="fragmentname"><a href="../Textures_and_Materials/Texture_Sampling_and_Antialiasing.html#fragment-Clampderivativesofuandvtoreasonablevalues-0">Clamp derivatives of <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.33ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 572.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">u</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D462" d="M543 143c0 0 -13 -63 -30 -99c-16 -32 -39 -55 -74 -55c-43 0 -78 26 -89 67c-17 -22 -53 -67 -119 -67c-54 0 -123 25 -123 120c0 49 21 111 58 210c6 15 17 44 17 68c0 32 -16 33 -25 33c-38 0 -76 -37 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10 c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -17 -63c-26 -69 -54 -148 -54 -204c0 -37 10 -82 62 -82c73 0 113 80 114 84l75 301c8 34 34 35 39 35c15 0 29 -9 29 -27c0 -6 -10 -44 -15 -67c-4 -15 -14 -53 -17 -68l-28 -108c-8 -35 -20 -82 -20 -104 c0 -33 10 -46 31 -46c42 0 61 68 75 124c3 14 4 18 14 18c3 0 12 0 12 -10Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D462" x="0" y="0"></use>
</g>
</svg> and <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.128ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 485.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">v</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D463" d="M468 372c0 -52 -57 -383 -225 -383c-46 0 -134 16 -134 124c0 43 13 89 57 205c7 18 17 45 17 70c0 32 -17 32 -25 32c-29 0 -72 -23 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 38 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -12 -50 c-31 -83 -58 -156 -58 -212c0 -52 23 -87 74 -87c117 0 178 229 178 271c0 36 -13 62 -34 82c-11 11 -16 17 -16 30c0 22 24 48 49 48c18 0 44 -16 44 -70Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D463" x="0" y="0"></use>
</g>
</svg> to reasonable values</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2516" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2516"><i></i></a><div id="fragbit-2516" class="collapse"><div class="fragmentcode">                           dudx = <a href="../Shapes/Managing_Rounding_Error.html#IsFinite" class="code">IsFinite</a>(dudx) ? <a href="../Utilities/Mathematical_Infrastructure.html#Clamp" class="code">Clamp</a>(dudx, -1e8f, 1e8f) : 0.f;
                           dvdx = <a href="../Shapes/Managing_Rounding_Error.html#IsFinite" class="code">IsFinite</a>(dvdx) ? <a href="../Utilities/Mathematical_Infrastructure.html#Clamp" class="code">Clamp</a>(dvdx, -1e8f, 1e8f) : 0.f;
                           dudy = <a href="../Shapes/Managing_Rounding_Error.html#IsFinite" class="code">IsFinite</a>(dudy) ? <a href="../Utilities/Mathematical_Infrastructure.html#Clamp" class="code">Clamp</a>(dudy, -1e8f, 1e8f) : 0.f;
                           dvdy = <a href="../Shapes/Managing_Rounding_Error.html#IsFinite" class="code">IsFinite</a>(dvdy) ? <a href="../Utilities/Mathematical_Infrastructure.html#Clamp" class="code">Clamp</a>(dvdy, -1e8f, 1e8f) : 0.f;</div></div></div></div>
                     </div></div>
                  &lt;&lt;<span class="fragmentname"><a href="#fragment-Computeshadingnormalifbumpornormalmappingisbeingused-0">Compute shading normal if bump or normal mapping is being used</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2517" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2517"><i></i></a><div id="fragbit-2517" class="collapse"><div class="fragmentcode">                     <a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a> <a href="#MaterialEvalWorkItem::ns" class="code">ns</a> = w.<a href="#MaterialEvalWorkItem::ns" class="code">ns</a>;
                     <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> <a href="#MaterialEvalWorkItem::dpdus" class="code">dpdus</a> = w.<a href="#MaterialEvalWorkItem::dpdus" class="code">dpdus</a>;
                     <a href="../Textures_and_Materials/Texture_Interface_and_Basic_Textures.html#FloatTexture" class="code">FloatTexture</a> displacement = w.<a href="#MaterialEvalWorkItem::material" class="code">material</a>-&gt;<a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#Material::GetDisplacement" class="code">GetDisplacement</a>();
                     const <a href="../Utilities/Images.html#Image" class="code">Image</a> *normalMap = w.<a href="#MaterialEvalWorkItem::material" class="code">material</a>-&gt;<a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#Material::GetNormalMap" class="code">GetNormalMap</a>();
                     if (normalMap) {
                         &lt;&lt;<span class="fragmentname"><a href="#fragment-CallmonoNormalMaptofindshadinggeometry-0">Call <tt>NormalMap()</tt> to find shading geometry</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2518" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2518"><i></i></a><div id="fragbit-2518" class="collapse"><div class="fragmentcode">                            <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#NormalBumpEvalContext" class="code">NormalBumpEvalContext</a> bctx = w.<a href="#MaterialEvalWorkItem::GetNormalBumpEvalContext" class="code">GetNormalBumpEvalContext</a>(dudx, dudy,  
                                                                                    dvdx, dvdy);
                            <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> dpdvs;
                            <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#NormalMap" class="code">NormalMap</a>(*normalMap, bctx, &amp;dpdus, &amp;dpdvs);
                            ns = <a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a>(<a href="../Geometry_and_Transformations/Vectors.html#Normalize" class="code">Normalize</a>(<a href="../Geometry_and_Transformations/Vectors.html#Cross" class="code">Cross</a>(dpdus, dpdvs)));
                            ns = <a href="../Geometry_and_Transformations/Normals.html#FaceForward" class="code">FaceForward</a>(ns, w.<a href="#MaterialEvalWorkItem::n" class="code">n</a>);</div></div>
                     } else if (displacement) {
                         &lt;&lt;<span class="fragmentname">Call <tt>BumpMap()</tt> to find shading geometry</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2519" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2519"><i></i></a><div id="fragbit-2519" class="collapse"><div class="fragmentcode">                            NormalBumpEvalContext bctx = w.<a href="#MaterialEvalWorkItem::GetNormalBumpEvalContext" class="code">GetNormalBumpEvalContext</a>(dudx, dudy, dvdx, dvdy);
                            <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> dpdvs;
                            <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#BumpMap" class="code">BumpMap</a>(texEval, displacement, bctx, &amp;dpdus, &amp;dpdvs);
                            ns = <a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a>(<a href="../Geometry_and_Transformations/Vectors.html#Normalize" class="code">Normalize</a>(<a href="../Geometry_and_Transformations/Vectors.html#Cross" class="code">Cross</a>(dpdus, dpdvs)));
                            ns = <a href="../Geometry_and_Transformations/Normals.html#FaceForward" class="code">FaceForward</a>(ns, w.<a href="#MaterialEvalWorkItem::n" class="code">n</a>);</div></div>
                     }</div></div>
                  &lt;&lt;<span class="fragmentname"><a href="#fragment-GetBSDFatintersectionpoint-0">Get BSDF at intersection point</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2520" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2520"><i></i></a><div id="fragbit-2520" class="collapse"><div class="fragmentcode">                     <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> <a href="#MaterialEvalWorkItem::lambda" class="code">lambda</a> = w.<a href="#MaterialEvalWorkItem::lambda" class="code">lambda</a>;
                     <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#MaterialEvalContext" class="code">MaterialEvalContext</a> ctx = w.<a href="#MaterialEvalWorkItem::GetMaterialEvalContext" class="code">GetMaterialEvalContext</a>(dudx, dudy, dvdx, dvdy,
                                                                        <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#MaterialEvalContext::ns" class="code">ns</a>, <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#MaterialEvalContext::dpdus" class="code">dpdus</a>);
                     using ConcreteBxDF = typename ConcreteMaterial::<a href="../Reflection_Models/BSDF_Representation.html#BxDF" class="code">BxDF</a>;
                     ConcreteBxDF bxdf = w.<a href="#MaterialEvalWorkItem::material" class="code">material</a>-&gt;<a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#Material::GetBxDF" class="code">GetBxDF</a>(texEval, ctx, <a href="#MaterialEvalWorkItem::lambda" class="code">lambda</a>);
                     <a href="../Reflection_Models/BSDF_Representation.html#BSDF" class="code">BSDF</a> bsdf(ctx.<a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#MaterialEvalContext::ns" class="code">ns</a>, ctx.<a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#MaterialEvalContext::dpdus" class="code">dpdus</a>, &amp;bxdf);
                     &lt;&lt;<span class="fragmentname"><a href="#fragment-HandleterminatedsecondarywavelengthsafterBSDFcreation-0">Handle terminated secondary wavelengths after BSDF creation</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2521" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2521"><i></i></a><div id="fragbit-2521" class="collapse"><div class="fragmentcode">                        if (<a href="#PixelSampleState::lambda" class="code">lambda</a>.<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths::SecondaryTerminated" class="code">SecondaryTerminated</a>())
                            <a href="#WavefrontPathIntegrator::pixelSampleState" class="code">pixelSampleState</a>.<a href="#PixelSampleState::lambda" class="code">lambda</a>[w.<a href="#MaterialEvalWorkItem::pixelIndex" class="code">pixelIndex</a>] = <a href="#PixelSampleState::lambda" class="code">lambda</a>;</div></div></div></div>
                  &lt;&lt;<span class="fragmentname"><a href="#fragment-RegularizeBSDFifappropriate-0">Regularize BSDF, if appropriate</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2522" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2522"><i></i></a><div id="fragbit-2522" class="collapse"><div class="fragmentcode">                     if (<a href="#WavefrontPathIntegrator::regularize" class="code">regularize</a> &amp;&amp; w.<a href="#MaterialEvalWorkItem::anyNonSpecularBounces" class="code">anyNonSpecularBounces</a>)
                         bsdf.<a href="../Light_Transport_I_Surface_Reflection/A_Better_Path_Tracer.html#BSDF::Regularize" class="code">Regularize</a>();</div></div>
                  &lt;&lt;<span class="fragmentname">Initialize <tt>VisibleSurface</tt> at first intersection if necessary</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2523" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2523"><i></i></a><div id="fragbit-2523" class="collapse"><div class="fragmentcode">                     if (w.depth == 0 &amp;&amp; initializeVisibleSurface) {
                         <a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction" class="code">SurfaceInteraction</a> isect;
                         isect.pi = w.pi;
                         isect.n = w.n;
                         isect.shading.n = ns;
                         isect.uv = w.uv;
                         isect.wo = w.wo;
                         isect.time = w.time;
                         isect.dpdx = dpdx;
                         isect.dpdy = dpdy;
                     
                         &lt;&lt;<span class="fragmentname"><a href="../Light_Transport_I_Surface_Reflection/A_Better_Path_Tracer.html#fragment-EstimateBSDFsalbedo-0">Estimate BSDF&rsquo;s albedo</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2524" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2524"><i></i></a><div id="fragbit-2524" class="collapse"><div class="fragmentcode">                            &lt;&lt;<span class="fragmentname">Define sample arrays <tt>ucRho</tt> and <tt>uRho</tt> for reflectance estimate</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2525" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2525"><i></i></a><div id="fragbit-2525" class="collapse"><div class="fragmentcode">                               constexpr int nRhoSamples = 16;
                               const Float ucRho[nRhoSamples] = { 0.75741637, 0.37870818, 0.7083487, 0.18935409, 0.9149363, 0.35417435, 0.5990858, 0.09467703, 0.8578725, 0.45746812, 0.686759, 0.17708716, 0.9674518, 0.2995429, 0.5083201, 0.047338516 };
                               const <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a> uRho[nRhoSamples] = { <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.855985, 0.570367), <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.381823, 0.851844), <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.285328, 0.764262), <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.733380, 0.114073), <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.542663, 0.344465), <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.127274, 0.414848), <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.964700, 0.947162), <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.594089, 0.643463), <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.095109, 0.170369), <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.825444, 0.263359), <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.429467, 0.454469), <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.244460, 0.816459), <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.756135, 0.731258), <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.516165, 0.152852), <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.180888, 0.214174), <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.898579, 0.503897) };</div></div>
                            <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> albedo = bsdf.<a href="../Reflection_Models/BSDF_Representation.html#BSDF::rho" class="code">rho</a>(isect.<a href="../Geometry_and_Transformations/Interactions.html#Interaction::wo" class="code">wo</a>, ucRho, uRho);</div></div>
                     
                         pixelSampleState.visibleSurface[w.pixelIndex] =
                             <a href="../Cameras_and_Film/Film_and_Imaging.html#VisibleSurface" class="code">VisibleSurface</a>(isect, albedo, lambda);
                     }</div></div>
                  &lt;&lt;<span class="fragmentname"><a href="#fragment-SampleBSDFandenqueueindirectrayatintersectionpoint-0">Sample BSDF and enqueue indirect ray at intersection point</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2526" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2526"><i></i></a><div id="fragbit-2526" class="collapse"><div class="fragmentcode">                     <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> <a href="#MaterialEvalWorkItem::wo" class="code">wo</a> = w.<a href="#MaterialEvalWorkItem::wo" class="code">wo</a>;
                     <a href="#RaySamples" class="code">RaySamples</a> raySamples = <a href="#WavefrontPathIntegrator::pixelSampleState" class="code">pixelSampleState</a>.<a href="#PixelSampleState::samples" class="code">samples</a>[w.<a href="#MaterialEvalWorkItem::pixelIndex" class="code">pixelIndex</a>];
                     pstd::optional&lt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample" class="code">BSDFSample</a>&gt; bsdfSample =
                         bsdf.<a href="../Reflection_Models/BSDF_Representation.html#BSDF::Sample_f" class="code">Sample_f</a>&lt;ConcreteBxDF&gt;(<a href="#MaterialEvalWorkItem::wo" class="code">wo</a>, raySamples.indirect.<a href="#RaySamples::indirect::uc" class="code">uc</a>,
                                                     raySamples.indirect.<a href="#RaySamples::indirect::u" class="code">u</a>);
                     if (bsdfSample) {
                         &lt;&lt;<span class="fragmentname"><a href="#fragment-ComputeupdatedpaththroughputandPDFsandenqueueindirectray-0">Compute updated path throughput and PDFs and enqueue indirect ray</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2527" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2527"><i></i></a><div id="fragbit-2527" class="collapse"><div class="fragmentcode">                            <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> <a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::wi" class="code">wi</a> = bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::wi" class="code">wi</a>;
                            <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <a href="#MaterialEvalWorkItem::beta" class="code">beta</a> = w.<a href="#MaterialEvalWorkItem::beta" class="code">beta</a> * bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::f" class="code">f</a> * <a href="../Geometry_and_Transformations/Vectors.html#AbsDot" class="code">AbsDot</a>(<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::wi" class="code">wi</a>, ns)/bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::pdf" class="code">pdf</a>;
                            <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <a href="#MaterialEvalWorkItem::r_u" class="code">r_u</a> = w.<a href="#MaterialEvalWorkItem::r_u" class="code">r_u</a>, r_l;
                            &lt;&lt;<span class="fragmentname"><a href="#fragment-Updatemonor_ubasedonBSDFsamplePDF-0">Update <tt>r_u</tt> based on BSDF sample PDF</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2528" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2528"><i></i></a><div id="fragbit-2528" class="collapse"><div class="fragmentcode">                               if (bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::pdfIsProportional" class="code">pdfIsProportional</a>)
                                   r_l = r_u / bsdf.<a href="../Reflection_Models/BSDF_Representation.html#BSDF::PDF" class="code">PDF</a>&lt;ConcreteBxDF&gt;(wo, bsdfSample-&gt;wi);
                               else
                                   r_l = r_u / bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::pdf" class="code">pdf</a>;</div></div>
                            &lt;&lt;<span class="fragmentname"><a href="#fragment-UpdatemonoetaScaleaccountingforBSDFscattering-0">Update <tt>etaScale</tt> accounting for BSDF scattering</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2529" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2529"><i></i></a><div id="fragbit-2529" class="collapse"><div class="fragmentcode">                               Float <a href="#MaterialEvalWorkItem::etaScale" class="code">etaScale</a> = w.<a href="#MaterialEvalWorkItem::etaScale" class="code">etaScale</a>;
                               if (bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::IsTransmission" class="code">IsTransmission</a>())
                                   <a href="#MaterialEvalWorkItem::etaScale" class="code">etaScale</a> *= <a href="../Utilities/Mathematical_Infrastructure.html#Sqr" class="code">Sqr</a>(bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::eta" class="code">eta</a>);</div></div>
                            &lt;&lt;<span class="fragmentname">Apply Russian roulette to indirect ray based on weighted path throughput</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2530" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2530"><i></i></a><div id="fragbit-2530" class="collapse"><div class="fragmentcode">                               <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> rrBeta = beta * etaScale / r_u.Average();
                               // Note: depth &gt;= 1 here to match VolPathIntegrator (which increments depth earlier).
                               if (rrBeta.MaxComponentValue() &lt; 1 &amp;&amp; w.depth &gt;= 1) {
                                   Float q = std::max&lt;Float&gt;(0, 1 - rrBeta.MaxComponentValue());
                                   if (raySamples.indirect.rr &lt; q) {
                                       beta = <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a>(0.f);
                                       PBRT_DBG("Path terminated with RR\n");
                                   } else
                                       beta /= 1 - q;
                               }</div></div>
                            if (<a href="#MaterialEvalWorkItem::beta" class="code">beta</a>) {
                                &lt;&lt;<span class="fragmentname"><a href="#fragment-Initializespawnedrayandenqueuefornextraydepth-0">Initialize spawned ray and enqueue for next ray depth</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2531" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2531"><i></i></a><div id="fragbit-2531" class="collapse"><div class="fragmentcode">                                   <a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> ray = <a href="../Shapes/Managing_Rounding_Error.html#SpawnRay" class="code">SpawnRay</a>(w.<a href="#MaterialEvalWorkItem::pi" class="code">pi</a>, w.<a href="#MaterialEvalWorkItem::n" class="code">n</a>, w.<a href="#MaterialEvalWorkItem::time" class="code">time</a>, wi);
                                   &lt;&lt;<span class="fragmentname"><a href="#fragment-Initializemonoraymediumifmediaarepresent-0">Initialize <tt>ray</tt> medium if media are present</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2532" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2532"><i></i></a><div id="fragbit-2532" class="collapse"><div class="fragmentcode">                                      if (haveMedia)
                                          ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::medium" class="code">medium</a> = <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::d" class="code">d</a>, w.<a href="#MaterialEvalWorkItem::n" class="code">n</a>) &gt; 0 ? w.<a href="#MaterialEvalWorkItem::mediumInterface" class="code">mediumInterface</a>.outside
                                                                           : w.<a href="#MaterialEvalWorkItem::mediumInterface" class="code">mediumInterface</a>.inside;</div></div>
                                   bool <a href="#MaterialEvalWorkItem::anyNonSpecularBounces" class="code">anyNonSpecularBounces</a> = !bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::IsSpecular" class="code">IsSpecular</a>() ||
                                                                w.<a href="#MaterialEvalWorkItem::anyNonSpecularBounces" class="code">anyNonSpecularBounces</a>;
                                   <a href="../Light_Sources/Light_Interface.html#LightSampleContext" class="code">LightSampleContext</a> ctx(w.<a href="#MaterialEvalWorkItem::pi" class="code">pi</a>, w.<a href="#MaterialEvalWorkItem::n" class="code">n</a>, ns);
                                   nextRayQueue-&gt;<a href="#RayQueue::PushIndirectRay" class="code">PushIndirectRay</a>(
                                       ray, w.<a href="#MaterialEvalWorkItem::depth" class="code">depth</a> + 1, ctx, beta, r_u, r_l, lambda,
                                       etaScale, bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::IsSpecular" class="code">IsSpecular</a>(), <a href="#MaterialEvalWorkItem::anyNonSpecularBounces" class="code">anyNonSpecularBounces</a>, w.<a href="#MaterialEvalWorkItem::pixelIndex" class="code">pixelIndex</a>);
                                   </div></div>
                            }</div></div>
                     }</div></div>
                  &lt;&lt;<span class="fragmentname"><a href="#fragment-Samplelightandenqueueshadowrayatintersectionpoint-0">Sample light and enqueue shadow ray at intersection point</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2533" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2533"><i></i></a><div id="fragbit-2533" class="collapse"><div class="fragmentcode">                     <a href="../Reflection_Models/BSDF_Representation.html#BxDFFlags" class="code">BxDFFlags</a> flags = bsdf.<a href="../Reflection_Models/BSDF_Representation.html#BSDF::Flags" class="code">Flags</a>();
                     if (<a href="../Reflection_Models/BSDF_Representation.html#BxDFFlags::IsNonSpecular" class="code">IsNonSpecular</a>(flags)) {
                         &lt;&lt;<span class="fragmentname">Choose a light source using the <tt>LightSampler</tt></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2534" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2534"><i></i></a><div id="fragbit-2534" class="collapse"><div class="fragmentcode">                            <a href="../Light_Sources/Light_Interface.html#LightSampleContext" class="code">LightSampleContext</a> ctx(w.pi, w.n, ns);
                            if (IsReflective(flags) &amp;&amp; !IsTransmissive(flags))
                                ctx.pi = OffsetRayOrigin(ctx.pi, w.n, wo);
                            else if (IsTransmissive(flags) &amp;&amp; IsReflective(flags))
                                ctx.pi = OffsetRayOrigin(ctx.pi, w.n, -wo);
                            pstd::optional&lt;SampledLight&gt; sampledLight =
                                lightSampler.Sample(ctx, raySamples.direct.uc);
                            if (!sampledLight)
                                return;
                            <a href="../Light_Sources/Light_Interface.html#Light" class="code">Light</a> light = sampledLight-&gt;light;</div></div>
                         &lt;&lt;<span class="fragmentname">Sample light source and evaluate BSDF for direct lighting</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2535" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2535"><i></i></a><div id="fragbit-2535" class="collapse"><div class="fragmentcode">                            pstd::optional&lt;<a href="../Light_Sources/Light_Interface.html#LightLiSample" class="code">LightLiSample</a>&gt; ls =
                                light.<a href="../Light_Sources/Light_Interface.html#Light::SampleLi" class="code">SampleLi</a>(ctx, raySamples.direct.<a href="#RaySamples::direct::u" class="code">u</a>, lambda,
                                true);
                            if (!ls || !ls-&gt;<a href="../Light_Sources/Light_Interface.html#LightLiSample::L" class="code">L</a> || ls-&gt;<a href="../Light_Sources/Light_Interface.html#LightLiSample::pdf" class="code">pdf</a> == 0) return;
                            <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> <a href="../Light_Sources/Light_Interface.html#LightLiSample::wi" class="code">wi</a> = ls-&gt;<a href="../Light_Sources/Light_Interface.html#LightLiSample::wi" class="code">wi</a>;
                            <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> f = bsdf.f&lt;ConcreteBxDF&gt;(wo, <a href="../Light_Sources/Light_Interface.html#LightLiSample::wi" class="code">wi</a>);
                            if (!f) return;</div></div>
                         &lt;&lt;<span class="fragmentname"><a href="#fragment-ComputepaththroughputandpathPDFsforlightsample-0">Compute path throughput and path PDFs for light sample</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2536" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2536"><i></i></a><div id="fragbit-2536" class="collapse"><div class="fragmentcode">                            <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <a href="#MaterialEvalWorkItem::beta" class="code">beta</a> = w.<a href="#MaterialEvalWorkItem::beta" class="code">beta</a> * f * <a href="../Geometry_and_Transformations/Vectors.html#AbsDot" class="code">AbsDot</a>(wi, ns);
                            Float lightPDF = ls-&gt;<a href="../Light_Sources/Light_Interface.html#LightLiSample::pdf" class="code">pdf</a> * sampledLight-&gt;<a href="../Light_Sources/Light_Sampling.html#SampledLight::p" class="code">p</a>;
                            Float bsdfPDF = <a href="../Light_Sources/Light_Interface.html#IsDeltaLight" class="code">IsDeltaLight</a>(light.<a href="../Light_Sources/Light_Interface.html#Light::Type" class="code">Type</a>()) ? 0.f
                                                                       : bsdf.<a href="../Reflection_Models/BSDF_Representation.html#BSDF::PDF" class="code">PDF</a>&lt;ConcreteBxDF&gt;(wo, wi);
                            <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <a href="#MaterialEvalWorkItem::r_u" class="code">r_u</a> = w.<a href="#MaterialEvalWorkItem::r_u" class="code">r_u</a> * bsdfPDF;
                            <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> r_l = w.<a href="#MaterialEvalWorkItem::r_u" class="code">r_u</a> * lightPDF;</div></div>
                         &lt;&lt;<span class="fragmentname"><a href="#fragment-Enqueueshadowraywithtentativeradiancecontribution-0">Enqueue shadow ray with tentative radiance contribution</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2537" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2537"><i></i></a><div id="fragbit-2537" class="collapse"><div class="fragmentcode">                            <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> Ld = beta * ls-&gt;<a href="../Light_Sources/Light_Interface.html#LightLiSample::L" class="code">L</a>;
                            <a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> ray = <a href="../Shapes/Managing_Rounding_Error.html#SpawnRayTo" class="code">SpawnRayTo</a>(w.<a href="../Geometry_and_Transformations/Interactions.html#Interaction::pi" class="code">pi</a>, w.<a href="../Geometry_and_Transformations/Interactions.html#Interaction::n" class="code">n</a>, w.<a href="#MaterialEvalWorkItem::time" class="code">time</a>, ls-&gt;<a href="../Light_Sources/Light_Interface.html#LightLiSample::pLight" class="code">pLight</a>.<a href="../Geometry_and_Transformations/Interactions.html#Interaction::pi" class="code">pi</a>, ls-&gt;<a href="../Light_Sources/Light_Interface.html#LightLiSample::pLight" class="code">pLight</a>.<a href="../Geometry_and_Transformations/Interactions.html#Interaction::n" class="code">n</a>);
                            &lt;&lt;<span class="fragmentname"><a href="#fragment-Initializemonoraymediumifmediaarepresent-0">Initialize <tt>ray</tt> medium if media are present</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2538" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2538"><i></i></a><div id="fragbit-2538" class="collapse"><div class="fragmentcode">                               if (haveMedia)
                                   ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::medium" class="code">medium</a> = <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::d" class="code">d</a>, w.<a href="#MaterialEvalWorkItem::n" class="code">n</a>) &gt; 0 ? w.<a href="#MaterialEvalWorkItem::mediumInterface" class="code">mediumInterface</a>.outside
                                                                    : w.<a href="#MaterialEvalWorkItem::mediumInterface" class="code">mediumInterface</a>.inside;</div></div>
                            <a href="#WavefrontPathIntegrator::shadowRayQueue" class="code">shadowRayQueue</a>-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#WorkQueue::Push" class="code">Push</a>(ShadowRayWorkItem{ray, 1 - <a href="../Shapes/Managing_Rounding_Error.html#ShadowEpsilon" class="code">ShadowEpsilon</a>, lambda, Ld,
                                                                   r_u, r_l, w.<a href="#MaterialEvalWorkItem::pixelIndex" class="code">pixelIndex</a>});
                            </div></div>
                     }</div></div></div></div>
           });</div></div>
}</div><p>


</p>
<p>After some initialization work that includes getting a pointer to the
<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#WorkQueue"><tt>WorkQueue</tt></a> for material evaluation of <tt>ConcreteMaterial</tt>, the
work items in the queue are processed in parallel.

</p>
<p></p>
<span class="anchor" id="fragment-GetBSDFforitemsinmonoevalQueueandsampleillumination-0"></span><div class="fragmentname">&lt;&lt;Get BSDF for items in <tt>evalQueue</tt> and sample illumination&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">&lt;&lt;<span class="fragmentname">Construct <tt>desc</tt> for material/texture evaluation kernel</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2539" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2539"><i></i></a><div id="fragbit-2539" class="collapse"><div class="fragmentcode">   std::string desc = <a href="../Utilities/User_Interaction.html#StringPrintf" class="code">StringPrintf</a>(
       "%s + <a href="../Reflection_Models/BSDF_Representation.html#BxDF" class="code">BxDF</a> eval (%s tex)", ConcreteMaterial::Name(),
       std::is_same_v&lt;<a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#TextureEvaluator" class="code">TextureEvaluator</a>, BasicTextureEvaluator&gt; ? "Basic" : "Universal");</div></div>
<a href="#RayQueue" class="code">RayQueue</a> *nextRayQueue = <a href="#WavefrontPathIntegrator::NextRayQueue" class="code">NextRayQueue</a>(wavefrontDepth);
auto queue = evalQueue-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#MultiWorkQueue::Get" class="code">Get</a>&lt;MaterialEvalWorkItem&lt;ConcreteMaterial&gt;&gt;();
<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#ForAllQueued" class="code">ForAllQueued</a>(desc.c_str(), queue, <a href="#WavefrontPathIntegrator::maxQueueSize" class="code">maxQueueSize</a>,
    PBRT_CPU_GPU_LAMBDA (const MaterialEvalWorkItem&lt;ConcreteMaterial&gt; w) {
        &lt;&lt;<span class="fragmentname"><a href="#fragment-EvaluatematerialandBSDFforrayintersection-0">Evaluate material and BSDF for ray intersection</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2540" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2540"><i></i></a><div id="fragbit-2540" class="collapse"><div class="fragmentcode">           <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#TextureEvaluator" class="code">TextureEvaluator</a> texEval;
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Computedifferentialsforpositionanduvatintersectionpoint-0">Compute differentials for position and <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.301ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 2282.2 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">left-parenthesis u comma v right-parenthesis</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-28" d="M332 -238c0 -5 -5 -10 -10 -10c-2 0 -4 1 -6 2c-110 83 -215 283 -215 454v84c0 171 105 371 215 454c2 1 4 2 6 2c5 0 10 -5 10 -10c0 -3 -2 -6 -4 -8c-104 -78 -173 -278 -173 -438v-84c0 -160 69 -360 173 -438c2 -2 4 -5 4 -8Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D462" d="M543 143c0 0 -13 -63 -30 -99c-16 -32 -39 -55 -74 -55c-43 0 -78 26 -89 67c-17 -22 -53 -67 -119 -67c-54 0 -123 25 -123 120c0 49 21 111 58 210c6 15 17 44 17 68c0 32 -16 33 -25 33c-38 0 -76 -37 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10 c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -17 -63c-26 -69 -54 -148 -54 -204c0 -37 10 -82 62 -82c73 0 113 80 114 84l75 301c8 34 34 35 39 35c15 0 29 -9 29 -27c0 -6 -10 -44 -15 -67c-4 -15 -14 -53 -17 -68l-28 -108c-8 -35 -20 -82 -20 -104 c0 -33 10 -46 31 -46c42 0 61 68 75 124c3 14 4 18 14 18c3 0 12 0 12 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2C" d="M203 1c0 -117 -80 -194 -91 -194c-5 0 -10 4 -10 11c0 3 0 5 11 16c33 33 68 93 68 167c0 14 -2 15 -2 15s-2 -1 -5 -3c-10 -9 -23 -13 -35 -13c-33 0 -53 26 -53 53c0 28 20 53 53 53c39 0 64 -39 64 -105Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D463" d="M468 372c0 -52 -57 -383 -225 -383c-46 0 -134 16 -134 124c0 43 13 89 57 205c7 18 17 45 17 70c0 32 -17 32 -25 32c-29 0 -72 -23 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 38 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -12 -50 c-31 -83 -58 -156 -58 -212c0 -52 23 -87 74 -87c117 0 178 229 178 271c0 36 -13 62 -34 82c-11 11 -16 17 -16 30c0 22 24 48 49 48c18 0 44 -16 44 -70Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-29" d="M288 208c0 -171 -105 -371 -215 -454c-2 -1 -4 -2 -6 -2c-5 0 -10 5 -10 10c0 3 2 6 4 8c104 78 173 278 173 438v84c0 160 -69 360 -173 438c-2 2 -4 5 -4 8c0 5 5 10 10 10c2 0 4 -1 6 -2c110 -83 215 -283 215 -454v-84Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-28" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D462" x="389" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="962" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D463" x="1407" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-29" x="1892" y="0"></use>
</g>
</svg> at intersection point</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2541" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2541"><i></i></a><div id="fragbit-2541" class="collapse"><div class="fragmentcode">              <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> dpdx, dpdy;
              Float dudx = 0, dudy = 0, dvdx = 0, dvdy = 0;
              <a href="#WavefrontPathIntegrator::camera" class="code">camera</a>.<a href="../Textures_and_Materials/Texture_Sampling_and_Antialiasing.html#Camera::Approximate_dp_dxy" class="code">Approximate_dp_dxy</a>(<a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a>(w.<a href="#MaterialEvalWorkItem::pi" class="code">pi</a>), w.<a href="#MaterialEvalWorkItem::n" class="code">n</a>, w.<a href="#MaterialEvalWorkItem::time" class="code">time</a>, <a href="#WavefrontPathIntegrator::samplesPerPixel" class="code">samplesPerPixel</a>,
                                        &amp;dpdx, &amp;dpdy);
              <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> <a href="#MaterialEvalWorkItem::dpdu" class="code">dpdu</a> = w.<a href="#MaterialEvalWorkItem::dpdu" class="code">dpdu</a>, <a href="#MaterialEvalWorkItem::dpdv" class="code">dpdv</a> = w.<a href="#MaterialEvalWorkItem::dpdv" class="code">dpdv</a>;
              &lt;&lt;<span class="fragmentname"><a href="../Textures_and_Materials/Texture_Sampling_and_Antialiasing.html#fragment-Estimatescreen-spacechangeinuv-0">Estimate screen-space change in <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.301ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 2282.2 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">left-parenthesis u comma v right-parenthesis</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-28" d="M332 -238c0 -5 -5 -10 -10 -10c-2 0 -4 1 -6 2c-110 83 -215 283 -215 454v84c0 171 105 371 215 454c2 1 4 2 6 2c5 0 10 -5 10 -10c0 -3 -2 -6 -4 -8c-104 -78 -173 -278 -173 -438v-84c0 -160 69 -360 173 -438c2 -2 4 -5 4 -8Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D462" d="M543 143c0 0 -13 -63 -30 -99c-16 -32 -39 -55 -74 -55c-43 0 -78 26 -89 67c-17 -22 -53 -67 -119 -67c-54 0 -123 25 -123 120c0 49 21 111 58 210c6 15 17 44 17 68c0 32 -16 33 -25 33c-38 0 -76 -37 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10 c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -17 -63c-26 -69 -54 -148 -54 -204c0 -37 10 -82 62 -82c73 0 113 80 114 84l75 301c8 34 34 35 39 35c15 0 29 -9 29 -27c0 -6 -10 -44 -15 -67c-4 -15 -14 -53 -17 -68l-28 -108c-8 -35 -20 -82 -20 -104 c0 -33 10 -46 31 -46c42 0 61 68 75 124c3 14 4 18 14 18c3 0 12 0 12 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2C" d="M203 1c0 -117 -80 -194 -91 -194c-5 0 -10 4 -10 11c0 3 0 5 11 16c33 33 68 93 68 167c0 14 -2 15 -2 15s-2 -1 -5 -3c-10 -9 -23 -13 -35 -13c-33 0 -53 26 -53 53c0 28 20 53 53 53c39 0 64 -39 64 -105Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D463" d="M468 372c0 -52 -57 -383 -225 -383c-46 0 -134 16 -134 124c0 43 13 89 57 205c7 18 17 45 17 70c0 32 -17 32 -25 32c-29 0 -72 -23 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 38 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -12 -50 c-31 -83 -58 -156 -58 -212c0 -52 23 -87 74 -87c117 0 178 229 178 271c0 36 -13 62 -34 82c-11 11 -16 17 -16 30c0 22 24 48 49 48c18 0 44 -16 44 -70Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-29" d="M288 208c0 -171 -105 -371 -215 -454c-2 -1 -4 -2 -6 -2c-5 0 -10 5 -10 10c0 3 2 6 4 8c104 78 173 278 173 438v84c0 160 -69 360 -173 438c-2 2 -4 5 -4 8c0 5 5 10 10 10c2 0 4 -1 6 -2c110 -83 215 -283 215 -454v-84Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-28" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D462" x="389" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="962" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D463" x="1407" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-29" x="1892" y="0"></use>
</g>
</svg></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2542" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2542"><i></i></a><div id="fragbit-2542" class="collapse"><div class="fragmentcode">                 &lt;&lt;<span class="fragmentname"><a href="../Textures_and_Materials/Texture_Sampling_and_Antialiasing.html#fragment-ComputetransposeXFORMAXFORMAanditsdeterminant-0">Compute <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.428ex" height="2.676ex" style="vertical-align: -0.338ex;" viewBox="0 -1006.6 2337.2 1152.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">bold upper A Superscript upper T Baseline bold upper A</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D400" d="M827 0c-35 3 -123 3 -163 3c-43 0 -138 0 -176 -3v47h95l-60 146h-268l-50 -121l-4 -12c0 -13 89 -13 89 -13v-47c-37 3 -93 3 -132 3l-117 -3v47h21c76 0 79 8 85 23l248 602c7 18 11 26 39 26c17 0 29 0 40 -26l256 -625h97v-47zM503 240l-114 278l-114 -278h228Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D447" d="M704 666c0 -3 -1 -13 -2 -17l-27 -174c-2 -15 -4 -23 -15 -23c-9 0 -12 7 -12 13c0 3 2 15 3 19c4 26 8 65 8 80c0 78 -45 82 -146 82c-21 0 -54 0 -63 -2c-12 -3 -16 -9 -23 -37l-133 -531c-4 -15 -4 -21 -4 -21c0 -16 8 -19 37 -22c26 -2 39 -2 64 -2c26 0 34 0 34 -11 c0 -20 -12 -20 -22 -20c-28 0 -58 2 -87 2l-83 1l-85 -1c-27 0 -55 -2 -82 -2c-6 0 -17 0 -17 12c0 19 6 19 42 19c107 0 110 11 119 48l134 534c1 3 4 15 4 21c0 8 0 12 -28 12h-39c-148 0 -174 -18 -228 -173c-6 -16 -7 -21 -17 -21c-7 0 -12 5 -12 11c0 0 5 16 6 18 l60 176c7 19 8 20 32 20h555c17 0 27 0 27 -11Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D400" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D447" x="1229" y="602"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D400" x="1467" y="0"></use>
</g>
</svg> and its determinant</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2543" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2543"><i></i></a><div id="fragbit-2543" class="collapse"><div class="fragmentcode">                    Float ata00 = <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(dpdu, dpdu), ata01 = <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(dpdu, dpdv);
                    Float ata11 = <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(dpdv, dpdv);
                    Float invDet = 1 / <a href="../Utilities/Mathematical_Infrastructure.html#DifferenceOfProducts" class="code">DifferenceOfProducts</a>(ata00, ata11, ata01, ata01);
                    invDet = <a href="../Shapes/Managing_Rounding_Error.html#IsFinite" class="code">IsFinite</a>(invDet) ? invDet : 0.f;</div></div>
                 &lt;&lt;<span class="fragmentname"><a href="../Textures_and_Materials/Texture_Sampling_and_Antialiasing.html#fragment-ComputetransposeXFORMAVECbforxandy-0">Compute <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.894ex" height="2.676ex" style="vertical-align: -0.338ex;" viewBox="0 -1006.6 2107.2 1152.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">bold upper A Superscript upper T Baseline bold b</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D400" d="M827 0c-35 3 -123 3 -163 3c-43 0 -138 0 -176 -3v47h95l-60 146h-268l-50 -121l-4 -12c0 -13 89 -13 89 -13v-47c-37 3 -93 3 -132 3l-117 -3v47h21c76 0 79 8 85 23l248 602c7 18 11 26 39 26c17 0 29 0 40 -26l256 -625h97v-47zM503 240l-114 278l-114 -278h228Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D447" d="M704 666c0 -3 -1 -13 -2 -17l-27 -174c-2 -15 -4 -23 -15 -23c-9 0 -12 7 -12 13c0 3 2 15 3 19c4 26 8 65 8 80c0 78 -45 82 -146 82c-21 0 -54 0 -63 -2c-12 -3 -16 -9 -23 -37l-133 -531c-4 -15 -4 -21 -4 -21c0 -16 8 -19 37 -22c26 -2 39 -2 64 -2c26 0 34 0 34 -11 c0 -20 -12 -20 -22 -20c-28 0 -58 2 -87 2l-83 1l-85 -1c-27 0 -55 -2 -82 -2c-6 0 -17 0 -17 12c0 19 6 19 42 19c107 0 110 11 119 48l134 534c1 3 4 15 4 21c0 8 0 12 -28 12h-39c-148 0 -174 -18 -228 -173c-6 -16 -7 -21 -17 -21c-7 0 -12 5 -12 11c0 0 5 16 6 18 l60 176c7 19 8 20 32 20h555c17 0 27 0 27 -11Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D41B" d="M600 223c0 -139 -103 -229 -252 -229c-89 0 -138 54 -146 62c-16 -19 -33 -37 -49 -56h-47v600c0 39 -7 39 -69 39v47l177 8v-293c24 20 74 49 147 49c145 0 239 -94 239 -227zM472 223c0 70 0 191 -122 191c-55 0 -103 -29 -130 -64v-251c10 -15 49 -69 119 -69 c32 0 78 11 107 52c26 39 26 94 26 141Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D400" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D447" x="1229" y="602"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D41B" x="1467" y="0"></use>
</g>
</svg> for <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.33ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 572.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">x</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D465" d="M527 376c0 -40 -32 -58 -54 -58c-27 0 -38 19 -38 35c0 24 20 49 48 54c-21 13 -45 13 -50 13c-70 0 -93 -92 -99 -118l-34 -137c-11 -44 -17 -66 -17 -88c0 -34 16 -66 55 -66c32 0 100 24 133 131c2 7 4 11 13 11c3 0 12 0 12 -10c0 -25 -57 -154 -160 -154 c-60 0 -96 39 -108 76c-3 -6 -39 -76 -105 -76c-44 0 -94 20 -94 66c0 32 25 58 55 58c15 0 37 -8 37 -35c0 -28 -22 -49 -47 -54c21 -13 44 -13 50 -13c44 0 79 42 95 104c37 140 54 207 54 238c0 58 -35 67 -54 67c-34 0 -100 -25 -134 -131c-2 -9 -5 -11 -13 -11 c0 0 -12 0 -12 10c0 25 57 154 161 154c29 0 83 -10 108 -76c12 23 47 76 105 76c34 0 93 -14 93 -66Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D465" x="0" y="0"></use>
</g>
</svg> and <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.139ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 490.5 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">y</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D466" d="M490 404c0 -7 0 -9 -4 -23l-96 -382c-28 -113 -131 -204 -234 -204c-62 0 -106 37 -106 87c0 49 33 65 56 65c10 0 37 -4 37 -35c0 -19 -10 -32 -20 -41c-14 -12 -27 -12 -43 -12c17 -39 62 -42 76 -42c46 0 84 29 110 63c40 53 52 102 65 154c-28 -28 -62 -45 -101 -45 c-59 0 -122 30 -122 119c0 47 18 104 58 210c7 19 17 45 17 70c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -20 -4 -31 -20 -72c-34 -88 -51 -150 -51 -196c0 -37 11 -81 62 -81 c66 0 109 70 113 85l45 180l20 80c4 18 12 49 14 54c9 15 25 21 35 21c15 0 29 -9 29 -27Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D466" x="0" y="0"></use>
</g>
</svg></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2544" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2544"><i></i></a><div id="fragbit-2544" class="collapse"><div class="fragmentcode">                    Float atb0x = <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(dpdu, dpdx), atb1x = <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(dpdv, dpdx);
                    Float atb0y = <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(dpdu, dpdy), atb1y = <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(dpdv, dpdy);</div></div>
                 &lt;&lt;<span class="fragmentname"><a href="../Textures_and_Materials/Texture_Sampling_and_Antialiasing.html#fragment-Computeuandvderivativeswithrespecttoxandy-0">Compute <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.33ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 572.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">u</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D462" d="M543 143c0 0 -13 -63 -30 -99c-16 -32 -39 -55 -74 -55c-43 0 -78 26 -89 67c-17 -22 -53 -67 -119 -67c-54 0 -123 25 -123 120c0 49 21 111 58 210c6 15 17 44 17 68c0 32 -16 33 -25 33c-38 0 -76 -37 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10 c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -17 -63c-26 -69 -54 -148 -54 -204c0 -37 10 -82 62 -82c73 0 113 80 114 84l75 301c8 34 34 35 39 35c15 0 29 -9 29 -27c0 -6 -10 -44 -15 -67c-4 -15 -14 -53 -17 -68l-28 -108c-8 -35 -20 -82 -20 -104 c0 -33 10 -46 31 -46c42 0 61 68 75 124c3 14 4 18 14 18c3 0 12 0 12 -10Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D462" x="0" y="0"></use>
</g>
</svg> and <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.128ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 485.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">v</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D463" d="M468 372c0 -52 -57 -383 -225 -383c-46 0 -134 16 -134 124c0 43 13 89 57 205c7 18 17 45 17 70c0 32 -17 32 -25 32c-29 0 -72 -23 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 38 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -12 -50 c-31 -83 -58 -156 -58 -212c0 -52 23 -87 74 -87c117 0 178 229 178 271c0 36 -13 62 -34 82c-11 11 -16 17 -16 30c0 22 24 48 49 48c18 0 44 -16 44 -70Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D463" x="0" y="0"></use>
</g>
</svg> derivatives with respect to <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.33ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 572.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">x</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D465" d="M527 376c0 -40 -32 -58 -54 -58c-27 0 -38 19 -38 35c0 24 20 49 48 54c-21 13 -45 13 -50 13c-70 0 -93 -92 -99 -118l-34 -137c-11 -44 -17 -66 -17 -88c0 -34 16 -66 55 -66c32 0 100 24 133 131c2 7 4 11 13 11c3 0 12 0 12 -10c0 -25 -57 -154 -160 -154 c-60 0 -96 39 -108 76c-3 -6 -39 -76 -105 -76c-44 0 -94 20 -94 66c0 32 25 58 55 58c15 0 37 -8 37 -35c0 -28 -22 -49 -47 -54c21 -13 44 -13 50 -13c44 0 79 42 95 104c37 140 54 207 54 238c0 58 -35 67 -54 67c-34 0 -100 -25 -134 -131c-2 -9 -5 -11 -13 -11 c0 0 -12 0 -12 10c0 25 57 154 161 154c29 0 83 -10 108 -76c12 23 47 76 105 76c34 0 93 -14 93 -66Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D465" x="0" y="0"></use>
</g>
</svg> and <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.139ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 490.5 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">y</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D466" d="M490 404c0 -7 0 -9 -4 -23l-96 -382c-28 -113 -131 -204 -234 -204c-62 0 -106 37 -106 87c0 49 33 65 56 65c10 0 37 -4 37 -35c0 -19 -10 -32 -20 -41c-14 -12 -27 -12 -43 -12c17 -39 62 -42 76 -42c46 0 84 29 110 63c40 53 52 102 65 154c-28 -28 -62 -45 -101 -45 c-59 0 -122 30 -122 119c0 47 18 104 58 210c7 19 17 45 17 70c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -20 -4 -31 -20 -72c-34 -88 -51 -150 -51 -196c0 -37 11 -81 62 -81 c66 0 109 70 113 85l45 180l20 80c4 18 12 49 14 54c9 15 25 21 35 21c15 0 29 -9 29 -27Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D466" x="0" y="0"></use>
</g>
</svg></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2545" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2545"><i></i></a><div id="fragbit-2545" class="collapse"><div class="fragmentcode">                    dudx = <a href="../Utilities/Mathematical_Infrastructure.html#DifferenceOfProducts" class="code">DifferenceOfProducts</a>(ata11, atb0x, ata01, atb1x) * invDet;
                    dvdx = <a href="../Utilities/Mathematical_Infrastructure.html#DifferenceOfProducts" class="code">DifferenceOfProducts</a>(ata00, atb1x, ata01, atb0x) * invDet;
                    dudy = <a href="../Utilities/Mathematical_Infrastructure.html#DifferenceOfProducts" class="code">DifferenceOfProducts</a>(ata11, atb0y, ata01, atb1y) * invDet;
                    dvdy = <a href="../Utilities/Mathematical_Infrastructure.html#DifferenceOfProducts" class="code">DifferenceOfProducts</a>(ata00, atb1y, ata01, atb0y) * invDet;</div></div>
                 &lt;&lt;<span class="fragmentname"><a href="../Textures_and_Materials/Texture_Sampling_and_Antialiasing.html#fragment-Clampderivativesofuandvtoreasonablevalues-0">Clamp derivatives of <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.33ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 572.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">u</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D462" d="M543 143c0 0 -13 -63 -30 -99c-16 -32 -39 -55 -74 -55c-43 0 -78 26 -89 67c-17 -22 -53 -67 -119 -67c-54 0 -123 25 -123 120c0 49 21 111 58 210c6 15 17 44 17 68c0 32 -16 33 -25 33c-38 0 -76 -37 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10 c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -17 -63c-26 -69 -54 -148 -54 -204c0 -37 10 -82 62 -82c73 0 113 80 114 84l75 301c8 34 34 35 39 35c15 0 29 -9 29 -27c0 -6 -10 -44 -15 -67c-4 -15 -14 -53 -17 -68l-28 -108c-8 -35 -20 -82 -20 -104 c0 -33 10 -46 31 -46c42 0 61 68 75 124c3 14 4 18 14 18c3 0 12 0 12 -10Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D462" x="0" y="0"></use>
</g>
</svg> and <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.128ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 485.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">v</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D463" d="M468 372c0 -52 -57 -383 -225 -383c-46 0 -134 16 -134 124c0 43 13 89 57 205c7 18 17 45 17 70c0 32 -17 32 -25 32c-29 0 -72 -23 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 38 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -12 -50 c-31 -83 -58 -156 -58 -212c0 -52 23 -87 74 -87c117 0 178 229 178 271c0 36 -13 62 -34 82c-11 11 -16 17 -16 30c0 22 24 48 49 48c18 0 44 -16 44 -70Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D463" x="0" y="0"></use>
</g>
</svg> to reasonable values</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2546" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2546"><i></i></a><div id="fragbit-2546" class="collapse"><div class="fragmentcode">                    dudx = <a href="../Shapes/Managing_Rounding_Error.html#IsFinite" class="code">IsFinite</a>(dudx) ? <a href="../Utilities/Mathematical_Infrastructure.html#Clamp" class="code">Clamp</a>(dudx, -1e8f, 1e8f) : 0.f;
                    dvdx = <a href="../Shapes/Managing_Rounding_Error.html#IsFinite" class="code">IsFinite</a>(dvdx) ? <a href="../Utilities/Mathematical_Infrastructure.html#Clamp" class="code">Clamp</a>(dvdx, -1e8f, 1e8f) : 0.f;
                    dudy = <a href="../Shapes/Managing_Rounding_Error.html#IsFinite" class="code">IsFinite</a>(dudy) ? <a href="../Utilities/Mathematical_Infrastructure.html#Clamp" class="code">Clamp</a>(dudy, -1e8f, 1e8f) : 0.f;
                    dvdy = <a href="../Shapes/Managing_Rounding_Error.html#IsFinite" class="code">IsFinite</a>(dvdy) ? <a href="../Utilities/Mathematical_Infrastructure.html#Clamp" class="code">Clamp</a>(dvdy, -1e8f, 1e8f) : 0.f;</div></div></div></div>
              </div></div>
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Computeshadingnormalifbumpornormalmappingisbeingused-0">Compute shading normal if bump or normal mapping is being used</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2547" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2547"><i></i></a><div id="fragbit-2547" class="collapse"><div class="fragmentcode">              <a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a> <a href="#MaterialEvalWorkItem::ns" class="code">ns</a> = w.<a href="#MaterialEvalWorkItem::ns" class="code">ns</a>;
              <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> <a href="#MaterialEvalWorkItem::dpdus" class="code">dpdus</a> = w.<a href="#MaterialEvalWorkItem::dpdus" class="code">dpdus</a>;
              <a href="../Textures_and_Materials/Texture_Interface_and_Basic_Textures.html#FloatTexture" class="code">FloatTexture</a> displacement = w.<a href="#MaterialEvalWorkItem::material" class="code">material</a>-&gt;<a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#Material::GetDisplacement" class="code">GetDisplacement</a>();
              const <a href="../Utilities/Images.html#Image" class="code">Image</a> *normalMap = w.<a href="#MaterialEvalWorkItem::material" class="code">material</a>-&gt;<a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#Material::GetNormalMap" class="code">GetNormalMap</a>();
              if (normalMap) {
                  &lt;&lt;<span class="fragmentname"><a href="#fragment-CallmonoNormalMaptofindshadinggeometry-0">Call <tt>NormalMap()</tt> to find shading geometry</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2548" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2548"><i></i></a><div id="fragbit-2548" class="collapse"><div class="fragmentcode">                     <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#NormalBumpEvalContext" class="code">NormalBumpEvalContext</a> bctx = w.<a href="#MaterialEvalWorkItem::GetNormalBumpEvalContext" class="code">GetNormalBumpEvalContext</a>(dudx, dudy,  
                                                                             dvdx, dvdy);
                     <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> dpdvs;
                     <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#NormalMap" class="code">NormalMap</a>(*normalMap, bctx, &amp;dpdus, &amp;dpdvs);
                     ns = <a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a>(<a href="../Geometry_and_Transformations/Vectors.html#Normalize" class="code">Normalize</a>(<a href="../Geometry_and_Transformations/Vectors.html#Cross" class="code">Cross</a>(dpdus, dpdvs)));
                     ns = <a href="../Geometry_and_Transformations/Normals.html#FaceForward" class="code">FaceForward</a>(ns, w.<a href="#MaterialEvalWorkItem::n" class="code">n</a>);</div></div>
              } else if (displacement) {
                  &lt;&lt;<span class="fragmentname">Call <tt>BumpMap()</tt> to find shading geometry</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2549" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2549"><i></i></a><div id="fragbit-2549" class="collapse"><div class="fragmentcode">                     NormalBumpEvalContext bctx = w.<a href="#MaterialEvalWorkItem::GetNormalBumpEvalContext" class="code">GetNormalBumpEvalContext</a>(dudx, dudy, dvdx, dvdy);
                     <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> dpdvs;
                     <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#BumpMap" class="code">BumpMap</a>(texEval, displacement, bctx, &amp;dpdus, &amp;dpdvs);
                     ns = <a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a>(<a href="../Geometry_and_Transformations/Vectors.html#Normalize" class="code">Normalize</a>(<a href="../Geometry_and_Transformations/Vectors.html#Cross" class="code">Cross</a>(dpdus, dpdvs)));
                     ns = <a href="../Geometry_and_Transformations/Normals.html#FaceForward" class="code">FaceForward</a>(ns, w.<a href="#MaterialEvalWorkItem::n" class="code">n</a>);</div></div>
              }</div></div>
           &lt;&lt;<span class="fragmentname"><a href="#fragment-GetBSDFatintersectionpoint-0">Get BSDF at intersection point</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2550" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2550"><i></i></a><div id="fragbit-2550" class="collapse"><div class="fragmentcode">              <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> <a href="#MaterialEvalWorkItem::lambda" class="code">lambda</a> = w.<a href="#MaterialEvalWorkItem::lambda" class="code">lambda</a>;
              <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#MaterialEvalContext" class="code">MaterialEvalContext</a> ctx = w.<a href="#MaterialEvalWorkItem::GetMaterialEvalContext" class="code">GetMaterialEvalContext</a>(dudx, dudy, dvdx, dvdy,
                                                                 <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#MaterialEvalContext::ns" class="code">ns</a>, <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#MaterialEvalContext::dpdus" class="code">dpdus</a>);
              using ConcreteBxDF = typename ConcreteMaterial::<a href="../Reflection_Models/BSDF_Representation.html#BxDF" class="code">BxDF</a>;
              ConcreteBxDF bxdf = w.<a href="#MaterialEvalWorkItem::material" class="code">material</a>-&gt;<a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#Material::GetBxDF" class="code">GetBxDF</a>(texEval, ctx, <a href="#MaterialEvalWorkItem::lambda" class="code">lambda</a>);
              <a href="../Reflection_Models/BSDF_Representation.html#BSDF" class="code">BSDF</a> bsdf(ctx.<a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#MaterialEvalContext::ns" class="code">ns</a>, ctx.<a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#MaterialEvalContext::dpdus" class="code">dpdus</a>, &amp;bxdf);
              &lt;&lt;<span class="fragmentname"><a href="#fragment-HandleterminatedsecondarywavelengthsafterBSDFcreation-0">Handle terminated secondary wavelengths after BSDF creation</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2551" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2551"><i></i></a><div id="fragbit-2551" class="collapse"><div class="fragmentcode">                 if (<a href="#PixelSampleState::lambda" class="code">lambda</a>.<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths::SecondaryTerminated" class="code">SecondaryTerminated</a>())
                     <a href="#WavefrontPathIntegrator::pixelSampleState" class="code">pixelSampleState</a>.<a href="#PixelSampleState::lambda" class="code">lambda</a>[w.<a href="#MaterialEvalWorkItem::pixelIndex" class="code">pixelIndex</a>] = <a href="#PixelSampleState::lambda" class="code">lambda</a>;</div></div></div></div>
           &lt;&lt;<span class="fragmentname"><a href="#fragment-RegularizeBSDFifappropriate-0">Regularize BSDF, if appropriate</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2552" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2552"><i></i></a><div id="fragbit-2552" class="collapse"><div class="fragmentcode">              if (<a href="#WavefrontPathIntegrator::regularize" class="code">regularize</a> &amp;&amp; w.<a href="#MaterialEvalWorkItem::anyNonSpecularBounces" class="code">anyNonSpecularBounces</a>)
                  bsdf.<a href="../Light_Transport_I_Surface_Reflection/A_Better_Path_Tracer.html#BSDF::Regularize" class="code">Regularize</a>();</div></div>
           &lt;&lt;<span class="fragmentname">Initialize <tt>VisibleSurface</tt> at first intersection if necessary</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2553" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2553"><i></i></a><div id="fragbit-2553" class="collapse"><div class="fragmentcode">              if (w.depth == 0 &amp;&amp; initializeVisibleSurface) {
                  <a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction" class="code">SurfaceInteraction</a> isect;
                  isect.pi = w.pi;
                  isect.n = w.n;
                  isect.shading.n = ns;
                  isect.uv = w.uv;
                  isect.wo = w.wo;
                  isect.time = w.time;
                  isect.dpdx = dpdx;
                  isect.dpdy = dpdy;
              
                  &lt;&lt;<span class="fragmentname"><a href="../Light_Transport_I_Surface_Reflection/A_Better_Path_Tracer.html#fragment-EstimateBSDFsalbedo-0">Estimate BSDF&rsquo;s albedo</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2554" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2554"><i></i></a><div id="fragbit-2554" class="collapse"><div class="fragmentcode">                     &lt;&lt;<span class="fragmentname">Define sample arrays <tt>ucRho</tt> and <tt>uRho</tt> for reflectance estimate</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2555" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2555"><i></i></a><div id="fragbit-2555" class="collapse"><div class="fragmentcode">                        constexpr int nRhoSamples = 16;
                        const Float ucRho[nRhoSamples] = { 0.75741637, 0.37870818, 0.7083487, 0.18935409, 0.9149363, 0.35417435, 0.5990858, 0.09467703, 0.8578725, 0.45746812, 0.686759, 0.17708716, 0.9674518, 0.2995429, 0.5083201, 0.047338516 };
                        const <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a> uRho[nRhoSamples] = { <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.855985, 0.570367), <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.381823, 0.851844), <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.285328, 0.764262), <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.733380, 0.114073), <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.542663, 0.344465), <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.127274, 0.414848), <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.964700, 0.947162), <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.594089, 0.643463), <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.095109, 0.170369), <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.825444, 0.263359), <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.429467, 0.454469), <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.244460, 0.816459), <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.756135, 0.731258), <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.516165, 0.152852), <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.180888, 0.214174), <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.898579, 0.503897) };</div></div>
                     <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> albedo = bsdf.<a href="../Reflection_Models/BSDF_Representation.html#BSDF::rho" class="code">rho</a>(isect.<a href="../Geometry_and_Transformations/Interactions.html#Interaction::wo" class="code">wo</a>, ucRho, uRho);</div></div>
              
                  pixelSampleState.visibleSurface[w.pixelIndex] =
                      <a href="../Cameras_and_Film/Film_and_Imaging.html#VisibleSurface" class="code">VisibleSurface</a>(isect, albedo, lambda);
              }</div></div>
           &lt;&lt;<span class="fragmentname"><a href="#fragment-SampleBSDFandenqueueindirectrayatintersectionpoint-0">Sample BSDF and enqueue indirect ray at intersection point</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2556" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2556"><i></i></a><div id="fragbit-2556" class="collapse"><div class="fragmentcode">              <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> <a href="#MaterialEvalWorkItem::wo" class="code">wo</a> = w.<a href="#MaterialEvalWorkItem::wo" class="code">wo</a>;
              <a href="#RaySamples" class="code">RaySamples</a> raySamples = <a href="#WavefrontPathIntegrator::pixelSampleState" class="code">pixelSampleState</a>.<a href="#PixelSampleState::samples" class="code">samples</a>[w.<a href="#MaterialEvalWorkItem::pixelIndex" class="code">pixelIndex</a>];
              pstd::optional&lt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample" class="code">BSDFSample</a>&gt; bsdfSample =
                  bsdf.<a href="../Reflection_Models/BSDF_Representation.html#BSDF::Sample_f" class="code">Sample_f</a>&lt;ConcreteBxDF&gt;(<a href="#MaterialEvalWorkItem::wo" class="code">wo</a>, raySamples.indirect.<a href="#RaySamples::indirect::uc" class="code">uc</a>,
                                              raySamples.indirect.<a href="#RaySamples::indirect::u" class="code">u</a>);
              if (bsdfSample) {
                  &lt;&lt;<span class="fragmentname"><a href="#fragment-ComputeupdatedpaththroughputandPDFsandenqueueindirectray-0">Compute updated path throughput and PDFs and enqueue indirect ray</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2557" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2557"><i></i></a><div id="fragbit-2557" class="collapse"><div class="fragmentcode">                     <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> <a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::wi" class="code">wi</a> = bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::wi" class="code">wi</a>;
                     <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <a href="#MaterialEvalWorkItem::beta" class="code">beta</a> = w.<a href="#MaterialEvalWorkItem::beta" class="code">beta</a> * bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::f" class="code">f</a> * <a href="../Geometry_and_Transformations/Vectors.html#AbsDot" class="code">AbsDot</a>(<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::wi" class="code">wi</a>, ns)/bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::pdf" class="code">pdf</a>;
                     <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <a href="#MaterialEvalWorkItem::r_u" class="code">r_u</a> = w.<a href="#MaterialEvalWorkItem::r_u" class="code">r_u</a>, r_l;
                     &lt;&lt;<span class="fragmentname"><a href="#fragment-Updatemonor_ubasedonBSDFsamplePDF-0">Update <tt>r_u</tt> based on BSDF sample PDF</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2558" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2558"><i></i></a><div id="fragbit-2558" class="collapse"><div class="fragmentcode">                        if (bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::pdfIsProportional" class="code">pdfIsProportional</a>)
                            r_l = r_u / bsdf.<a href="../Reflection_Models/BSDF_Representation.html#BSDF::PDF" class="code">PDF</a>&lt;ConcreteBxDF&gt;(wo, bsdfSample-&gt;wi);
                        else
                            r_l = r_u / bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::pdf" class="code">pdf</a>;</div></div>
                     &lt;&lt;<span class="fragmentname"><a href="#fragment-UpdatemonoetaScaleaccountingforBSDFscattering-0">Update <tt>etaScale</tt> accounting for BSDF scattering</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2559" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2559"><i></i></a><div id="fragbit-2559" class="collapse"><div class="fragmentcode">                        Float <a href="#MaterialEvalWorkItem::etaScale" class="code">etaScale</a> = w.<a href="#MaterialEvalWorkItem::etaScale" class="code">etaScale</a>;
                        if (bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::IsTransmission" class="code">IsTransmission</a>())
                            <a href="#MaterialEvalWorkItem::etaScale" class="code">etaScale</a> *= <a href="../Utilities/Mathematical_Infrastructure.html#Sqr" class="code">Sqr</a>(bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::eta" class="code">eta</a>);</div></div>
                     &lt;&lt;<span class="fragmentname">Apply Russian roulette to indirect ray based on weighted path throughput</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2560" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2560"><i></i></a><div id="fragbit-2560" class="collapse"><div class="fragmentcode">                        <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> rrBeta = beta * etaScale / r_u.Average();
                        // Note: depth &gt;= 1 here to match VolPathIntegrator (which increments depth earlier).
                        if (rrBeta.MaxComponentValue() &lt; 1 &amp;&amp; w.depth &gt;= 1) {
                            Float q = std::max&lt;Float&gt;(0, 1 - rrBeta.MaxComponentValue());
                            if (raySamples.indirect.rr &lt; q) {
                                beta = <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a>(0.f);
                                PBRT_DBG("Path terminated with RR\n");
                            } else
                                beta /= 1 - q;
                        }</div></div>
                     if (<a href="#MaterialEvalWorkItem::beta" class="code">beta</a>) {
                         &lt;&lt;<span class="fragmentname"><a href="#fragment-Initializespawnedrayandenqueuefornextraydepth-0">Initialize spawned ray and enqueue for next ray depth</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2561" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2561"><i></i></a><div id="fragbit-2561" class="collapse"><div class="fragmentcode">                            <a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> ray = <a href="../Shapes/Managing_Rounding_Error.html#SpawnRay" class="code">SpawnRay</a>(w.<a href="#MaterialEvalWorkItem::pi" class="code">pi</a>, w.<a href="#MaterialEvalWorkItem::n" class="code">n</a>, w.<a href="#MaterialEvalWorkItem::time" class="code">time</a>, wi);
                            &lt;&lt;<span class="fragmentname"><a href="#fragment-Initializemonoraymediumifmediaarepresent-0">Initialize <tt>ray</tt> medium if media are present</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2562" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2562"><i></i></a><div id="fragbit-2562" class="collapse"><div class="fragmentcode">                               if (haveMedia)
                                   ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::medium" class="code">medium</a> = <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::d" class="code">d</a>, w.<a href="#MaterialEvalWorkItem::n" class="code">n</a>) &gt; 0 ? w.<a href="#MaterialEvalWorkItem::mediumInterface" class="code">mediumInterface</a>.outside
                                                                    : w.<a href="#MaterialEvalWorkItem::mediumInterface" class="code">mediumInterface</a>.inside;</div></div>
                            bool <a href="#MaterialEvalWorkItem::anyNonSpecularBounces" class="code">anyNonSpecularBounces</a> = !bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::IsSpecular" class="code">IsSpecular</a>() ||
                                                         w.<a href="#MaterialEvalWorkItem::anyNonSpecularBounces" class="code">anyNonSpecularBounces</a>;
                            <a href="../Light_Sources/Light_Interface.html#LightSampleContext" class="code">LightSampleContext</a> ctx(w.<a href="#MaterialEvalWorkItem::pi" class="code">pi</a>, w.<a href="#MaterialEvalWorkItem::n" class="code">n</a>, ns);
                            nextRayQueue-&gt;<a href="#RayQueue::PushIndirectRay" class="code">PushIndirectRay</a>(
                                ray, w.<a href="#MaterialEvalWorkItem::depth" class="code">depth</a> + 1, ctx, beta, r_u, r_l, lambda,
                                etaScale, bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::IsSpecular" class="code">IsSpecular</a>(), <a href="#MaterialEvalWorkItem::anyNonSpecularBounces" class="code">anyNonSpecularBounces</a>, w.<a href="#MaterialEvalWorkItem::pixelIndex" class="code">pixelIndex</a>);
                            </div></div>
                     }</div></div>
              }</div></div>
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Samplelightandenqueueshadowrayatintersectionpoint-0">Sample light and enqueue shadow ray at intersection point</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2563" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2563"><i></i></a><div id="fragbit-2563" class="collapse"><div class="fragmentcode">              <a href="../Reflection_Models/BSDF_Representation.html#BxDFFlags" class="code">BxDFFlags</a> flags = bsdf.<a href="../Reflection_Models/BSDF_Representation.html#BSDF::Flags" class="code">Flags</a>();
              if (<a href="../Reflection_Models/BSDF_Representation.html#BxDFFlags::IsNonSpecular" class="code">IsNonSpecular</a>(flags)) {
                  &lt;&lt;<span class="fragmentname">Choose a light source using the <tt>LightSampler</tt></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2564" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2564"><i></i></a><div id="fragbit-2564" class="collapse"><div class="fragmentcode">                     <a href="../Light_Sources/Light_Interface.html#LightSampleContext" class="code">LightSampleContext</a> ctx(w.pi, w.n, ns);
                     if (IsReflective(flags) &amp;&amp; !IsTransmissive(flags))
                         ctx.pi = OffsetRayOrigin(ctx.pi, w.n, wo);
                     else if (IsTransmissive(flags) &amp;&amp; IsReflective(flags))
                         ctx.pi = OffsetRayOrigin(ctx.pi, w.n, -wo);
                     pstd::optional&lt;SampledLight&gt; sampledLight =
                         lightSampler.Sample(ctx, raySamples.direct.uc);
                     if (!sampledLight)
                         return;
                     <a href="../Light_Sources/Light_Interface.html#Light" class="code">Light</a> light = sampledLight-&gt;light;</div></div>
                  &lt;&lt;<span class="fragmentname">Sample light source and evaluate BSDF for direct lighting</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2565" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2565"><i></i></a><div id="fragbit-2565" class="collapse"><div class="fragmentcode">                     pstd::optional&lt;<a href="../Light_Sources/Light_Interface.html#LightLiSample" class="code">LightLiSample</a>&gt; ls =
                         light.<a href="../Light_Sources/Light_Interface.html#Light::SampleLi" class="code">SampleLi</a>(ctx, raySamples.direct.<a href="#RaySamples::direct::u" class="code">u</a>, lambda,
                         true);
                     if (!ls || !ls-&gt;<a href="../Light_Sources/Light_Interface.html#LightLiSample::L" class="code">L</a> || ls-&gt;<a href="../Light_Sources/Light_Interface.html#LightLiSample::pdf" class="code">pdf</a> == 0) return;
                     <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> <a href="../Light_Sources/Light_Interface.html#LightLiSample::wi" class="code">wi</a> = ls-&gt;<a href="../Light_Sources/Light_Interface.html#LightLiSample::wi" class="code">wi</a>;
                     <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> f = bsdf.f&lt;ConcreteBxDF&gt;(wo, <a href="../Light_Sources/Light_Interface.html#LightLiSample::wi" class="code">wi</a>);
                     if (!f) return;</div></div>
                  &lt;&lt;<span class="fragmentname"><a href="#fragment-ComputepaththroughputandpathPDFsforlightsample-0">Compute path throughput and path PDFs for light sample</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2566" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2566"><i></i></a><div id="fragbit-2566" class="collapse"><div class="fragmentcode">                     <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <a href="#MaterialEvalWorkItem::beta" class="code">beta</a> = w.<a href="#MaterialEvalWorkItem::beta" class="code">beta</a> * f * <a href="../Geometry_and_Transformations/Vectors.html#AbsDot" class="code">AbsDot</a>(wi, ns);
                     Float lightPDF = ls-&gt;<a href="../Light_Sources/Light_Interface.html#LightLiSample::pdf" class="code">pdf</a> * sampledLight-&gt;<a href="../Light_Sources/Light_Sampling.html#SampledLight::p" class="code">p</a>;
                     Float bsdfPDF = <a href="../Light_Sources/Light_Interface.html#IsDeltaLight" class="code">IsDeltaLight</a>(light.<a href="../Light_Sources/Light_Interface.html#Light::Type" class="code">Type</a>()) ? 0.f
                                                                : bsdf.<a href="../Reflection_Models/BSDF_Representation.html#BSDF::PDF" class="code">PDF</a>&lt;ConcreteBxDF&gt;(wo, wi);
                     <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <a href="#MaterialEvalWorkItem::r_u" class="code">r_u</a> = w.<a href="#MaterialEvalWorkItem::r_u" class="code">r_u</a> * bsdfPDF;
                     <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> r_l = w.<a href="#MaterialEvalWorkItem::r_u" class="code">r_u</a> * lightPDF;</div></div>
                  &lt;&lt;<span class="fragmentname"><a href="#fragment-Enqueueshadowraywithtentativeradiancecontribution-0">Enqueue shadow ray with tentative radiance contribution</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2567" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2567"><i></i></a><div id="fragbit-2567" class="collapse"><div class="fragmentcode">                     <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> Ld = beta * ls-&gt;<a href="../Light_Sources/Light_Interface.html#LightLiSample::L" class="code">L</a>;
                     <a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> ray = <a href="../Shapes/Managing_Rounding_Error.html#SpawnRayTo" class="code">SpawnRayTo</a>(w.<a href="../Geometry_and_Transformations/Interactions.html#Interaction::pi" class="code">pi</a>, w.<a href="../Geometry_and_Transformations/Interactions.html#Interaction::n" class="code">n</a>, w.<a href="#MaterialEvalWorkItem::time" class="code">time</a>, ls-&gt;<a href="../Light_Sources/Light_Interface.html#LightLiSample::pLight" class="code">pLight</a>.<a href="../Geometry_and_Transformations/Interactions.html#Interaction::pi" class="code">pi</a>, ls-&gt;<a href="../Light_Sources/Light_Interface.html#LightLiSample::pLight" class="code">pLight</a>.<a href="../Geometry_and_Transformations/Interactions.html#Interaction::n" class="code">n</a>);
                     &lt;&lt;<span class="fragmentname"><a href="#fragment-Initializemonoraymediumifmediaarepresent-0">Initialize <tt>ray</tt> medium if media are present</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2568" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2568"><i></i></a><div id="fragbit-2568" class="collapse"><div class="fragmentcode">                        if (haveMedia)
                            ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::medium" class="code">medium</a> = <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::d" class="code">d</a>, w.<a href="#MaterialEvalWorkItem::n" class="code">n</a>) &gt; 0 ? w.<a href="#MaterialEvalWorkItem::mediumInterface" class="code">mediumInterface</a>.outside
                                                             : w.<a href="#MaterialEvalWorkItem::mediumInterface" class="code">mediumInterface</a>.inside;</div></div>
                     <a href="#WavefrontPathIntegrator::shadowRayQueue" class="code">shadowRayQueue</a>-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#WorkQueue::Push" class="code">Push</a>(ShadowRayWorkItem{ray, 1 - <a href="../Shapes/Managing_Rounding_Error.html#ShadowEpsilon" class="code">ShadowEpsilon</a>, lambda, Ld,
                                                            r_u, r_l, w.<a href="#MaterialEvalWorkItem::pixelIndex" class="code">pixelIndex</a>});
                     </div></div>
              }</div></div></div></div>
    });</div><p>


</p>
<p>

</p>
<p>The structure of the material evaluation and sampling kernel parallels that
of the surface-scattering&ndash;focused part of <a href="../Light_Transport_II_Volume_Rendering/Volume_Scattering_Integrators.html#VolPathIntegrator::Li"><tt>VolPathIntegrator::Li()</tt></a>.
 
</p>
<span class="anchor" id="fragment-EvaluatematerialandBSDFforrayintersection-0"></span><div class="fragmentname">&lt;&lt;Evaluate material and BSDF for ray intersection&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#TextureEvaluator" class="code">TextureEvaluator</a> texEval;
&lt;&lt;<span class="fragmentname"><a href="#fragment-Computedifferentialsforpositionanduvatintersectionpoint-0">Compute differentials for position and <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.301ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 2282.2 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">left-parenthesis u comma v right-parenthesis</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-28" d="M332 -238c0 -5 -5 -10 -10 -10c-2 0 -4 1 -6 2c-110 83 -215 283 -215 454v84c0 171 105 371 215 454c2 1 4 2 6 2c5 0 10 -5 10 -10c0 -3 -2 -6 -4 -8c-104 -78 -173 -278 -173 -438v-84c0 -160 69 -360 173 -438c2 -2 4 -5 4 -8Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D462" d="M543 143c0 0 -13 -63 -30 -99c-16 -32 -39 -55 -74 -55c-43 0 -78 26 -89 67c-17 -22 -53 -67 -119 -67c-54 0 -123 25 -123 120c0 49 21 111 58 210c6 15 17 44 17 68c0 32 -16 33 -25 33c-38 0 -76 -37 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10 c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -17 -63c-26 -69 -54 -148 -54 -204c0 -37 10 -82 62 -82c73 0 113 80 114 84l75 301c8 34 34 35 39 35c15 0 29 -9 29 -27c0 -6 -10 -44 -15 -67c-4 -15 -14 -53 -17 -68l-28 -108c-8 -35 -20 -82 -20 -104 c0 -33 10 -46 31 -46c42 0 61 68 75 124c3 14 4 18 14 18c3 0 12 0 12 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2C" d="M203 1c0 -117 -80 -194 -91 -194c-5 0 -10 4 -10 11c0 3 0 5 11 16c33 33 68 93 68 167c0 14 -2 15 -2 15s-2 -1 -5 -3c-10 -9 -23 -13 -35 -13c-33 0 -53 26 -53 53c0 28 20 53 53 53c39 0 64 -39 64 -105Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D463" d="M468 372c0 -52 -57 -383 -225 -383c-46 0 -134 16 -134 124c0 43 13 89 57 205c7 18 17 45 17 70c0 32 -17 32 -25 32c-29 0 -72 -23 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 38 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -12 -50 c-31 -83 -58 -156 -58 -212c0 -52 23 -87 74 -87c117 0 178 229 178 271c0 36 -13 62 -34 82c-11 11 -16 17 -16 30c0 22 24 48 49 48c18 0 44 -16 44 -70Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-29" d="M288 208c0 -171 -105 -371 -215 -454c-2 -1 -4 -2 -6 -2c-5 0 -10 5 -10 10c0 3 2 6 4 8c104 78 173 278 173 438v84c0 160 -69 360 -173 438c-2 2 -4 5 -4 8c0 5 5 10 10 10c2 0 4 -1 6 -2c110 -83 215 -283 215 -454v-84Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-28" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D462" x="389" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="962" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D463" x="1407" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-29" x="1892" y="0"></use>
</g>
</svg> at intersection point</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2569" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2569"><i></i></a><div id="fragbit-2569" class="collapse"><div class="fragmentcode">   <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> dpdx, dpdy;
   Float dudx = 0, dudy = 0, dvdx = 0, dvdy = 0;
   <a href="#WavefrontPathIntegrator::camera" class="code">camera</a>.<a href="../Textures_and_Materials/Texture_Sampling_and_Antialiasing.html#Camera::Approximate_dp_dxy" class="code">Approximate_dp_dxy</a>(<a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a>(w.<a href="#MaterialEvalWorkItem::pi" class="code">pi</a>), w.<a href="#MaterialEvalWorkItem::n" class="code">n</a>, w.<a href="#MaterialEvalWorkItem::time" class="code">time</a>, <a href="#WavefrontPathIntegrator::samplesPerPixel" class="code">samplesPerPixel</a>,
                             &amp;dpdx, &amp;dpdy);
   <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> <a href="#MaterialEvalWorkItem::dpdu" class="code">dpdu</a> = w.<a href="#MaterialEvalWorkItem::dpdu" class="code">dpdu</a>, <a href="#MaterialEvalWorkItem::dpdv" class="code">dpdv</a> = w.<a href="#MaterialEvalWorkItem::dpdv" class="code">dpdv</a>;
   &lt;&lt;<span class="fragmentname"><a href="../Textures_and_Materials/Texture_Sampling_and_Antialiasing.html#fragment-Estimatescreen-spacechangeinuv-0">Estimate screen-space change in <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.301ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 2282.2 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">left-parenthesis u comma v right-parenthesis</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-28" d="M332 -238c0 -5 -5 -10 -10 -10c-2 0 -4 1 -6 2c-110 83 -215 283 -215 454v84c0 171 105 371 215 454c2 1 4 2 6 2c5 0 10 -5 10 -10c0 -3 -2 -6 -4 -8c-104 -78 -173 -278 -173 -438v-84c0 -160 69 -360 173 -438c2 -2 4 -5 4 -8Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D462" d="M543 143c0 0 -13 -63 -30 -99c-16 -32 -39 -55 -74 -55c-43 0 -78 26 -89 67c-17 -22 -53 -67 -119 -67c-54 0 -123 25 -123 120c0 49 21 111 58 210c6 15 17 44 17 68c0 32 -16 33 -25 33c-38 0 -76 -37 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10 c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -17 -63c-26 -69 -54 -148 -54 -204c0 -37 10 -82 62 -82c73 0 113 80 114 84l75 301c8 34 34 35 39 35c15 0 29 -9 29 -27c0 -6 -10 -44 -15 -67c-4 -15 -14 -53 -17 -68l-28 -108c-8 -35 -20 -82 -20 -104 c0 -33 10 -46 31 -46c42 0 61 68 75 124c3 14 4 18 14 18c3 0 12 0 12 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2C" d="M203 1c0 -117 -80 -194 -91 -194c-5 0 -10 4 -10 11c0 3 0 5 11 16c33 33 68 93 68 167c0 14 -2 15 -2 15s-2 -1 -5 -3c-10 -9 -23 -13 -35 -13c-33 0 -53 26 -53 53c0 28 20 53 53 53c39 0 64 -39 64 -105Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D463" d="M468 372c0 -52 -57 -383 -225 -383c-46 0 -134 16 -134 124c0 43 13 89 57 205c7 18 17 45 17 70c0 32 -17 32 -25 32c-29 0 -72 -23 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 38 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -12 -50 c-31 -83 -58 -156 -58 -212c0 -52 23 -87 74 -87c117 0 178 229 178 271c0 36 -13 62 -34 82c-11 11 -16 17 -16 30c0 22 24 48 49 48c18 0 44 -16 44 -70Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-29" d="M288 208c0 -171 -105 -371 -215 -454c-2 -1 -4 -2 -6 -2c-5 0 -10 5 -10 10c0 3 2 6 4 8c104 78 173 278 173 438v84c0 160 -69 360 -173 438c-2 2 -4 5 -4 8c0 5 5 10 10 10c2 0 4 -1 6 -2c110 -83 215 -283 215 -454v-84Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-28" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D462" x="389" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="962" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D463" x="1407" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-29" x="1892" y="0"></use>
</g>
</svg></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2570" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2570"><i></i></a><div id="fragbit-2570" class="collapse"><div class="fragmentcode">      &lt;&lt;<span class="fragmentname"><a href="../Textures_and_Materials/Texture_Sampling_and_Antialiasing.html#fragment-ComputetransposeXFORMAXFORMAanditsdeterminant-0">Compute <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.428ex" height="2.676ex" style="vertical-align: -0.338ex;" viewBox="0 -1006.6 2337.2 1152.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">bold upper A Superscript upper T Baseline bold upper A</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D400" d="M827 0c-35 3 -123 3 -163 3c-43 0 -138 0 -176 -3v47h95l-60 146h-268l-50 -121l-4 -12c0 -13 89 -13 89 -13v-47c-37 3 -93 3 -132 3l-117 -3v47h21c76 0 79 8 85 23l248 602c7 18 11 26 39 26c17 0 29 0 40 -26l256 -625h97v-47zM503 240l-114 278l-114 -278h228Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D447" d="M704 666c0 -3 -1 -13 -2 -17l-27 -174c-2 -15 -4 -23 -15 -23c-9 0 -12 7 -12 13c0 3 2 15 3 19c4 26 8 65 8 80c0 78 -45 82 -146 82c-21 0 -54 0 -63 -2c-12 -3 -16 -9 -23 -37l-133 -531c-4 -15 -4 -21 -4 -21c0 -16 8 -19 37 -22c26 -2 39 -2 64 -2c26 0 34 0 34 -11 c0 -20 -12 -20 -22 -20c-28 0 -58 2 -87 2l-83 1l-85 -1c-27 0 -55 -2 -82 -2c-6 0 -17 0 -17 12c0 19 6 19 42 19c107 0 110 11 119 48l134 534c1 3 4 15 4 21c0 8 0 12 -28 12h-39c-148 0 -174 -18 -228 -173c-6 -16 -7 -21 -17 -21c-7 0 -12 5 -12 11c0 0 5 16 6 18 l60 176c7 19 8 20 32 20h555c17 0 27 0 27 -11Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D400" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D447" x="1229" y="602"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D400" x="1467" y="0"></use>
</g>
</svg> and its determinant</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2571" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2571"><i></i></a><div id="fragbit-2571" class="collapse"><div class="fragmentcode">         Float ata00 = <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(dpdu, dpdu), ata01 = <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(dpdu, dpdv);
         Float ata11 = <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(dpdv, dpdv);
         Float invDet = 1 / <a href="../Utilities/Mathematical_Infrastructure.html#DifferenceOfProducts" class="code">DifferenceOfProducts</a>(ata00, ata11, ata01, ata01);
         invDet = <a href="../Shapes/Managing_Rounding_Error.html#IsFinite" class="code">IsFinite</a>(invDet) ? invDet : 0.f;</div></div>
      &lt;&lt;<span class="fragmentname"><a href="../Textures_and_Materials/Texture_Sampling_and_Antialiasing.html#fragment-ComputetransposeXFORMAVECbforxandy-0">Compute <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.894ex" height="2.676ex" style="vertical-align: -0.338ex;" viewBox="0 -1006.6 2107.2 1152.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">bold upper A Superscript upper T Baseline bold b</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D400" d="M827 0c-35 3 -123 3 -163 3c-43 0 -138 0 -176 -3v47h95l-60 146h-268l-50 -121l-4 -12c0 -13 89 -13 89 -13v-47c-37 3 -93 3 -132 3l-117 -3v47h21c76 0 79 8 85 23l248 602c7 18 11 26 39 26c17 0 29 0 40 -26l256 -625h97v-47zM503 240l-114 278l-114 -278h228Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D447" d="M704 666c0 -3 -1 -13 -2 -17l-27 -174c-2 -15 -4 -23 -15 -23c-9 0 -12 7 -12 13c0 3 2 15 3 19c4 26 8 65 8 80c0 78 -45 82 -146 82c-21 0 -54 0 -63 -2c-12 -3 -16 -9 -23 -37l-133 -531c-4 -15 -4 -21 -4 -21c0 -16 8 -19 37 -22c26 -2 39 -2 64 -2c26 0 34 0 34 -11 c0 -20 -12 -20 -22 -20c-28 0 -58 2 -87 2l-83 1l-85 -1c-27 0 -55 -2 -82 -2c-6 0 -17 0 -17 12c0 19 6 19 42 19c107 0 110 11 119 48l134 534c1 3 4 15 4 21c0 8 0 12 -28 12h-39c-148 0 -174 -18 -228 -173c-6 -16 -7 -21 -17 -21c-7 0 -12 5 -12 11c0 0 5 16 6 18 l60 176c7 19 8 20 32 20h555c17 0 27 0 27 -11Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D41B" d="M600 223c0 -139 -103 -229 -252 -229c-89 0 -138 54 -146 62c-16 -19 -33 -37 -49 -56h-47v600c0 39 -7 39 -69 39v47l177 8v-293c24 20 74 49 147 49c145 0 239 -94 239 -227zM472 223c0 70 0 191 -122 191c-55 0 -103 -29 -130 -64v-251c10 -15 49 -69 119 -69 c32 0 78 11 107 52c26 39 26 94 26 141Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D400" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D447" x="1229" y="602"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D41B" x="1467" y="0"></use>
</g>
</svg> for <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.33ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 572.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">x</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D465" d="M527 376c0 -40 -32 -58 -54 -58c-27 0 -38 19 -38 35c0 24 20 49 48 54c-21 13 -45 13 -50 13c-70 0 -93 -92 -99 -118l-34 -137c-11 -44 -17 -66 -17 -88c0 -34 16 -66 55 -66c32 0 100 24 133 131c2 7 4 11 13 11c3 0 12 0 12 -10c0 -25 -57 -154 -160 -154 c-60 0 -96 39 -108 76c-3 -6 -39 -76 -105 -76c-44 0 -94 20 -94 66c0 32 25 58 55 58c15 0 37 -8 37 -35c0 -28 -22 -49 -47 -54c21 -13 44 -13 50 -13c44 0 79 42 95 104c37 140 54 207 54 238c0 58 -35 67 -54 67c-34 0 -100 -25 -134 -131c-2 -9 -5 -11 -13 -11 c0 0 -12 0 -12 10c0 25 57 154 161 154c29 0 83 -10 108 -76c12 23 47 76 105 76c34 0 93 -14 93 -66Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D465" x="0" y="0"></use>
</g>
</svg> and <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.139ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 490.5 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">y</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D466" d="M490 404c0 -7 0 -9 -4 -23l-96 -382c-28 -113 -131 -204 -234 -204c-62 0 -106 37 -106 87c0 49 33 65 56 65c10 0 37 -4 37 -35c0 -19 -10 -32 -20 -41c-14 -12 -27 -12 -43 -12c17 -39 62 -42 76 -42c46 0 84 29 110 63c40 53 52 102 65 154c-28 -28 -62 -45 -101 -45 c-59 0 -122 30 -122 119c0 47 18 104 58 210c7 19 17 45 17 70c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -20 -4 -31 -20 -72c-34 -88 -51 -150 -51 -196c0 -37 11 -81 62 -81 c66 0 109 70 113 85l45 180l20 80c4 18 12 49 14 54c9 15 25 21 35 21c15 0 29 -9 29 -27Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D466" x="0" y="0"></use>
</g>
</svg></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2572" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2572"><i></i></a><div id="fragbit-2572" class="collapse"><div class="fragmentcode">         Float atb0x = <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(dpdu, dpdx), atb1x = <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(dpdv, dpdx);
         Float atb0y = <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(dpdu, dpdy), atb1y = <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(dpdv, dpdy);</div></div>
      &lt;&lt;<span class="fragmentname"><a href="../Textures_and_Materials/Texture_Sampling_and_Antialiasing.html#fragment-Computeuandvderivativeswithrespecttoxandy-0">Compute <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.33ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 572.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">u</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D462" d="M543 143c0 0 -13 -63 -30 -99c-16 -32 -39 -55 -74 -55c-43 0 -78 26 -89 67c-17 -22 -53 -67 -119 -67c-54 0 -123 25 -123 120c0 49 21 111 58 210c6 15 17 44 17 68c0 32 -16 33 -25 33c-38 0 -76 -37 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10 c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -17 -63c-26 -69 -54 -148 -54 -204c0 -37 10 -82 62 -82c73 0 113 80 114 84l75 301c8 34 34 35 39 35c15 0 29 -9 29 -27c0 -6 -10 -44 -15 -67c-4 -15 -14 -53 -17 -68l-28 -108c-8 -35 -20 -82 -20 -104 c0 -33 10 -46 31 -46c42 0 61 68 75 124c3 14 4 18 14 18c3 0 12 0 12 -10Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D462" x="0" y="0"></use>
</g>
</svg> and <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.128ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 485.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">v</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D463" d="M468 372c0 -52 -57 -383 -225 -383c-46 0 -134 16 -134 124c0 43 13 89 57 205c7 18 17 45 17 70c0 32 -17 32 -25 32c-29 0 -72 -23 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 38 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -12 -50 c-31 -83 -58 -156 -58 -212c0 -52 23 -87 74 -87c117 0 178 229 178 271c0 36 -13 62 -34 82c-11 11 -16 17 -16 30c0 22 24 48 49 48c18 0 44 -16 44 -70Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D463" x="0" y="0"></use>
</g>
</svg> derivatives with respect to <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.33ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 572.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">x</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D465" d="M527 376c0 -40 -32 -58 -54 -58c-27 0 -38 19 -38 35c0 24 20 49 48 54c-21 13 -45 13 -50 13c-70 0 -93 -92 -99 -118l-34 -137c-11 -44 -17 -66 -17 -88c0 -34 16 -66 55 -66c32 0 100 24 133 131c2 7 4 11 13 11c3 0 12 0 12 -10c0 -25 -57 -154 -160 -154 c-60 0 -96 39 -108 76c-3 -6 -39 -76 -105 -76c-44 0 -94 20 -94 66c0 32 25 58 55 58c15 0 37 -8 37 -35c0 -28 -22 -49 -47 -54c21 -13 44 -13 50 -13c44 0 79 42 95 104c37 140 54 207 54 238c0 58 -35 67 -54 67c-34 0 -100 -25 -134 -131c-2 -9 -5 -11 -13 -11 c0 0 -12 0 -12 10c0 25 57 154 161 154c29 0 83 -10 108 -76c12 23 47 76 105 76c34 0 93 -14 93 -66Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D465" x="0" y="0"></use>
</g>
</svg> and <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.139ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 490.5 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">y</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D466" d="M490 404c0 -7 0 -9 -4 -23l-96 -382c-28 -113 -131 -204 -234 -204c-62 0 -106 37 -106 87c0 49 33 65 56 65c10 0 37 -4 37 -35c0 -19 -10 -32 -20 -41c-14 -12 -27 -12 -43 -12c17 -39 62 -42 76 -42c46 0 84 29 110 63c40 53 52 102 65 154c-28 -28 -62 -45 -101 -45 c-59 0 -122 30 -122 119c0 47 18 104 58 210c7 19 17 45 17 70c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -20 -4 -31 -20 -72c-34 -88 -51 -150 -51 -196c0 -37 11 -81 62 -81 c66 0 109 70 113 85l45 180l20 80c4 18 12 49 14 54c9 15 25 21 35 21c15 0 29 -9 29 -27Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D466" x="0" y="0"></use>
</g>
</svg></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2573" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2573"><i></i></a><div id="fragbit-2573" class="collapse"><div class="fragmentcode">         dudx = <a href="../Utilities/Mathematical_Infrastructure.html#DifferenceOfProducts" class="code">DifferenceOfProducts</a>(ata11, atb0x, ata01, atb1x) * invDet;
         dvdx = <a href="../Utilities/Mathematical_Infrastructure.html#DifferenceOfProducts" class="code">DifferenceOfProducts</a>(ata00, atb1x, ata01, atb0x) * invDet;
         dudy = <a href="../Utilities/Mathematical_Infrastructure.html#DifferenceOfProducts" class="code">DifferenceOfProducts</a>(ata11, atb0y, ata01, atb1y) * invDet;
         dvdy = <a href="../Utilities/Mathematical_Infrastructure.html#DifferenceOfProducts" class="code">DifferenceOfProducts</a>(ata00, atb1y, ata01, atb0y) * invDet;</div></div>
      &lt;&lt;<span class="fragmentname"><a href="../Textures_and_Materials/Texture_Sampling_and_Antialiasing.html#fragment-Clampderivativesofuandvtoreasonablevalues-0">Clamp derivatives of <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.33ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 572.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">u</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D462" d="M543 143c0 0 -13 -63 -30 -99c-16 -32 -39 -55 -74 -55c-43 0 -78 26 -89 67c-17 -22 -53 -67 -119 -67c-54 0 -123 25 -123 120c0 49 21 111 58 210c6 15 17 44 17 68c0 32 -16 33 -25 33c-38 0 -76 -37 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10 c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -17 -63c-26 -69 -54 -148 -54 -204c0 -37 10 -82 62 -82c73 0 113 80 114 84l75 301c8 34 34 35 39 35c15 0 29 -9 29 -27c0 -6 -10 -44 -15 -67c-4 -15 -14 -53 -17 -68l-28 -108c-8 -35 -20 -82 -20 -104 c0 -33 10 -46 31 -46c42 0 61 68 75 124c3 14 4 18 14 18c3 0 12 0 12 -10Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D462" x="0" y="0"></use>
</g>
</svg> and <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.128ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 485.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">v</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D463" d="M468 372c0 -52 -57 -383 -225 -383c-46 0 -134 16 -134 124c0 43 13 89 57 205c7 18 17 45 17 70c0 32 -17 32 -25 32c-29 0 -72 -23 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 38 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -12 -50 c-31 -83 -58 -156 -58 -212c0 -52 23 -87 74 -87c117 0 178 229 178 271c0 36 -13 62 -34 82c-11 11 -16 17 -16 30c0 22 24 48 49 48c18 0 44 -16 44 -70Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D463" x="0" y="0"></use>
</g>
</svg> to reasonable values</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2574" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2574"><i></i></a><div id="fragbit-2574" class="collapse"><div class="fragmentcode">         dudx = <a href="../Shapes/Managing_Rounding_Error.html#IsFinite" class="code">IsFinite</a>(dudx) ? <a href="../Utilities/Mathematical_Infrastructure.html#Clamp" class="code">Clamp</a>(dudx, -1e8f, 1e8f) : 0.f;
         dvdx = <a href="../Shapes/Managing_Rounding_Error.html#IsFinite" class="code">IsFinite</a>(dvdx) ? <a href="../Utilities/Mathematical_Infrastructure.html#Clamp" class="code">Clamp</a>(dvdx, -1e8f, 1e8f) : 0.f;
         dudy = <a href="../Shapes/Managing_Rounding_Error.html#IsFinite" class="code">IsFinite</a>(dudy) ? <a href="../Utilities/Mathematical_Infrastructure.html#Clamp" class="code">Clamp</a>(dudy, -1e8f, 1e8f) : 0.f;
         dvdy = <a href="../Shapes/Managing_Rounding_Error.html#IsFinite" class="code">IsFinite</a>(dvdy) ? <a href="../Utilities/Mathematical_Infrastructure.html#Clamp" class="code">Clamp</a>(dvdy, -1e8f, 1e8f) : 0.f;</div></div></div></div>
   </div></div>
&lt;&lt;<span class="fragmentname"><a href="#fragment-Computeshadingnormalifbumpornormalmappingisbeingused-0">Compute shading normal if bump or normal mapping is being used</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2575" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2575"><i></i></a><div id="fragbit-2575" class="collapse"><div class="fragmentcode">   <a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a> <a href="#MaterialEvalWorkItem::ns" class="code">ns</a> = w.<a href="#MaterialEvalWorkItem::ns" class="code">ns</a>;
   <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> <a href="#MaterialEvalWorkItem::dpdus" class="code">dpdus</a> = w.<a href="#MaterialEvalWorkItem::dpdus" class="code">dpdus</a>;
   <a href="../Textures_and_Materials/Texture_Interface_and_Basic_Textures.html#FloatTexture" class="code">FloatTexture</a> displacement = w.<a href="#MaterialEvalWorkItem::material" class="code">material</a>-&gt;<a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#Material::GetDisplacement" class="code">GetDisplacement</a>();
   const <a href="../Utilities/Images.html#Image" class="code">Image</a> *normalMap = w.<a href="#MaterialEvalWorkItem::material" class="code">material</a>-&gt;<a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#Material::GetNormalMap" class="code">GetNormalMap</a>();
   if (normalMap) {
       &lt;&lt;<span class="fragmentname"><a href="#fragment-CallmonoNormalMaptofindshadinggeometry-0">Call <tt>NormalMap()</tt> to find shading geometry</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2576" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2576"><i></i></a><div id="fragbit-2576" class="collapse"><div class="fragmentcode">          <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#NormalBumpEvalContext" class="code">NormalBumpEvalContext</a> bctx = w.<a href="#MaterialEvalWorkItem::GetNormalBumpEvalContext" class="code">GetNormalBumpEvalContext</a>(dudx, dudy,  
                                                                  dvdx, dvdy);
          <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> dpdvs;
          <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#NormalMap" class="code">NormalMap</a>(*normalMap, bctx, &amp;dpdus, &amp;dpdvs);
          ns = <a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a>(<a href="../Geometry_and_Transformations/Vectors.html#Normalize" class="code">Normalize</a>(<a href="../Geometry_and_Transformations/Vectors.html#Cross" class="code">Cross</a>(dpdus, dpdvs)));
          ns = <a href="../Geometry_and_Transformations/Normals.html#FaceForward" class="code">FaceForward</a>(ns, w.<a href="#MaterialEvalWorkItem::n" class="code">n</a>);</div></div>
   } else if (displacement) {
       &lt;&lt;<span class="fragmentname">Call <tt>BumpMap()</tt> to find shading geometry</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2577" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2577"><i></i></a><div id="fragbit-2577" class="collapse"><div class="fragmentcode">          NormalBumpEvalContext bctx = w.<a href="#MaterialEvalWorkItem::GetNormalBumpEvalContext" class="code">GetNormalBumpEvalContext</a>(dudx, dudy, dvdx, dvdy);
          <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> dpdvs;
          <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#BumpMap" class="code">BumpMap</a>(texEval, displacement, bctx, &amp;dpdus, &amp;dpdvs);
          ns = <a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a>(<a href="../Geometry_and_Transformations/Vectors.html#Normalize" class="code">Normalize</a>(<a href="../Geometry_and_Transformations/Vectors.html#Cross" class="code">Cross</a>(dpdus, dpdvs)));
          ns = <a href="../Geometry_and_Transformations/Normals.html#FaceForward" class="code">FaceForward</a>(ns, w.<a href="#MaterialEvalWorkItem::n" class="code">n</a>);</div></div>
   }</div></div>
&lt;&lt;<span class="fragmentname"><a href="#fragment-GetBSDFatintersectionpoint-0">Get BSDF at intersection point</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2578" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2578"><i></i></a><div id="fragbit-2578" class="collapse"><div class="fragmentcode">   <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> <a href="#MaterialEvalWorkItem::lambda" class="code">lambda</a> = w.<a href="#MaterialEvalWorkItem::lambda" class="code">lambda</a>;
   <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#MaterialEvalContext" class="code">MaterialEvalContext</a> ctx = w.<a href="#MaterialEvalWorkItem::GetMaterialEvalContext" class="code">GetMaterialEvalContext</a>(dudx, dudy, dvdx, dvdy,
                                                      <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#MaterialEvalContext::ns" class="code">ns</a>, <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#MaterialEvalContext::dpdus" class="code">dpdus</a>);
   using ConcreteBxDF = typename ConcreteMaterial::<a href="../Reflection_Models/BSDF_Representation.html#BxDF" class="code">BxDF</a>;
   ConcreteBxDF bxdf = w.<a href="#MaterialEvalWorkItem::material" class="code">material</a>-&gt;<a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#Material::GetBxDF" class="code">GetBxDF</a>(texEval, ctx, <a href="#MaterialEvalWorkItem::lambda" class="code">lambda</a>);
   <a href="../Reflection_Models/BSDF_Representation.html#BSDF" class="code">BSDF</a> bsdf(ctx.<a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#MaterialEvalContext::ns" class="code">ns</a>, ctx.<a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#MaterialEvalContext::dpdus" class="code">dpdus</a>, &amp;bxdf);
   &lt;&lt;<span class="fragmentname"><a href="#fragment-HandleterminatedsecondarywavelengthsafterBSDFcreation-0">Handle terminated secondary wavelengths after BSDF creation</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2579" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2579"><i></i></a><div id="fragbit-2579" class="collapse"><div class="fragmentcode">      if (<a href="#PixelSampleState::lambda" class="code">lambda</a>.<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths::SecondaryTerminated" class="code">SecondaryTerminated</a>())
          <a href="#WavefrontPathIntegrator::pixelSampleState" class="code">pixelSampleState</a>.<a href="#PixelSampleState::lambda" class="code">lambda</a>[w.<a href="#MaterialEvalWorkItem::pixelIndex" class="code">pixelIndex</a>] = <a href="#PixelSampleState::lambda" class="code">lambda</a>;</div></div></div></div>
&lt;&lt;<span class="fragmentname"><a href="#fragment-RegularizeBSDFifappropriate-0">Regularize BSDF, if appropriate</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2580" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2580"><i></i></a><div id="fragbit-2580" class="collapse"><div class="fragmentcode">   if (<a href="#WavefrontPathIntegrator::regularize" class="code">regularize</a> &amp;&amp; w.<a href="#MaterialEvalWorkItem::anyNonSpecularBounces" class="code">anyNonSpecularBounces</a>)
       bsdf.<a href="../Light_Transport_I_Surface_Reflection/A_Better_Path_Tracer.html#BSDF::Regularize" class="code">Regularize</a>();</div></div>
&lt;&lt;<span class="fragmentname">Initialize <tt>VisibleSurface</tt> at first intersection if necessary</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2581" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2581"><i></i></a><div id="fragbit-2581" class="collapse"><div class="fragmentcode">   if (w.depth == 0 &amp;&amp; initializeVisibleSurface) {
       <a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction" class="code">SurfaceInteraction</a> isect;
       isect.pi = w.pi;
       isect.n = w.n;
       isect.shading.n = ns;
       isect.uv = w.uv;
       isect.wo = w.wo;
       isect.time = w.time;
       isect.dpdx = dpdx;
       isect.dpdy = dpdy;
   
       &lt;&lt;<span class="fragmentname"><a href="../Light_Transport_I_Surface_Reflection/A_Better_Path_Tracer.html#fragment-EstimateBSDFsalbedo-0">Estimate BSDF&rsquo;s albedo</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2582" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2582"><i></i></a><div id="fragbit-2582" class="collapse"><div class="fragmentcode">          &lt;&lt;<span class="fragmentname">Define sample arrays <tt>ucRho</tt> and <tt>uRho</tt> for reflectance estimate</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2583" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2583"><i></i></a><div id="fragbit-2583" class="collapse"><div class="fragmentcode">             constexpr int nRhoSamples = 16;
             const Float ucRho[nRhoSamples] = { 0.75741637, 0.37870818, 0.7083487, 0.18935409, 0.9149363, 0.35417435, 0.5990858, 0.09467703, 0.8578725, 0.45746812, 0.686759, 0.17708716, 0.9674518, 0.2995429, 0.5083201, 0.047338516 };
             const <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a> uRho[nRhoSamples] = { <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.855985, 0.570367), <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.381823, 0.851844), <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.285328, 0.764262), <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.733380, 0.114073), <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.542663, 0.344465), <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.127274, 0.414848), <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.964700, 0.947162), <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.594089, 0.643463), <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.095109, 0.170369), <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.825444, 0.263359), <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.429467, 0.454469), <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.244460, 0.816459), <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.756135, 0.731258), <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.516165, 0.152852), <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.180888, 0.214174), <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a>(0.898579, 0.503897) };</div></div>
          <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> albedo = bsdf.<a href="../Reflection_Models/BSDF_Representation.html#BSDF::rho" class="code">rho</a>(isect.<a href="../Geometry_and_Transformations/Interactions.html#Interaction::wo" class="code">wo</a>, ucRho, uRho);</div></div>
   
       pixelSampleState.visibleSurface[w.pixelIndex] =
           <a href="../Cameras_and_Film/Film_and_Imaging.html#VisibleSurface" class="code">VisibleSurface</a>(isect, albedo, lambda);
   }</div></div>
&lt;&lt;<span class="fragmentname"><a href="#fragment-SampleBSDFandenqueueindirectrayatintersectionpoint-0">Sample BSDF and enqueue indirect ray at intersection point</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2584" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2584"><i></i></a><div id="fragbit-2584" class="collapse"><div class="fragmentcode">   <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> <a href="#MaterialEvalWorkItem::wo" class="code">wo</a> = w.<a href="#MaterialEvalWorkItem::wo" class="code">wo</a>;
   <a href="#RaySamples" class="code">RaySamples</a> raySamples = <a href="#WavefrontPathIntegrator::pixelSampleState" class="code">pixelSampleState</a>.<a href="#PixelSampleState::samples" class="code">samples</a>[w.<a href="#MaterialEvalWorkItem::pixelIndex" class="code">pixelIndex</a>];
   pstd::optional&lt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample" class="code">BSDFSample</a>&gt; bsdfSample =
       bsdf.<a href="../Reflection_Models/BSDF_Representation.html#BSDF::Sample_f" class="code">Sample_f</a>&lt;ConcreteBxDF&gt;(<a href="#MaterialEvalWorkItem::wo" class="code">wo</a>, raySamples.indirect.<a href="#RaySamples::indirect::uc" class="code">uc</a>,
                                   raySamples.indirect.<a href="#RaySamples::indirect::u" class="code">u</a>);
   if (bsdfSample) {
       &lt;&lt;<span class="fragmentname"><a href="#fragment-ComputeupdatedpaththroughputandPDFsandenqueueindirectray-0">Compute updated path throughput and PDFs and enqueue indirect ray</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2585" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2585"><i></i></a><div id="fragbit-2585" class="collapse"><div class="fragmentcode">          <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> <a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::wi" class="code">wi</a> = bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::wi" class="code">wi</a>;
          <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <a href="#MaterialEvalWorkItem::beta" class="code">beta</a> = w.<a href="#MaterialEvalWorkItem::beta" class="code">beta</a> * bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::f" class="code">f</a> * <a href="../Geometry_and_Transformations/Vectors.html#AbsDot" class="code">AbsDot</a>(<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::wi" class="code">wi</a>, ns)/bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::pdf" class="code">pdf</a>;
          <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <a href="#MaterialEvalWorkItem::r_u" class="code">r_u</a> = w.<a href="#MaterialEvalWorkItem::r_u" class="code">r_u</a>, r_l;
          &lt;&lt;<span class="fragmentname"><a href="#fragment-Updatemonor_ubasedonBSDFsamplePDF-0">Update <tt>r_u</tt> based on BSDF sample PDF</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2586" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2586"><i></i></a><div id="fragbit-2586" class="collapse"><div class="fragmentcode">             if (bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::pdfIsProportional" class="code">pdfIsProportional</a>)
                 r_l = r_u / bsdf.<a href="../Reflection_Models/BSDF_Representation.html#BSDF::PDF" class="code">PDF</a>&lt;ConcreteBxDF&gt;(wo, bsdfSample-&gt;wi);
             else
                 r_l = r_u / bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::pdf" class="code">pdf</a>;</div></div>
          &lt;&lt;<span class="fragmentname"><a href="#fragment-UpdatemonoetaScaleaccountingforBSDFscattering-0">Update <tt>etaScale</tt> accounting for BSDF scattering</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2587" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2587"><i></i></a><div id="fragbit-2587" class="collapse"><div class="fragmentcode">             Float <a href="#MaterialEvalWorkItem::etaScale" class="code">etaScale</a> = w.<a href="#MaterialEvalWorkItem::etaScale" class="code">etaScale</a>;
             if (bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::IsTransmission" class="code">IsTransmission</a>())
                 <a href="#MaterialEvalWorkItem::etaScale" class="code">etaScale</a> *= <a href="../Utilities/Mathematical_Infrastructure.html#Sqr" class="code">Sqr</a>(bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::eta" class="code">eta</a>);</div></div>
          &lt;&lt;<span class="fragmentname">Apply Russian roulette to indirect ray based on weighted path throughput</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2588" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2588"><i></i></a><div id="fragbit-2588" class="collapse"><div class="fragmentcode">             <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> rrBeta = beta * etaScale / r_u.Average();
             // Note: depth &gt;= 1 here to match VolPathIntegrator (which increments depth earlier).
             if (rrBeta.MaxComponentValue() &lt; 1 &amp;&amp; w.depth &gt;= 1) {
                 Float q = std::max&lt;Float&gt;(0, 1 - rrBeta.MaxComponentValue());
                 if (raySamples.indirect.rr &lt; q) {
                     beta = <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a>(0.f);
                     PBRT_DBG("Path terminated with RR\n");
                 } else
                     beta /= 1 - q;
             }</div></div>
          if (<a href="#MaterialEvalWorkItem::beta" class="code">beta</a>) {
              &lt;&lt;<span class="fragmentname"><a href="#fragment-Initializespawnedrayandenqueuefornextraydepth-0">Initialize spawned ray and enqueue for next ray depth</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2589" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2589"><i></i></a><div id="fragbit-2589" class="collapse"><div class="fragmentcode">                 <a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> ray = <a href="../Shapes/Managing_Rounding_Error.html#SpawnRay" class="code">SpawnRay</a>(w.<a href="#MaterialEvalWorkItem::pi" class="code">pi</a>, w.<a href="#MaterialEvalWorkItem::n" class="code">n</a>, w.<a href="#MaterialEvalWorkItem::time" class="code">time</a>, wi);
                 &lt;&lt;<span class="fragmentname"><a href="#fragment-Initializemonoraymediumifmediaarepresent-0">Initialize <tt>ray</tt> medium if media are present</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2590" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2590"><i></i></a><div id="fragbit-2590" class="collapse"><div class="fragmentcode">                    if (haveMedia)
                        ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::medium" class="code">medium</a> = <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::d" class="code">d</a>, w.<a href="#MaterialEvalWorkItem::n" class="code">n</a>) &gt; 0 ? w.<a href="#MaterialEvalWorkItem::mediumInterface" class="code">mediumInterface</a>.outside
                                                         : w.<a href="#MaterialEvalWorkItem::mediumInterface" class="code">mediumInterface</a>.inside;</div></div>
                 bool <a href="#MaterialEvalWorkItem::anyNonSpecularBounces" class="code">anyNonSpecularBounces</a> = !bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::IsSpecular" class="code">IsSpecular</a>() ||
                                              w.<a href="#MaterialEvalWorkItem::anyNonSpecularBounces" class="code">anyNonSpecularBounces</a>;
                 <a href="../Light_Sources/Light_Interface.html#LightSampleContext" class="code">LightSampleContext</a> ctx(w.<a href="#MaterialEvalWorkItem::pi" class="code">pi</a>, w.<a href="#MaterialEvalWorkItem::n" class="code">n</a>, ns);
                 nextRayQueue-&gt;<a href="#RayQueue::PushIndirectRay" class="code">PushIndirectRay</a>(
                     ray, w.<a href="#MaterialEvalWorkItem::depth" class="code">depth</a> + 1, ctx, beta, r_u, r_l, lambda,
                     etaScale, bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::IsSpecular" class="code">IsSpecular</a>(), <a href="#MaterialEvalWorkItem::anyNonSpecularBounces" class="code">anyNonSpecularBounces</a>, w.<a href="#MaterialEvalWorkItem::pixelIndex" class="code">pixelIndex</a>);
                 </div></div>
          }</div></div>
   }</div></div>
&lt;&lt;<span class="fragmentname"><a href="#fragment-Samplelightandenqueueshadowrayatintersectionpoint-0">Sample light and enqueue shadow ray at intersection point</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2591" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2591"><i></i></a><div id="fragbit-2591" class="collapse"><div class="fragmentcode">   <a href="../Reflection_Models/BSDF_Representation.html#BxDFFlags" class="code">BxDFFlags</a> flags = bsdf.<a href="../Reflection_Models/BSDF_Representation.html#BSDF::Flags" class="code">Flags</a>();
   if (<a href="../Reflection_Models/BSDF_Representation.html#BxDFFlags::IsNonSpecular" class="code">IsNonSpecular</a>(flags)) {
       &lt;&lt;<span class="fragmentname">Choose a light source using the <tt>LightSampler</tt></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2592" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2592"><i></i></a><div id="fragbit-2592" class="collapse"><div class="fragmentcode">          <a href="../Light_Sources/Light_Interface.html#LightSampleContext" class="code">LightSampleContext</a> ctx(w.pi, w.n, ns);
          if (IsReflective(flags) &amp;&amp; !IsTransmissive(flags))
              ctx.pi = OffsetRayOrigin(ctx.pi, w.n, wo);
          else if (IsTransmissive(flags) &amp;&amp; IsReflective(flags))
              ctx.pi = OffsetRayOrigin(ctx.pi, w.n, -wo);
          pstd::optional&lt;SampledLight&gt; sampledLight =
              lightSampler.Sample(ctx, raySamples.direct.uc);
          if (!sampledLight)
              return;
          <a href="../Light_Sources/Light_Interface.html#Light" class="code">Light</a> light = sampledLight-&gt;light;</div></div>
       &lt;&lt;<span class="fragmentname">Sample light source and evaluate BSDF for direct lighting</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2593" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2593"><i></i></a><div id="fragbit-2593" class="collapse"><div class="fragmentcode">          pstd::optional&lt;<a href="../Light_Sources/Light_Interface.html#LightLiSample" class="code">LightLiSample</a>&gt; ls =
              light.<a href="../Light_Sources/Light_Interface.html#Light::SampleLi" class="code">SampleLi</a>(ctx, raySamples.direct.<a href="#RaySamples::direct::u" class="code">u</a>, lambda,
              true);
          if (!ls || !ls-&gt;<a href="../Light_Sources/Light_Interface.html#LightLiSample::L" class="code">L</a> || ls-&gt;<a href="../Light_Sources/Light_Interface.html#LightLiSample::pdf" class="code">pdf</a> == 0) return;
          <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> <a href="../Light_Sources/Light_Interface.html#LightLiSample::wi" class="code">wi</a> = ls-&gt;<a href="../Light_Sources/Light_Interface.html#LightLiSample::wi" class="code">wi</a>;
          <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> f = bsdf.f&lt;ConcreteBxDF&gt;(wo, <a href="../Light_Sources/Light_Interface.html#LightLiSample::wi" class="code">wi</a>);
          if (!f) return;</div></div>
       &lt;&lt;<span class="fragmentname"><a href="#fragment-ComputepaththroughputandpathPDFsforlightsample-0">Compute path throughput and path PDFs for light sample</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2594" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2594"><i></i></a><div id="fragbit-2594" class="collapse"><div class="fragmentcode">          <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <a href="#MaterialEvalWorkItem::beta" class="code">beta</a> = w.<a href="#MaterialEvalWorkItem::beta" class="code">beta</a> * f * <a href="../Geometry_and_Transformations/Vectors.html#AbsDot" class="code">AbsDot</a>(wi, ns);
          Float lightPDF = ls-&gt;<a href="../Light_Sources/Light_Interface.html#LightLiSample::pdf" class="code">pdf</a> * sampledLight-&gt;<a href="../Light_Sources/Light_Sampling.html#SampledLight::p" class="code">p</a>;
          Float bsdfPDF = <a href="../Light_Sources/Light_Interface.html#IsDeltaLight" class="code">IsDeltaLight</a>(light.<a href="../Light_Sources/Light_Interface.html#Light::Type" class="code">Type</a>()) ? 0.f
                                                     : bsdf.<a href="../Reflection_Models/BSDF_Representation.html#BSDF::PDF" class="code">PDF</a>&lt;ConcreteBxDF&gt;(wo, wi);
          <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <a href="#MaterialEvalWorkItem::r_u" class="code">r_u</a> = w.<a href="#MaterialEvalWorkItem::r_u" class="code">r_u</a> * bsdfPDF;
          <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> r_l = w.<a href="#MaterialEvalWorkItem::r_u" class="code">r_u</a> * lightPDF;</div></div>
       &lt;&lt;<span class="fragmentname"><a href="#fragment-Enqueueshadowraywithtentativeradiancecontribution-0">Enqueue shadow ray with tentative radiance contribution</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2595" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2595"><i></i></a><div id="fragbit-2595" class="collapse"><div class="fragmentcode">          <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> Ld = beta * ls-&gt;<a href="../Light_Sources/Light_Interface.html#LightLiSample::L" class="code">L</a>;
          <a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> ray = <a href="../Shapes/Managing_Rounding_Error.html#SpawnRayTo" class="code">SpawnRayTo</a>(w.<a href="../Geometry_and_Transformations/Interactions.html#Interaction::pi" class="code">pi</a>, w.<a href="../Geometry_and_Transformations/Interactions.html#Interaction::n" class="code">n</a>, w.<a href="#MaterialEvalWorkItem::time" class="code">time</a>, ls-&gt;<a href="../Light_Sources/Light_Interface.html#LightLiSample::pLight" class="code">pLight</a>.<a href="../Geometry_and_Transformations/Interactions.html#Interaction::pi" class="code">pi</a>, ls-&gt;<a href="../Light_Sources/Light_Interface.html#LightLiSample::pLight" class="code">pLight</a>.<a href="../Geometry_and_Transformations/Interactions.html#Interaction::n" class="code">n</a>);
          &lt;&lt;<span class="fragmentname"><a href="#fragment-Initializemonoraymediumifmediaarepresent-0">Initialize <tt>ray</tt> medium if media are present</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2596" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2596"><i></i></a><div id="fragbit-2596" class="collapse"><div class="fragmentcode">             if (haveMedia)
                 ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::medium" class="code">medium</a> = <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::d" class="code">d</a>, w.<a href="#MaterialEvalWorkItem::n" class="code">n</a>) &gt; 0 ? w.<a href="#MaterialEvalWorkItem::mediumInterface" class="code">mediumInterface</a>.outside
                                                  : w.<a href="#MaterialEvalWorkItem::mediumInterface" class="code">mediumInterface</a>.inside;</div></div>
          <a href="#WavefrontPathIntegrator::shadowRayQueue" class="code">shadowRayQueue</a>-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#WorkQueue::Push" class="code">Push</a>(ShadowRayWorkItem{ray, 1 - <a href="../Shapes/Managing_Rounding_Error.html#ShadowEpsilon" class="code">ShadowEpsilon</a>, lambda, Ld,
                                                 r_u, r_l, w.<a href="#MaterialEvalWorkItem::pixelIndex" class="code">pixelIndex</a>});
          </div></div>
   }</div></div></div><p>


</p>
<p>One difference from the <a href="../Light_Transport_II_Volume_Rendering/Volume_Scattering_Integrators.html#VolPathIntegrator"><tt>VolPathIntegrator</tt></a> is that the wavefront
integrator does not carry ray differentials with the rays it traces.
Therefore, in order to compute filter widths for texture filtering, the
<tt>Camera</tt>&rsquo;s <tt>Approximate_dp_dxy()</tt> method is used to compute
approximate differentials at the intersection point.  While the resulting
filter width estimates are less accurate if there has been specular
reflection or transmission from curved surfaces, they usually work well
in practice.  Note that by declaring local variables <tt>dpdu</tt> and
<tt>dpdv</tt> at the end of this fragment that store the surface&rsquo;s partial
derivatives, we are able to reuse the earlier
fragment &lt;&lt;<span class="fragmentname"><a href="../Textures_and_Materials/Texture_Sampling_and_Antialiasing.html#fragment-Estimatescreen-spacechangeinuv-0">Estimate screen-space change in <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.301ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 2282.2 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">left-parenthesis u comma v right-parenthesis</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-28" d="M332 -238c0 -5 -5 -10 -10 -10c-2 0 -4 1 -6 2c-110 83 -215 283 -215 454v84c0 171 105 371 215 454c2 1 4 2 6 2c5 0 10 -5 10 -10c0 -3 -2 -6 -4 -8c-104 -78 -173 -278 -173 -438v-84c0 -160 69 -360 173 -438c2 -2 4 -5 4 -8Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D462" d="M543 143c0 0 -13 -63 -30 -99c-16 -32 -39 -55 -74 -55c-43 0 -78 26 -89 67c-17 -22 -53 -67 -119 -67c-54 0 -123 25 -123 120c0 49 21 111 58 210c6 15 17 44 17 68c0 32 -16 33 -25 33c-38 0 -76 -37 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10 c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -17 -63c-26 -69 -54 -148 -54 -204c0 -37 10 -82 62 -82c73 0 113 80 114 84l75 301c8 34 34 35 39 35c15 0 29 -9 29 -27c0 -6 -10 -44 -15 -67c-4 -15 -14 -53 -17 -68l-28 -108c-8 -35 -20 -82 -20 -104 c0 -33 10 -46 31 -46c42 0 61 68 75 124c3 14 4 18 14 18c3 0 12 0 12 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2C" d="M203 1c0 -117 -80 -194 -91 -194c-5 0 -10 4 -10 11c0 3 0 5 11 16c33 33 68 93 68 167c0 14 -2 15 -2 15s-2 -1 -5 -3c-10 -9 -23 -13 -35 -13c-33 0 -53 26 -53 53c0 28 20 53 53 53c39 0 64 -39 64 -105Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D463" d="M468 372c0 -52 -57 -383 -225 -383c-46 0 -134 16 -134 124c0 43 13 89 57 205c7 18 17 45 17 70c0 32 -17 32 -25 32c-29 0 -72 -23 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 38 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -12 -50 c-31 -83 -58 -156 -58 -212c0 -52 23 -87 74 -87c117 0 178 229 178 271c0 36 -13 62 -34 82c-11 11 -16 17 -16 30c0 22 24 48 49 48c18 0 44 -16 44 -70Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-29" d="M288 208c0 -171 -105 -371 -215 -454c-2 -1 -4 -2 -6 -2c-5 0 -10 5 -10 10c0 3 2 6 4 8c104 78 173 278 173 438v84c0 160 -69 360 -173 438c-2 2 -4 5 -4 8c0 5 5 10 10 10c2 0 4 -1 6 -2c110 -83 215 -283 215 -454v-84Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-28" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D462" x="389" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="962" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D463" x="1407" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-29" x="1892" y="0"></use>
</g>
</svg></a></span>&gt;&gt; to compute the
<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.301ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 2282.2 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">left-parenthesis u comma v right-parenthesis</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-28" d="M332 -238c0 -5 -5 -10 -10 -10c-2 0 -4 1 -6 2c-110 83 -215 283 -215 454v84c0 171 105 371 215 454c2 1 4 2 6 2c5 0 10 -5 10 -10c0 -3 -2 -6 -4 -8c-104 -78 -173 -278 -173 -438v-84c0 -160 69 -360 173 -438c2 -2 4 -5 4 -8Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D462" d="M543 143c0 0 -13 -63 -30 -99c-16 -32 -39 -55 -74 -55c-43 0 -78 26 -89 67c-17 -22 -53 -67 -119 -67c-54 0 -123 25 -123 120c0 49 21 111 58 210c6 15 17 44 17 68c0 32 -16 33 -25 33c-38 0 -76 -37 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10 c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -17 -63c-26 -69 -54 -148 -54 -204c0 -37 10 -82 62 -82c73 0 113 80 114 84l75 301c8 34 34 35 39 35c15 0 29 -9 29 -27c0 -6 -10 -44 -15 -67c-4 -15 -14 -53 -17 -68l-28 -108c-8 -35 -20 -82 -20 -104 c0 -33 10 -46 31 -46c42 0 61 68 75 124c3 14 4 18 14 18c3 0 12 0 12 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2C" d="M203 1c0 -117 -80 -194 -91 -194c-5 0 -10 4 -10 11c0 3 0 5 11 16c33 33 68 93 68 167c0 14 -2 15 -2 15s-2 -1 -5 -3c-10 -9 -23 -13 -35 -13c-33 0 -53 26 -53 53c0 28 20 53 53 53c39 0 64 -39 64 -105Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D463" d="M468 372c0 -52 -57 -383 -225 -383c-46 0 -134 16 -134 124c0 43 13 89 57 205c7 18 17 45 17 70c0 32 -17 32 -25 32c-29 0 -72 -23 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 38 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -12 -50 c-31 -83 -58 -156 -58 -212c0 -52 23 -87 74 -87c117 0 178 229 178 271c0 36 -13 62 -34 82c-11 11 -16 17 -16 30c0 22 24 48 49 48c18 0 44 -16 44 -70Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-29" d="M288 208c0 -171 -105 -371 -215 -454c-2 -1 -4 -2 -6 -2c-5 0 -10 5 -10 10c0 3 2 6 4 8c104 78 173 278 173 438v84c0 160 -69 360 -173 438c-2 2 -4 5 -4 8c0 5 5 10 10 10c2 0 4 -1 6 -2c110 -83 215 -283 215 -454v-84Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-28" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D462" x="389" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="962" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D463" x="1407" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-29" x="1892" y="0"></use>
</g>
</svg> texture derivatives.

</p>
<p></p>
<span class="anchor" id="fragment-Computedifferentialsforpositionanduvatintersectionpoint-0"></span><div class="fragmentname">&lt;&lt;Compute differentials for position and <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.301ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 2282.2 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">left-parenthesis u comma v right-parenthesis</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-28" d="M332 -238c0 -5 -5 -10 -10 -10c-2 0 -4 1 -6 2c-110 83 -215 283 -215 454v84c0 171 105 371 215 454c2 1 4 2 6 2c5 0 10 -5 10 -10c0 -3 -2 -6 -4 -8c-104 -78 -173 -278 -173 -438v-84c0 -160 69 -360 173 -438c2 -2 4 -5 4 -8Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D462" d="M543 143c0 0 -13 -63 -30 -99c-16 -32 -39 -55 -74 -55c-43 0 -78 26 -89 67c-17 -22 -53 -67 -119 -67c-54 0 -123 25 -123 120c0 49 21 111 58 210c6 15 17 44 17 68c0 32 -16 33 -25 33c-38 0 -76 -37 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10 c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -17 -63c-26 -69 -54 -148 -54 -204c0 -37 10 -82 62 -82c73 0 113 80 114 84l75 301c8 34 34 35 39 35c15 0 29 -9 29 -27c0 -6 -10 -44 -15 -67c-4 -15 -14 -53 -17 -68l-28 -108c-8 -35 -20 -82 -20 -104 c0 -33 10 -46 31 -46c42 0 61 68 75 124c3 14 4 18 14 18c3 0 12 0 12 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2C" d="M203 1c0 -117 -80 -194 -91 -194c-5 0 -10 4 -10 11c0 3 0 5 11 16c33 33 68 93 68 167c0 14 -2 15 -2 15s-2 -1 -5 -3c-10 -9 -23 -13 -35 -13c-33 0 -53 26 -53 53c0 28 20 53 53 53c39 0 64 -39 64 -105Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D463" d="M468 372c0 -52 -57 -383 -225 -383c-46 0 -134 16 -134 124c0 43 13 89 57 205c7 18 17 45 17 70c0 32 -17 32 -25 32c-29 0 -72 -23 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 38 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -12 -50 c-31 -83 -58 -156 -58 -212c0 -52 23 -87 74 -87c117 0 178 229 178 271c0 36 -13 62 -34 82c-11 11 -16 17 -16 30c0 22 24 48 49 48c18 0 44 -16 44 -70Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-29" d="M288 208c0 -171 -105 -371 -215 -454c-2 -1 -4 -2 -6 -2c-5 0 -10 5 -10 10c0 3 2 6 4 8c104 78 173 278 173 438v84c0 160 -69 360 -173 438c-2 2 -4 5 -4 8c0 5 5 10 10 10c2 0 4 -1 6 -2c110 -83 215 -283 215 -454v-84Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-28" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D462" x="389" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="962" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D463" x="1407" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-29" x="1892" y="0"></use>
</g>
</svg> at intersection point&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> dpdx, dpdy;
Float dudx = 0, dudy = 0, dvdx = 0, dvdy = 0;
<a href="#WavefrontPathIntegrator::camera" class="code">camera</a>.<a href="../Textures_and_Materials/Texture_Sampling_and_Antialiasing.html#Camera::Approximate_dp_dxy" class="code">Approximate_dp_dxy</a>(<a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a>(w.<a href="#MaterialEvalWorkItem::pi" class="code">pi</a>), w.<a href="#MaterialEvalWorkItem::n" class="code">n</a>, w.<a href="#MaterialEvalWorkItem::time" class="code">time</a>, <a href="#WavefrontPathIntegrator::samplesPerPixel" class="code">samplesPerPixel</a>,
                          &amp;dpdx, &amp;dpdy);
<a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> <a href="#MaterialEvalWorkItem::dpdu" class="code">dpdu</a> = w.<a href="#MaterialEvalWorkItem::dpdu" class="code">dpdu</a>, <a href="#MaterialEvalWorkItem::dpdv" class="code">dpdv</a> = w.<a href="#MaterialEvalWorkItem::dpdv" class="code">dpdv</a>;
&lt;&lt;<span class="fragmentname"><a href="../Textures_and_Materials/Texture_Sampling_and_Antialiasing.html#fragment-Estimatescreen-spacechangeinuv-0">Estimate screen-space change in <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.301ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 2282.2 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">left-parenthesis u comma v right-parenthesis</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-28" d="M332 -238c0 -5 -5 -10 -10 -10c-2 0 -4 1 -6 2c-110 83 -215 283 -215 454v84c0 171 105 371 215 454c2 1 4 2 6 2c5 0 10 -5 10 -10c0 -3 -2 -6 -4 -8c-104 -78 -173 -278 -173 -438v-84c0 -160 69 -360 173 -438c2 -2 4 -5 4 -8Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D462" d="M543 143c0 0 -13 -63 -30 -99c-16 -32 -39 -55 -74 -55c-43 0 -78 26 -89 67c-17 -22 -53 -67 -119 -67c-54 0 -123 25 -123 120c0 49 21 111 58 210c6 15 17 44 17 68c0 32 -16 33 -25 33c-38 0 -76 -37 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10 c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -17 -63c-26 -69 -54 -148 -54 -204c0 -37 10 -82 62 -82c73 0 113 80 114 84l75 301c8 34 34 35 39 35c15 0 29 -9 29 -27c0 -6 -10 -44 -15 -67c-4 -15 -14 -53 -17 -68l-28 -108c-8 -35 -20 -82 -20 -104 c0 -33 10 -46 31 -46c42 0 61 68 75 124c3 14 4 18 14 18c3 0 12 0 12 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2C" d="M203 1c0 -117 -80 -194 -91 -194c-5 0 -10 4 -10 11c0 3 0 5 11 16c33 33 68 93 68 167c0 14 -2 15 -2 15s-2 -1 -5 -3c-10 -9 -23 -13 -35 -13c-33 0 -53 26 -53 53c0 28 20 53 53 53c39 0 64 -39 64 -105Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D463" d="M468 372c0 -52 -57 -383 -225 -383c-46 0 -134 16 -134 124c0 43 13 89 57 205c7 18 17 45 17 70c0 32 -17 32 -25 32c-29 0 -72 -23 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 38 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -12 -50 c-31 -83 -58 -156 -58 -212c0 -52 23 -87 74 -87c117 0 178 229 178 271c0 36 -13 62 -34 82c-11 11 -16 17 -16 30c0 22 24 48 49 48c18 0 44 -16 44 -70Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-29" d="M288 208c0 -171 -105 -371 -215 -454c-2 -1 -4 -2 -6 -2c-5 0 -10 5 -10 10c0 3 2 6 4 8c104 78 173 278 173 438v84c0 160 -69 360 -173 438c-2 2 -4 5 -4 8c0 5 5 10 10 10c2 0 4 -1 6 -2c110 -83 215 -283 215 -454v-84Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-28" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D462" x="389" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="962" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D463" x="1407" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-29" x="1892" y="0"></use>
</g>
</svg></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2597" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2597"><i></i></a><div id="fragbit-2597" class="collapse"><div class="fragmentcode">   &lt;&lt;<span class="fragmentname"><a href="../Textures_and_Materials/Texture_Sampling_and_Antialiasing.html#fragment-ComputetransposeXFORMAXFORMAanditsdeterminant-0">Compute <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.428ex" height="2.676ex" style="vertical-align: -0.338ex;" viewBox="0 -1006.6 2337.2 1152.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">bold upper A Superscript upper T Baseline bold upper A</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D400" d="M827 0c-35 3 -123 3 -163 3c-43 0 -138 0 -176 -3v47h95l-60 146h-268l-50 -121l-4 -12c0 -13 89 -13 89 -13v-47c-37 3 -93 3 -132 3l-117 -3v47h21c76 0 79 8 85 23l248 602c7 18 11 26 39 26c17 0 29 0 40 -26l256 -625h97v-47zM503 240l-114 278l-114 -278h228Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D447" d="M704 666c0 -3 -1 -13 -2 -17l-27 -174c-2 -15 -4 -23 -15 -23c-9 0 -12 7 -12 13c0 3 2 15 3 19c4 26 8 65 8 80c0 78 -45 82 -146 82c-21 0 -54 0 -63 -2c-12 -3 -16 -9 -23 -37l-133 -531c-4 -15 -4 -21 -4 -21c0 -16 8 -19 37 -22c26 -2 39 -2 64 -2c26 0 34 0 34 -11 c0 -20 -12 -20 -22 -20c-28 0 -58 2 -87 2l-83 1l-85 -1c-27 0 -55 -2 -82 -2c-6 0 -17 0 -17 12c0 19 6 19 42 19c107 0 110 11 119 48l134 534c1 3 4 15 4 21c0 8 0 12 -28 12h-39c-148 0 -174 -18 -228 -173c-6 -16 -7 -21 -17 -21c-7 0 -12 5 -12 11c0 0 5 16 6 18 l60 176c7 19 8 20 32 20h555c17 0 27 0 27 -11Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D400" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D447" x="1229" y="602"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D400" x="1467" y="0"></use>
</g>
</svg> and its determinant</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2598" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2598"><i></i></a><div id="fragbit-2598" class="collapse"><div class="fragmentcode">      Float ata00 = <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(dpdu, dpdu), ata01 = <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(dpdu, dpdv);
      Float ata11 = <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(dpdv, dpdv);
      Float invDet = 1 / <a href="../Utilities/Mathematical_Infrastructure.html#DifferenceOfProducts" class="code">DifferenceOfProducts</a>(ata00, ata11, ata01, ata01);
      invDet = <a href="../Shapes/Managing_Rounding_Error.html#IsFinite" class="code">IsFinite</a>(invDet) ? invDet : 0.f;</div></div>
   &lt;&lt;<span class="fragmentname"><a href="../Textures_and_Materials/Texture_Sampling_and_Antialiasing.html#fragment-ComputetransposeXFORMAVECbforxandy-0">Compute <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.894ex" height="2.676ex" style="vertical-align: -0.338ex;" viewBox="0 -1006.6 2107.2 1152.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">bold upper A Superscript upper T Baseline bold b</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D400" d="M827 0c-35 3 -123 3 -163 3c-43 0 -138 0 -176 -3v47h95l-60 146h-268l-50 -121l-4 -12c0 -13 89 -13 89 -13v-47c-37 3 -93 3 -132 3l-117 -3v47h21c76 0 79 8 85 23l248 602c7 18 11 26 39 26c17 0 29 0 40 -26l256 -625h97v-47zM503 240l-114 278l-114 -278h228Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D447" d="M704 666c0 -3 -1 -13 -2 -17l-27 -174c-2 -15 -4 -23 -15 -23c-9 0 -12 7 -12 13c0 3 2 15 3 19c4 26 8 65 8 80c0 78 -45 82 -146 82c-21 0 -54 0 -63 -2c-12 -3 -16 -9 -23 -37l-133 -531c-4 -15 -4 -21 -4 -21c0 -16 8 -19 37 -22c26 -2 39 -2 64 -2c26 0 34 0 34 -11 c0 -20 -12 -20 -22 -20c-28 0 -58 2 -87 2l-83 1l-85 -1c-27 0 -55 -2 -82 -2c-6 0 -17 0 -17 12c0 19 6 19 42 19c107 0 110 11 119 48l134 534c1 3 4 15 4 21c0 8 0 12 -28 12h-39c-148 0 -174 -18 -228 -173c-6 -16 -7 -21 -17 -21c-7 0 -12 5 -12 11c0 0 5 16 6 18 l60 176c7 19 8 20 32 20h555c17 0 27 0 27 -11Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D41B" d="M600 223c0 -139 -103 -229 -252 -229c-89 0 -138 54 -146 62c-16 -19 -33 -37 -49 -56h-47v600c0 39 -7 39 -69 39v47l177 8v-293c24 20 74 49 147 49c145 0 239 -94 239 -227zM472 223c0 70 0 191 -122 191c-55 0 -103 -29 -130 -64v-251c10 -15 49 -69 119 -69 c32 0 78 11 107 52c26 39 26 94 26 141Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D400" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D447" x="1229" y="602"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D41B" x="1467" y="0"></use>
</g>
</svg> for <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.33ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 572.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">x</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D465" d="M527 376c0 -40 -32 -58 -54 -58c-27 0 -38 19 -38 35c0 24 20 49 48 54c-21 13 -45 13 -50 13c-70 0 -93 -92 -99 -118l-34 -137c-11 -44 -17 -66 -17 -88c0 -34 16 -66 55 -66c32 0 100 24 133 131c2 7 4 11 13 11c3 0 12 0 12 -10c0 -25 -57 -154 -160 -154 c-60 0 -96 39 -108 76c-3 -6 -39 -76 -105 -76c-44 0 -94 20 -94 66c0 32 25 58 55 58c15 0 37 -8 37 -35c0 -28 -22 -49 -47 -54c21 -13 44 -13 50 -13c44 0 79 42 95 104c37 140 54 207 54 238c0 58 -35 67 -54 67c-34 0 -100 -25 -134 -131c-2 -9 -5 -11 -13 -11 c0 0 -12 0 -12 10c0 25 57 154 161 154c29 0 83 -10 108 -76c12 23 47 76 105 76c34 0 93 -14 93 -66Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D465" x="0" y="0"></use>
</g>
</svg> and <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.139ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 490.5 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">y</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D466" d="M490 404c0 -7 0 -9 -4 -23l-96 -382c-28 -113 -131 -204 -234 -204c-62 0 -106 37 -106 87c0 49 33 65 56 65c10 0 37 -4 37 -35c0 -19 -10 -32 -20 -41c-14 -12 -27 -12 -43 -12c17 -39 62 -42 76 -42c46 0 84 29 110 63c40 53 52 102 65 154c-28 -28 -62 -45 -101 -45 c-59 0 -122 30 -122 119c0 47 18 104 58 210c7 19 17 45 17 70c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -20 -4 -31 -20 -72c-34 -88 -51 -150 -51 -196c0 -37 11 -81 62 -81 c66 0 109 70 113 85l45 180l20 80c4 18 12 49 14 54c9 15 25 21 35 21c15 0 29 -9 29 -27Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D466" x="0" y="0"></use>
</g>
</svg></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2599" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2599"><i></i></a><div id="fragbit-2599" class="collapse"><div class="fragmentcode">      Float atb0x = <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(dpdu, dpdx), atb1x = <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(dpdv, dpdx);
      Float atb0y = <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(dpdu, dpdy), atb1y = <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(dpdv, dpdy);</div></div>
   &lt;&lt;<span class="fragmentname"><a href="../Textures_and_Materials/Texture_Sampling_and_Antialiasing.html#fragment-Computeuandvderivativeswithrespecttoxandy-0">Compute <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.33ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 572.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">u</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D462" d="M543 143c0 0 -13 -63 -30 -99c-16 -32 -39 -55 -74 -55c-43 0 -78 26 -89 67c-17 -22 -53 -67 -119 -67c-54 0 -123 25 -123 120c0 49 21 111 58 210c6 15 17 44 17 68c0 32 -16 33 -25 33c-38 0 -76 -37 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10 c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -17 -63c-26 -69 -54 -148 -54 -204c0 -37 10 -82 62 -82c73 0 113 80 114 84l75 301c8 34 34 35 39 35c15 0 29 -9 29 -27c0 -6 -10 -44 -15 -67c-4 -15 -14 -53 -17 -68l-28 -108c-8 -35 -20 -82 -20 -104 c0 -33 10 -46 31 -46c42 0 61 68 75 124c3 14 4 18 14 18c3 0 12 0 12 -10Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D462" x="0" y="0"></use>
</g>
</svg> and <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.128ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 485.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">v</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D463" d="M468 372c0 -52 -57 -383 -225 -383c-46 0 -134 16 -134 124c0 43 13 89 57 205c7 18 17 45 17 70c0 32 -17 32 -25 32c-29 0 -72 -23 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 38 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -12 -50 c-31 -83 -58 -156 -58 -212c0 -52 23 -87 74 -87c117 0 178 229 178 271c0 36 -13 62 -34 82c-11 11 -16 17 -16 30c0 22 24 48 49 48c18 0 44 -16 44 -70Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D463" x="0" y="0"></use>
</g>
</svg> derivatives with respect to <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.33ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 572.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">x</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D465" d="M527 376c0 -40 -32 -58 -54 -58c-27 0 -38 19 -38 35c0 24 20 49 48 54c-21 13 -45 13 -50 13c-70 0 -93 -92 -99 -118l-34 -137c-11 -44 -17 -66 -17 -88c0 -34 16 -66 55 -66c32 0 100 24 133 131c2 7 4 11 13 11c3 0 12 0 12 -10c0 -25 -57 -154 -160 -154 c-60 0 -96 39 -108 76c-3 -6 -39 -76 -105 -76c-44 0 -94 20 -94 66c0 32 25 58 55 58c15 0 37 -8 37 -35c0 -28 -22 -49 -47 -54c21 -13 44 -13 50 -13c44 0 79 42 95 104c37 140 54 207 54 238c0 58 -35 67 -54 67c-34 0 -100 -25 -134 -131c-2 -9 -5 -11 -13 -11 c0 0 -12 0 -12 10c0 25 57 154 161 154c29 0 83 -10 108 -76c12 23 47 76 105 76c34 0 93 -14 93 -66Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D465" x="0" y="0"></use>
</g>
</svg> and <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.139ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 490.5 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">y</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D466" d="M490 404c0 -7 0 -9 -4 -23l-96 -382c-28 -113 -131 -204 -234 -204c-62 0 -106 37 -106 87c0 49 33 65 56 65c10 0 37 -4 37 -35c0 -19 -10 -32 -20 -41c-14 -12 -27 -12 -43 -12c17 -39 62 -42 76 -42c46 0 84 29 110 63c40 53 52 102 65 154c-28 -28 -62 -45 -101 -45 c-59 0 -122 30 -122 119c0 47 18 104 58 210c7 19 17 45 17 70c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -20 -4 -31 -20 -72c-34 -88 -51 -150 -51 -196c0 -37 11 -81 62 -81 c66 0 109 70 113 85l45 180l20 80c4 18 12 49 14 54c9 15 25 21 35 21c15 0 29 -9 29 -27Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D466" x="0" y="0"></use>
</g>
</svg></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2600" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2600"><i></i></a><div id="fragbit-2600" class="collapse"><div class="fragmentcode">      dudx = <a href="../Utilities/Mathematical_Infrastructure.html#DifferenceOfProducts" class="code">DifferenceOfProducts</a>(ata11, atb0x, ata01, atb1x) * invDet;
      dvdx = <a href="../Utilities/Mathematical_Infrastructure.html#DifferenceOfProducts" class="code">DifferenceOfProducts</a>(ata00, atb1x, ata01, atb0x) * invDet;
      dudy = <a href="../Utilities/Mathematical_Infrastructure.html#DifferenceOfProducts" class="code">DifferenceOfProducts</a>(ata11, atb0y, ata01, atb1y) * invDet;
      dvdy = <a href="../Utilities/Mathematical_Infrastructure.html#DifferenceOfProducts" class="code">DifferenceOfProducts</a>(ata00, atb1y, ata01, atb0y) * invDet;</div></div>
   &lt;&lt;<span class="fragmentname"><a href="../Textures_and_Materials/Texture_Sampling_and_Antialiasing.html#fragment-Clampderivativesofuandvtoreasonablevalues-0">Clamp derivatives of <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.33ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 572.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">u</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D462" d="M543 143c0 0 -13 -63 -30 -99c-16 -32 -39 -55 -74 -55c-43 0 -78 26 -89 67c-17 -22 -53 -67 -119 -67c-54 0 -123 25 -123 120c0 49 21 111 58 210c6 15 17 44 17 68c0 32 -16 33 -25 33c-38 0 -76 -37 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10 c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -17 -63c-26 -69 -54 -148 -54 -204c0 -37 10 -82 62 -82c73 0 113 80 114 84l75 301c8 34 34 35 39 35c15 0 29 -9 29 -27c0 -6 -10 -44 -15 -67c-4 -15 -14 -53 -17 -68l-28 -108c-8 -35 -20 -82 -20 -104 c0 -33 10 -46 31 -46c42 0 61 68 75 124c3 14 4 18 14 18c3 0 12 0 12 -10Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D462" x="0" y="0"></use>
</g>
</svg> and <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.128ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 485.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">v</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D463" d="M468 372c0 -52 -57 -383 -225 -383c-46 0 -134 16 -134 124c0 43 13 89 57 205c7 18 17 45 17 70c0 32 -17 32 -25 32c-29 0 -72 -23 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 38 154 132 154c50 0 82 -37 82 -82c0 -19 -5 -33 -12 -50 c-31 -83 -58 -156 -58 -212c0 -52 23 -87 74 -87c117 0 178 229 178 271c0 36 -13 62 -34 82c-11 11 -16 17 -16 30c0 22 24 48 49 48c18 0 44 -16 44 -70Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D463" x="0" y="0"></use>
</g>
</svg> to reasonable values</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2601" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2601"><i></i></a><div id="fragbit-2601" class="collapse"><div class="fragmentcode">      dudx = <a href="../Shapes/Managing_Rounding_Error.html#IsFinite" class="code">IsFinite</a>(dudx) ? <a href="../Utilities/Mathematical_Infrastructure.html#Clamp" class="code">Clamp</a>(dudx, -1e8f, 1e8f) : 0.f;
      dvdx = <a href="../Shapes/Managing_Rounding_Error.html#IsFinite" class="code">IsFinite</a>(dvdx) ? <a href="../Utilities/Mathematical_Infrastructure.html#Clamp" class="code">Clamp</a>(dvdx, -1e8f, 1e8f) : 0.f;
      dudy = <a href="../Shapes/Managing_Rounding_Error.html#IsFinite" class="code">IsFinite</a>(dudy) ? <a href="../Utilities/Mathematical_Infrastructure.html#Clamp" class="code">Clamp</a>(dudy, -1e8f, 1e8f) : 0.f;
      dvdy = <a href="../Shapes/Managing_Rounding_Error.html#IsFinite" class="code">IsFinite</a>(dvdy) ? <a href="../Utilities/Mathematical_Infrastructure.html#Clamp" class="code">Clamp</a>(dvdy, -1e8f, 1e8f) : 0.f;</div></div></div></div>
</div><p>


</p>
<p><a href="#MaterialEvalWorkItem"><tt>MaterialEvalWorkItem</tt></a> also carries a variety of information about the
local geometry of the ray&ndash;shape intersection that is copied from the
<a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction"><tt>SurfaceInteraction</tt></a> when material evaluation work is enqueued.

</p>
<p></p>
<span class="anchor" id="fragment-MaterialEvalWorkItemPublicMembers-1"></span><div class="fragmentname">&lt;&lt;MaterialEvalWorkItem Public Members&gt;&gt;+=&nbsp;<a href="#fragment-MaterialEvalWorkItemPublicMembers-0"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-MaterialEvalWorkItemPublicMembers-2"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">Point3fi <span class="anchor" id="MaterialEvalWorkItem::pi"></span>pi;
<a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a> <span class="anchor" id="MaterialEvalWorkItem::n"></span>n;
<a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> <span class="anchor" id="MaterialEvalWorkItem::dpdu"></span>dpdu, <span class="anchor" id="MaterialEvalWorkItem::dpdv"></span>dpdv;
Float <span class="anchor" id="MaterialEvalWorkItem::time"></span>time;
int <span class="anchor" id="MaterialEvalWorkItem::depth"></span>depth;</div><p>


</p>
<p>Before any further work is done, the effect of normal or bump mapping on
the local shading geometry is found, if appropriate.

</p>
<p></p>
<span class="anchor" id="fragment-Computeshadingnormalifbumpornormalmappingisbeingused-0"></span><div class="fragmentname">&lt;&lt;Compute shading normal if bump or normal mapping is being used&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a> <a href="#MaterialEvalWorkItem::ns" class="code">ns</a> = w.<a href="#MaterialEvalWorkItem::ns" class="code">ns</a>;
<a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> <a href="#MaterialEvalWorkItem::dpdus" class="code">dpdus</a> = w.<a href="#MaterialEvalWorkItem::dpdus" class="code">dpdus</a>;
<a href="../Textures_and_Materials/Texture_Interface_and_Basic_Textures.html#FloatTexture" class="code">FloatTexture</a> displacement = w.<a href="#MaterialEvalWorkItem::material" class="code">material</a>-&gt;<a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#Material::GetDisplacement" class="code">GetDisplacement</a>();
const <a href="../Utilities/Images.html#Image" class="code">Image</a> *normalMap = w.<a href="#MaterialEvalWorkItem::material" class="code">material</a>-&gt;<a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#Material::GetNormalMap" class="code">GetNormalMap</a>();
if (normalMap) {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-CallmonoNormalMaptofindshadinggeometry-0">Call <tt>NormalMap()</tt> to find shading geometry</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2602" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2602"><i></i></a><div id="fragbit-2602" class="collapse"><div class="fragmentcode">       <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#NormalBumpEvalContext" class="code">NormalBumpEvalContext</a> bctx = w.<a href="#MaterialEvalWorkItem::GetNormalBumpEvalContext" class="code">GetNormalBumpEvalContext</a>(dudx, dudy,  
                                                               dvdx, dvdy);
       <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> dpdvs;
       <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#NormalMap" class="code">NormalMap</a>(*normalMap, bctx, &amp;dpdus, &amp;dpdvs);
       ns = <a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a>(<a href="../Geometry_and_Transformations/Vectors.html#Normalize" class="code">Normalize</a>(<a href="../Geometry_and_Transformations/Vectors.html#Cross" class="code">Cross</a>(dpdus, dpdvs)));
       ns = <a href="../Geometry_and_Transformations/Normals.html#FaceForward" class="code">FaceForward</a>(ns, w.<a href="#MaterialEvalWorkItem::n" class="code">n</a>);</div></div>
} else if (displacement) {
    &lt;&lt;<span class="fragmentname">Call <tt>BumpMap()</tt> to find shading geometry</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2603" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2603"><i></i></a><div id="fragbit-2603" class="collapse"><div class="fragmentcode">       NormalBumpEvalContext bctx = w.<a href="#MaterialEvalWorkItem::GetNormalBumpEvalContext" class="code">GetNormalBumpEvalContext</a>(dudx, dudy, dvdx, dvdy);
       <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> dpdvs;
       <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#BumpMap" class="code">BumpMap</a>(texEval, displacement, bctx, &amp;dpdus, &amp;dpdvs);
       ns = <a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a>(<a href="../Geometry_and_Transformations/Vectors.html#Normalize" class="code">Normalize</a>(<a href="../Geometry_and_Transformations/Vectors.html#Cross" class="code">Cross</a>(dpdus, dpdvs)));
       ns = <a href="../Geometry_and_Transformations/Normals.html#FaceForward" class="code">FaceForward</a>(ns, w.<a href="#MaterialEvalWorkItem::n" class="code">n</a>);</div></div>
}</div><p>


</p>
<p><tt>MaterialEvalWorkItem</tt> carries along information about the initial
shading geometry from the intersected shape for a starting point for calls to
<tt>NormalMap()</tt> or <tt>BumpMap()</tt> and for direct use if there is no
normal or bump mapping at the intersection point.

</p>
<p></p>
<span class="anchor" id="fragment-MaterialEvalWorkItemPublicMembers-2"></span><div class="fragmentname">&lt;&lt;MaterialEvalWorkItem Public Members&gt;&gt;+=&nbsp;<a href="#fragment-MaterialEvalWorkItemPublicMembers-1"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-MaterialEvalWorkItemPublicMembers-3"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode"><a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a> <span class="anchor" id="MaterialEvalWorkItem::ns"></span>ns;
<a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> <span class="anchor" id="MaterialEvalWorkItem::dpdus"></span>dpdus, <span class="anchor" id="MaterialEvalWorkItem::dpdvs"></span>dpdvs;
<a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a> <span class="anchor" id="MaterialEvalWorkItem::dndus"></span>dndus, <span class="anchor" id="MaterialEvalWorkItem::dndvs"></span>dndvs;
<a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a> <span class="anchor" id="MaterialEvalWorkItem::uv"></span>uv;
</div><p>


</p>
<p>As before, all work related to normal mapping is performed
in the <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#NormalMap"><tt>NormalMap()</tt></a> function and bump mapping is handled by <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#BumpMap"><tt>BumpMap()</tt></a>.
Note that here we are able to avoid dynamic dispatch in
the calling of the material&rsquo;s <tt>GetDisplacement()</tt> and
<tt>GetNormalMap()</tt> methods thanks to <tt>ConcreteMaterial</tt> being a
known specific material type.  If a displacement texture or normal map is
present, the <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#NormalBumpEvalContext"><tt>NormalBumpEvalContext</tt></a> for the call to <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#BumpMap"><tt>BumpMap()</tt></a> comes from
a <a href="#MaterialEvalWorkItem"><tt>MaterialEvalWorkItem</tt></a> utility
function<span class="anchor" id="MaterialEvalWorkItem::GetNormalBumpEvalContext"></span> that we do
not include here; it just initializes a <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#NormalBumpEvalContext"><tt>NormalBumpEvalContext</tt></a> using
appropriate values from its member variables.

</p>
<p>On the GPU, there are a few ways that there may be execution divergence
here.  First, if some of the threads in the thread group have normal maps
or displacement textures and some do not, then all of them will pay the cost
of executing the <tt>NormalMap()</tt> and <tt>BumpMap()</tt> functions.  Second, some threads may have
displacement textures and others may have normal maps, which will lead to
execution divergence.  Finally, the types of the
<a href="../Textures_and_Materials/Texture_Interface_and_Basic_Textures.html#FloatTexture"><tt>FloatTexture</tt></a>s used for defining displacements may vary across the
threads.  Each of these factors could be used to sort work more finely,
though we have not found this divergence to be too much of a problem in
practice.

</p>
<p></p>
<span class="anchor" id="fragment-CallmonoNormalMaptofindshadinggeometry-0"></span><div class="fragmentname">&lt;&lt;Call <tt>NormalMap()</tt> to find shading geometry&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#NormalBumpEvalContext" class="code">NormalBumpEvalContext</a> bctx = w.<a href="#MaterialEvalWorkItem::GetNormalBumpEvalContext" class="code">GetNormalBumpEvalContext</a>(dudx, dudy,  
                                                        dvdx, dvdy);
<a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> dpdvs;
<a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#NormalMap" class="code">NormalMap</a>(*normalMap, bctx, &amp;dpdus, &amp;dpdvs);
ns = <a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a>(<a href="../Geometry_and_Transformations/Vectors.html#Normalize" class="code">Normalize</a>(<a href="../Geometry_and_Transformations/Vectors.html#Cross" class="code">Cross</a>(dpdus, dpdvs)));
ns = <a href="../Geometry_and_Transformations/Normals.html#FaceForward" class="code">FaceForward</a>(ns, w.<a href="#MaterialEvalWorkItem::n" class="code">n</a>);</div><p>


</p>
<p>The fragment that calls <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#BumpMap"><tt>BumpMap()</tt></a> for bump mapping parallels the one
for normal mapping, so it is not included here.

</p>
<p>

</p>
<p>

</p>
<p>The <a href="../Reflection_Models/BSDF_Representation.html#BSDF"><tt>BSDF</tt></a> is initialized here in a different way than in the
<a href="../Light_Transport_II_Volume_Rendering/Volume_Scattering_Integrators.html#VolPathIntegrator"><tt>VolPathIntegrator</tt></a>.  Because the <tt>EvaluateMaterialAndBSDF()</tt>
method is specialized on the material type, and because <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#Material"><tt>Material</tt></a>s in
<tt>pbrt</tt> must provide a type definition for their associated <tt>BxDF</tt>, it
is possible to stack-allocate the <a href="../Reflection_Models/BSDF_Representation.html#BxDF"><tt>BxDF</tt></a> here rather than use an
instance of the <a href="../Utilities/Containers_and_Memory_Management.html#ScratchBuffer"><tt>ScratchBuffer</tt></a> class to allocate space for it.  It is
then possible to call the material&rsquo;s <tt>GetBxDF()</tt> method directly rather
than using dynamic dispatch through a call to <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#Material::GetBSDF"><tt>Material::GetBSDF()</tt></a> to
do so.

</p>
<p>The benefit from avoiding use of the <a href="../Utilities/Containers_and_Memory_Management.html#ScratchBuffer"><tt>ScratchBuffer</tt></a> for <tt>BxDF</tt>s is
significant: just as stack-allocating the concrete <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler"><tt>Sampler</tt></a> type in
the camera ray generation and sample generation kernels made it possible
for the <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler"><tt>Sampler</tt></a>&rsquo;s member variables to be stored in GPU registers,
this approach does the same for the <a href="../Reflection_Models/BSDF_Representation.html#BxDF"><tt>BxDF</tt></a>, giving a substantial
performance benefit compared to storing them in device memory.

</p>
<p>The <tt>MaterialEvalWorkItem</tt>
<tt>GetMaterialEvalContext()</tt><span class="anchor" id="MaterialEvalWorkItem::GetMaterialEvalContext"></span>
method, which is also not included here, initializes a
<a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#MaterialEvalContext"><tt>MaterialEvalContext</tt></a> from its corresponding member variables.

</p>
<p></p>
<span class="anchor" id="fragment-GetBSDFatintersectionpoint-0"></span><div class="fragmentname">&lt;&lt;Get BSDF at intersection point&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> <a href="#MaterialEvalWorkItem::lambda" class="code">lambda</a> = w.<a href="#MaterialEvalWorkItem::lambda" class="code">lambda</a>;
<a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#MaterialEvalContext" class="code">MaterialEvalContext</a> ctx = w.<a href="#MaterialEvalWorkItem::GetMaterialEvalContext" class="code">GetMaterialEvalContext</a>(dudx, dudy, dvdx, dvdy,
                                                   <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#MaterialEvalContext::ns" class="code">ns</a>, <a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#MaterialEvalContext::dpdus" class="code">dpdus</a>);
using ConcreteBxDF = typename ConcreteMaterial::<a href="../Reflection_Models/BSDF_Representation.html#BxDF" class="code">BxDF</a>;
ConcreteBxDF bxdf = w.<a href="#MaterialEvalWorkItem::material" class="code">material</a>-&gt;<a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#Material::GetBxDF" class="code">GetBxDF</a>(texEval, ctx, <a href="#MaterialEvalWorkItem::lambda" class="code">lambda</a>);
<a href="../Reflection_Models/BSDF_Representation.html#BSDF" class="code">BSDF</a> bsdf(ctx.<a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#MaterialEvalContext::ns" class="code">ns</a>, ctx.<a href="../Textures_and_Materials/Material_Interface_and_Implementations.html#MaterialEvalContext::dpdus" class="code">dpdus</a>, &amp;bxdf);
&lt;&lt;<span class="fragmentname"><a href="#fragment-HandleterminatedsecondarywavelengthsafterBSDFcreation-0">Handle terminated secondary wavelengths after BSDF creation</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2604" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2604"><i></i></a><div id="fragbit-2604" class="collapse"><div class="fragmentcode">   if (<a href="#PixelSampleState::lambda" class="code">lambda</a>.<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths::SecondaryTerminated" class="code">SecondaryTerminated</a>())
       <a href="#WavefrontPathIntegrator::pixelSampleState" class="code">pixelSampleState</a>.<a href="#PixelSampleState::lambda" class="code">lambda</a>[w.<a href="#MaterialEvalWorkItem::pixelIndex" class="code">pixelIndex</a>] = <a href="#PixelSampleState::lambda" class="code">lambda</a>;</div></div></div><p>


</p>
<p></p>
<span class="anchor" id="fragment-MaterialEvalWorkItemPublicMembers-3"></span><div class="fragmentname">&lt;&lt;MaterialEvalWorkItem Public Members&gt;&gt;+=&nbsp;<a href="#fragment-MaterialEvalWorkItemPublicMembers-2"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-MaterialEvalWorkItemPublicMembers-4"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode"><a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> <span class="anchor" id="MaterialEvalWorkItem::lambda"></span>lambda;</div><p>


</p>
<p>The call to <tt>GetBxDF()</tt> above may cause secondary wavelengths to be
terminated&mdash;for example, in case of dispersion.  It is therefore important that the
stack-allocated <tt>lambda</tt> value both be used here in this
kernel and also be passed along to subsequent rendering kernels, rather than
the initial <tt>SampledWavelengths</tt> value from the
<tt>MaterialEvalWorkItem</tt>.  If the secondary wavelengths in <tt>lambda</tt>
have been terminated, the copy of the <tt>SampledWavelengths</tt> for the
path in <a href="#PixelSampleState"><tt>PixelSampleState</tt></a> must be updated.  Note that the
implementation here may end up writing <tt>lambda</tt> multiple times
redundantly at subsequent intersections in that case.

</p>
<p></p>
<span class="anchor" id="fragment-HandleterminatedsecondarywavelengthsafterBSDFcreation-0"></span><div class="fragmentname">&lt;&lt;Handle terminated secondary wavelengths after BSDF creation&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">if (<a href="#PixelSampleState::lambda" class="code">lambda</a>.<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths::SecondaryTerminated" class="code">SecondaryTerminated</a>())
    <a href="#WavefrontPathIntegrator::pixelSampleState" class="code">pixelSampleState</a>.<a href="#PixelSampleState::lambda" class="code">lambda</a>[w.<a href="#MaterialEvalWorkItem::pixelIndex" class="code">pixelIndex</a>] = <a href="#PixelSampleState::lambda" class="code">lambda</a>;</div><p>


</p>
<p></p>
<span class="anchor" id="fragment-MaterialEvalWorkItemPublicMembers-4"></span><div class="fragmentname">&lt;&lt;MaterialEvalWorkItem Public Members&gt;&gt;+=&nbsp;<a href="#fragment-MaterialEvalWorkItemPublicMembers-3"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-MaterialEvalWorkItemPublicMembers-5"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">int <span class="anchor" id="MaterialEvalWorkItem::pixelIndex"></span>pixelIndex;</div><p>


</p>
<p>BSDF regularization proceeds as before, only happening if the option has
been enabled and a ray has undergone a non-specular scattering event.

</p>
<p></p>
<span class="anchor" id="fragment-RegularizeBSDFifappropriate-0"></span><div class="fragmentname">&lt;&lt;Regularize BSDF, if appropriate&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">if (<a href="#WavefrontPathIntegrator::regularize" class="code">regularize</a> &amp;&amp; w.<a href="#MaterialEvalWorkItem::anyNonSpecularBounces" class="code">anyNonSpecularBounces</a>)
    bsdf.<a href="../Light_Transport_I_Surface_Reflection/A_Better_Path_Tracer.html#BSDF::Regularize" class="code">Regularize</a>();</div><p>


</p>
<p>The <tt>anyNonSpecularBounces</tt> member variable is yet another single-bit
quantity taking up 32 bits.  A more bandwidth-efficient implementation
would pack this value into a free bit elsewhere in the
<a href="#MaterialEvalWorkItem"><tt>MaterialEvalWorkItem</tt></a>.

</p>
<p></p>
<span class="anchor" id="fragment-MaterialEvalWorkItemPublicMembers-5"></span><div class="fragmentname">&lt;&lt;MaterialEvalWorkItem Public Members&gt;&gt;+=&nbsp;<a href="#fragment-MaterialEvalWorkItemPublicMembers-4"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-MaterialEvalWorkItemPublicMembers-6"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">int <span class="anchor" id="MaterialEvalWorkItem::anyNonSpecularBounces"></span>anyNonSpecularBounces;</div><p>


</p>
<p>We will omit the fragment that initializes the <tt>VisibleSurface</tt> at the
first intersection, as it is not especially interesting or different than
the corresponding code in the CPU-based rendering path.

</p>
<p>

</p>
<p>

</p>
<p>There are two new things to see in the fragment that samples the BSDF.
First, the sample values used come from the <a href="#RaySamples"><tt>RaySamples</tt></a> object rather
than from <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler"><tt>Sampler</tt></a> method calls.  Second, because the
<tt>ConcreteBxDF</tt> type is known here at compile time, it is possible to
call the templated <a href="../Reflection_Models/BSDF_Representation.html#BSDF::Sample_f"><tt>BSDF::Sample_f()</tt></a> variant that takes the
<a href="../Reflection_Models/BSDF_Representation.html#BxDF"><tt>BxDF</tt></a> type and thus avoids dynamic dispatch, calling the appropriate
<a href="../Reflection_Models/BSDF_Representation.html#BxDF"><tt>BxDF</tt></a> method implementation directly.

</p>
<p></p>
<span class="anchor" id="fragment-SampleBSDFandenqueueindirectrayatintersectionpoint-0"></span><div class="fragmentname">&lt;&lt;Sample BSDF and enqueue indirect ray at intersection point&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> <a href="#MaterialEvalWorkItem::wo" class="code">wo</a> = w.<a href="#MaterialEvalWorkItem::wo" class="code">wo</a>;
<a href="#RaySamples" class="code">RaySamples</a> raySamples = <a href="#WavefrontPathIntegrator::pixelSampleState" class="code">pixelSampleState</a>.<a href="#PixelSampleState::samples" class="code">samples</a>[w.<a href="#MaterialEvalWorkItem::pixelIndex" class="code">pixelIndex</a>];
pstd::optional&lt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample" class="code">BSDFSample</a>&gt; bsdfSample =
    bsdf.<a href="../Reflection_Models/BSDF_Representation.html#BSDF::Sample_f" class="code">Sample_f</a>&lt;ConcreteBxDF&gt;(<a href="#MaterialEvalWorkItem::wo" class="code">wo</a>, raySamples.indirect.<a href="#RaySamples::indirect::uc" class="code">uc</a>,
                                raySamples.indirect.<a href="#RaySamples::indirect::u" class="code">u</a>);
if (bsdfSample) {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-ComputeupdatedpaththroughputandPDFsandenqueueindirectray-0">Compute updated path throughput and PDFs and enqueue indirect ray</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2605" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2605"><i></i></a><div id="fragbit-2605" class="collapse"><div class="fragmentcode">       <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> <a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::wi" class="code">wi</a> = bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::wi" class="code">wi</a>;
       <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <a href="#MaterialEvalWorkItem::beta" class="code">beta</a> = w.<a href="#MaterialEvalWorkItem::beta" class="code">beta</a> * bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::f" class="code">f</a> * <a href="../Geometry_and_Transformations/Vectors.html#AbsDot" class="code">AbsDot</a>(<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::wi" class="code">wi</a>, ns)/bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::pdf" class="code">pdf</a>;
       <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <a href="#MaterialEvalWorkItem::r_u" class="code">r_u</a> = w.<a href="#MaterialEvalWorkItem::r_u" class="code">r_u</a>, r_l;
       &lt;&lt;<span class="fragmentname"><a href="#fragment-Updatemonor_ubasedonBSDFsamplePDF-0">Update <tt>r_u</tt> based on BSDF sample PDF</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2606" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2606"><i></i></a><div id="fragbit-2606" class="collapse"><div class="fragmentcode">          if (bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::pdfIsProportional" class="code">pdfIsProportional</a>)
              r_l = r_u / bsdf.<a href="../Reflection_Models/BSDF_Representation.html#BSDF::PDF" class="code">PDF</a>&lt;ConcreteBxDF&gt;(wo, bsdfSample-&gt;wi);
          else
              r_l = r_u / bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::pdf" class="code">pdf</a>;</div></div>
       &lt;&lt;<span class="fragmentname"><a href="#fragment-UpdatemonoetaScaleaccountingforBSDFscattering-0">Update <tt>etaScale</tt> accounting for BSDF scattering</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2607" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2607"><i></i></a><div id="fragbit-2607" class="collapse"><div class="fragmentcode">          Float <a href="#MaterialEvalWorkItem::etaScale" class="code">etaScale</a> = w.<a href="#MaterialEvalWorkItem::etaScale" class="code">etaScale</a>;
          if (bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::IsTransmission" class="code">IsTransmission</a>())
              <a href="#MaterialEvalWorkItem::etaScale" class="code">etaScale</a> *= <a href="../Utilities/Mathematical_Infrastructure.html#Sqr" class="code">Sqr</a>(bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::eta" class="code">eta</a>);</div></div>
       &lt;&lt;<span class="fragmentname">Apply Russian roulette to indirect ray based on weighted path throughput</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2608" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2608"><i></i></a><div id="fragbit-2608" class="collapse"><div class="fragmentcode">          <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> rrBeta = beta * etaScale / r_u.Average();
          // Note: depth &gt;= 1 here to match VolPathIntegrator (which increments depth earlier).
          if (rrBeta.MaxComponentValue() &lt; 1 &amp;&amp; w.depth &gt;= 1) {
              Float q = std::max&lt;Float&gt;(0, 1 - rrBeta.MaxComponentValue());
              if (raySamples.indirect.rr &lt; q) {
                  beta = <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a>(0.f);
                  PBRT_DBG("Path terminated with RR\n");
              } else
                  beta /= 1 - q;
          }</div></div>
       if (<a href="#MaterialEvalWorkItem::beta" class="code">beta</a>) {
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Initializespawnedrayandenqueuefornextraydepth-0">Initialize spawned ray and enqueue for next ray depth</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2609" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2609"><i></i></a><div id="fragbit-2609" class="collapse"><div class="fragmentcode">              <a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> ray = <a href="../Shapes/Managing_Rounding_Error.html#SpawnRay" class="code">SpawnRay</a>(w.<a href="#MaterialEvalWorkItem::pi" class="code">pi</a>, w.<a href="#MaterialEvalWorkItem::n" class="code">n</a>, w.<a href="#MaterialEvalWorkItem::time" class="code">time</a>, wi);
              &lt;&lt;<span class="fragmentname"><a href="#fragment-Initializemonoraymediumifmediaarepresent-0">Initialize <tt>ray</tt> medium if media are present</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2610" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2610"><i></i></a><div id="fragbit-2610" class="collapse"><div class="fragmentcode">                 if (haveMedia)
                     ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::medium" class="code">medium</a> = <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::d" class="code">d</a>, w.<a href="#MaterialEvalWorkItem::n" class="code">n</a>) &gt; 0 ? w.<a href="#MaterialEvalWorkItem::mediumInterface" class="code">mediumInterface</a>.outside
                                                      : w.<a href="#MaterialEvalWorkItem::mediumInterface" class="code">mediumInterface</a>.inside;</div></div>
              bool <a href="#MaterialEvalWorkItem::anyNonSpecularBounces" class="code">anyNonSpecularBounces</a> = !bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::IsSpecular" class="code">IsSpecular</a>() ||
                                           w.<a href="#MaterialEvalWorkItem::anyNonSpecularBounces" class="code">anyNonSpecularBounces</a>;
              <a href="../Light_Sources/Light_Interface.html#LightSampleContext" class="code">LightSampleContext</a> ctx(w.<a href="#MaterialEvalWorkItem::pi" class="code">pi</a>, w.<a href="#MaterialEvalWorkItem::n" class="code">n</a>, ns);
              nextRayQueue-&gt;<a href="#RayQueue::PushIndirectRay" class="code">PushIndirectRay</a>(
                  ray, w.<a href="#MaterialEvalWorkItem::depth" class="code">depth</a> + 1, ctx, beta, r_u, r_l, lambda,
                  etaScale, bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::IsSpecular" class="code">IsSpecular</a>(), <a href="#MaterialEvalWorkItem::anyNonSpecularBounces" class="code">anyNonSpecularBounces</a>, w.<a href="#MaterialEvalWorkItem::pixelIndex" class="code">pixelIndex</a>);
              </div></div>
       }</div></div>
}</div><p>


</p>
<p></p>
<span class="anchor" id="fragment-MaterialEvalWorkItemPublicMembers-6"></span><div class="fragmentname">&lt;&lt;MaterialEvalWorkItem Public Members&gt;&gt;+=&nbsp;<a href="#fragment-MaterialEvalWorkItemPublicMembers-5"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-MaterialEvalWorkItemPublicMembers-7"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode"><a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> <span class="anchor" id="MaterialEvalWorkItem::wo"></span>wo;</div><p>


</p>
<p>The path throughput and rescaled path probabilities are updated in the same manner
as in the <a href="../Light_Transport_II_Volume_Rendering/Volume_Scattering_Integrators.html#VolPathIntegrator"><tt>VolPathIntegrator</tt></a> &lt;&lt;<span class="fragmentname"><a href="../Light_Transport_II_Volume_Rendering/Volume_Scattering_Integrators.html#fragment-Updatevolumetricintegratorpathstateaftersurfacescattering-0">Update volumetric integrator path state after surface
scattering</a></span>&gt;&gt; fragment.

</p>
<p></p>
<span class="anchor" id="fragment-ComputeupdatedpaththroughputandPDFsandenqueueindirectray-0"></span><div class="fragmentname">&lt;&lt;Compute updated path throughput and PDFs and enqueue indirect ray&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> <a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::wi" class="code">wi</a> = bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::wi" class="code">wi</a>;
<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <a href="#MaterialEvalWorkItem::beta" class="code">beta</a> = w.<a href="#MaterialEvalWorkItem::beta" class="code">beta</a> * bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::f" class="code">f</a> * <a href="../Geometry_and_Transformations/Vectors.html#AbsDot" class="code">AbsDot</a>(<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::wi" class="code">wi</a>, ns)/bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::pdf" class="code">pdf</a>;
<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <a href="#MaterialEvalWorkItem::r_u" class="code">r_u</a> = w.<a href="#MaterialEvalWorkItem::r_u" class="code">r_u</a>, r_l;
&lt;&lt;<span class="fragmentname"><a href="#fragment-Updatemonor_ubasedonBSDFsamplePDF-0">Update <tt>r_u</tt> based on BSDF sample PDF</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2611" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2611"><i></i></a><div id="fragbit-2611" class="collapse"><div class="fragmentcode">   if (bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::pdfIsProportional" class="code">pdfIsProportional</a>)
       r_l = r_u / bsdf.<a href="../Reflection_Models/BSDF_Representation.html#BSDF::PDF" class="code">PDF</a>&lt;ConcreteBxDF&gt;(wo, bsdfSample-&gt;wi);
   else
       r_l = r_u / bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::pdf" class="code">pdf</a>;</div></div>
&lt;&lt;<span class="fragmentname"><a href="#fragment-UpdatemonoetaScaleaccountingforBSDFscattering-0">Update <tt>etaScale</tt> accounting for BSDF scattering</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2612" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2612"><i></i></a><div id="fragbit-2612" class="collapse"><div class="fragmentcode">   Float <a href="#MaterialEvalWorkItem::etaScale" class="code">etaScale</a> = w.<a href="#MaterialEvalWorkItem::etaScale" class="code">etaScale</a>;
   if (bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::IsTransmission" class="code">IsTransmission</a>())
       <a href="#MaterialEvalWorkItem::etaScale" class="code">etaScale</a> *= <a href="../Utilities/Mathematical_Infrastructure.html#Sqr" class="code">Sqr</a>(bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::eta" class="code">eta</a>);</div></div>
&lt;&lt;<span class="fragmentname">Apply Russian roulette to indirect ray based on weighted path throughput</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2613" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2613"><i></i></a><div id="fragbit-2613" class="collapse"><div class="fragmentcode">   <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> rrBeta = beta * etaScale / r_u.Average();
   // Note: depth &gt;= 1 here to match VolPathIntegrator (which increments depth earlier).
   if (rrBeta.MaxComponentValue() &lt; 1 &amp;&amp; w.depth &gt;= 1) {
       Float q = std::max&lt;Float&gt;(0, 1 - rrBeta.MaxComponentValue());
       if (raySamples.indirect.rr &lt; q) {
           beta = <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a>(0.f);
           PBRT_DBG("Path terminated with RR\n");
       } else
           beta /= 1 - q;
   }</div></div>
if (<a href="#MaterialEvalWorkItem::beta" class="code">beta</a>) {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Initializespawnedrayandenqueuefornextraydepth-0">Initialize spawned ray and enqueue for next ray depth</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2614" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2614"><i></i></a><div id="fragbit-2614" class="collapse"><div class="fragmentcode">       <a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> ray = <a href="../Shapes/Managing_Rounding_Error.html#SpawnRay" class="code">SpawnRay</a>(w.<a href="#MaterialEvalWorkItem::pi" class="code">pi</a>, w.<a href="#MaterialEvalWorkItem::n" class="code">n</a>, w.<a href="#MaterialEvalWorkItem::time" class="code">time</a>, wi);
       &lt;&lt;<span class="fragmentname"><a href="#fragment-Initializemonoraymediumifmediaarepresent-0">Initialize <tt>ray</tt> medium if media are present</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2615" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2615"><i></i></a><div id="fragbit-2615" class="collapse"><div class="fragmentcode">          if (haveMedia)
              ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::medium" class="code">medium</a> = <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::d" class="code">d</a>, w.<a href="#MaterialEvalWorkItem::n" class="code">n</a>) &gt; 0 ? w.<a href="#MaterialEvalWorkItem::mediumInterface" class="code">mediumInterface</a>.outside
                                               : w.<a href="#MaterialEvalWorkItem::mediumInterface" class="code">mediumInterface</a>.inside;</div></div>
       bool <a href="#MaterialEvalWorkItem::anyNonSpecularBounces" class="code">anyNonSpecularBounces</a> = !bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::IsSpecular" class="code">IsSpecular</a>() ||
                                    w.<a href="#MaterialEvalWorkItem::anyNonSpecularBounces" class="code">anyNonSpecularBounces</a>;
       <a href="../Light_Sources/Light_Interface.html#LightSampleContext" class="code">LightSampleContext</a> ctx(w.<a href="#MaterialEvalWorkItem::pi" class="code">pi</a>, w.<a href="#MaterialEvalWorkItem::n" class="code">n</a>, ns);
       nextRayQueue-&gt;<a href="#RayQueue::PushIndirectRay" class="code">PushIndirectRay</a>(
           ray, w.<a href="#MaterialEvalWorkItem::depth" class="code">depth</a> + 1, ctx, beta, r_u, r_l, lambda,
           etaScale, bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::IsSpecular" class="code">IsSpecular</a>(), <a href="#MaterialEvalWorkItem::anyNonSpecularBounces" class="code">anyNonSpecularBounces</a>, w.<a href="#MaterialEvalWorkItem::pixelIndex" class="code">pixelIndex</a>);
       </div></div>
}</div><p>


</p>
<p>Only the unidirectional rescaled path probability needs to be passed in to this
kernel, since the light path probability is initialized during its
execution.

</p>
<p></p>
<span class="anchor" id="fragment-MaterialEvalWorkItemPublicMembers-7"></span><div class="fragmentname">&lt;&lt;MaterialEvalWorkItem Public Members&gt;&gt;+=&nbsp;<a href="#fragment-MaterialEvalWorkItemPublicMembers-6"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-MaterialEvalWorkItemPublicMembers-8"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode"><a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <span class="anchor" id="MaterialEvalWorkItem::beta"></span>beta, <span class="anchor" id="MaterialEvalWorkItem::r_u"></span>r_u;</div><p>


</p>
<p>The logic for updating the unidirectional rescaled
path probability also follows that of the
<a href="../Light_Transport_II_Volume_Rendering/Volume_Scattering_Integrators.html#VolPathIntegrator"><tt>VolPathIntegrator</tt></a>, including how proportional BSDF samples such as
those from the <a href="../Light_Transport_II_Volume_Rendering/Scattering_from_Layered_Materials.html#LayeredBxDF"><tt>LayeredBxDF</tt></a> are handled.  The call to the
<a href="../Reflection_Models/BSDF_Representation.html#BSDF::PDF"><tt>BSDF::PDF()</tt></a> method presents another opportunity to avoid dynamic
dispatch given a compile-time known <tt>BxDF</tt>, however.

</p>
<p></p>
<span class="anchor" id="fragment-Updatemonor_ubasedonBSDFsamplePDF-0"></span><div class="fragmentname">&lt;&lt;Update <tt>r_u</tt> based on BSDF sample PDF&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">if (bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::pdfIsProportional" class="code">pdfIsProportional</a>)
    r_l = r_u / bsdf.<a href="../Reflection_Models/BSDF_Representation.html#BSDF::PDF" class="code">PDF</a>&lt;ConcreteBxDF&gt;(wo, bsdfSample-&gt;wi);
else
    r_l = r_u / bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::pdf" class="code">pdf</a>;</div><p>


</p>
<p>The <tt>etaScale</tt> factor used in Russian roulette is also updated in the
same manner as before.

</p>
<p></p>
<span class="anchor" id="fragment-UpdatemonoetaScaleaccountingforBSDFscattering-0"></span><div class="fragmentname">&lt;&lt;Update <tt>etaScale</tt> accounting for BSDF scattering&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">Float <a href="#MaterialEvalWorkItem::etaScale" class="code">etaScale</a> = w.<a href="#MaterialEvalWorkItem::etaScale" class="code">etaScale</a>;
if (bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::IsTransmission" class="code">IsTransmission</a>())
    <a href="#MaterialEvalWorkItem::etaScale" class="code">etaScale</a> *= <a href="../Utilities/Mathematical_Infrastructure.html#Sqr" class="code">Sqr</a>(bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::eta" class="code">eta</a>);</div><p>


</p>
<p></p>
<span class="anchor" id="fragment-MaterialEvalWorkItemPublicMembers-8"></span><div class="fragmentname">&lt;&lt;MaterialEvalWorkItem Public Members&gt;&gt;+=&nbsp;<a href="#fragment-MaterialEvalWorkItemPublicMembers-7"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-MaterialEvalWorkItemPublicMembers-9"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">Float <span class="anchor" id="MaterialEvalWorkItem::etaScale"></span>etaScale;</div><p>


</p>
<p>We will omit the &lt;&lt;<span class="fragmentname">Apply Russian roulette to indirect ray based on
weighted path throughput</span>&gt;&gt; fragment, which is almost exactly the same as the
<a href="../Light_Transport_II_Volume_Rendering/Volume_Scattering_Integrators.html#VolPathIntegrator"><tt>VolPathIntegrator</tt></a>&rsquo;s &lt;&lt;<span class="fragmentname"><a href="../Light_Transport_II_Volume_Rendering/Volume_Scattering_Integrators.html#fragment-PossiblyterminatevolumetricpathwithRussianroulette-0">Possibly terminate volumetric path with
Russian roulette</a></span>&gt;&gt;, other than the fact that in this case the sample value
for the Russian roulette test comes from
<tt>RaySamples.indirect.rr</tt>.

</p>
<p>

</p>
<p>

</p>
<p>For indirect rays, a ray is initialized and pushed on to the
<a href="#RayQueue"><tt>RayQueue</tt></a> for the next level of the ray tree. (We omit the
implementation of the
<tt>RayQueue::PushIndirectRay()</tt><span class="anchor" id="RayQueue::PushIndirectRay"></span>
method, which stores the provided values in the corresponding member
variables.)

</p>
<p></p>
<span class="anchor" id="fragment-Initializespawnedrayandenqueuefornextraydepth-0"></span><div class="fragmentname">&lt;&lt;Initialize spawned ray and enqueue for next ray depth&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> ray = <a href="../Shapes/Managing_Rounding_Error.html#SpawnRay" class="code">SpawnRay</a>(w.<a href="#MaterialEvalWorkItem::pi" class="code">pi</a>, w.<a href="#MaterialEvalWorkItem::n" class="code">n</a>, w.<a href="#MaterialEvalWorkItem::time" class="code">time</a>, wi);
&lt;&lt;<span class="fragmentname"><a href="#fragment-Initializemonoraymediumifmediaarepresent-0">Initialize <tt>ray</tt> medium if media are present</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2616" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2616"><i></i></a><div id="fragbit-2616" class="collapse"><div class="fragmentcode">   if (haveMedia)
       ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::medium" class="code">medium</a> = <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::d" class="code">d</a>, w.<a href="#MaterialEvalWorkItem::n" class="code">n</a>) &gt; 0 ? w.<a href="#MaterialEvalWorkItem::mediumInterface" class="code">mediumInterface</a>.outside
                                        : w.<a href="#MaterialEvalWorkItem::mediumInterface" class="code">mediumInterface</a>.inside;</div></div>
bool <a href="#MaterialEvalWorkItem::anyNonSpecularBounces" class="code">anyNonSpecularBounces</a> = !bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::IsSpecular" class="code">IsSpecular</a>() ||
                             w.<a href="#MaterialEvalWorkItem::anyNonSpecularBounces" class="code">anyNonSpecularBounces</a>;
<a href="../Light_Sources/Light_Interface.html#LightSampleContext" class="code">LightSampleContext</a> ctx(w.<a href="#MaterialEvalWorkItem::pi" class="code">pi</a>, w.<a href="#MaterialEvalWorkItem::n" class="code">n</a>, ns);
nextRayQueue-&gt;<a href="#RayQueue::PushIndirectRay" class="code">PushIndirectRay</a>(
    ray, w.<a href="#MaterialEvalWorkItem::depth" class="code">depth</a> + 1, ctx, beta, r_u, r_l, lambda,
    etaScale, bsdfSample-&gt;<a href="../Reflection_Models/BSDF_Representation.html#BSDFSample::IsSpecular" class="code">IsSpecular</a>(), <a href="#MaterialEvalWorkItem::anyNonSpecularBounces" class="code">anyNonSpecularBounces</a>, w.<a href="#MaterialEvalWorkItem::pixelIndex" class="code">pixelIndex</a>);
</div><p>


</p>
<p>The <tt>medium</tt> member of the <a href="../Geometry_and_Transformations/Rays.html#Ray"><tt>Ray</tt></a> must be set manually based on
which side of the surface the ray starts in.

</p>
<p></p>
<span class="anchor" id="fragment-Initializemonoraymediumifmediaarepresent-0"></span><div class="fragmentname">&lt;&lt;Initialize <tt>ray</tt> medium if media are present&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">if (haveMedia)
    ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::medium" class="code">medium</a> = <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::d" class="code">d</a>, w.<a href="#MaterialEvalWorkItem::n" class="code">n</a>) &gt; 0 ? w.<a href="#MaterialEvalWorkItem::mediumInterface" class="code">mediumInterface</a>.outside
                                     : w.<a href="#MaterialEvalWorkItem::mediumInterface" class="code">mediumInterface</a>.inside;</div><p>


</p>
<p>The <a href="../Volume_Scattering/Media.html#MediumInterface"><tt>MediumInterface</tt></a> at the intersection point is thus needed in
<tt>MaterialEvalWorkItem</tt>.

</p>
<p></p>
<span class="anchor" id="fragment-MaterialEvalWorkItemPublicMembers-9"></span><div class="fragmentname">&lt;&lt;MaterialEvalWorkItem Public Members&gt;&gt;+=&nbsp;<a href="#fragment-MaterialEvalWorkItemPublicMembers-8"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode"><a href="../Volume_Scattering/Media.html#MediumInterface" class="code">MediumInterface</a> <span class="anchor" id="MaterialEvalWorkItem::mediumInterface"></span>mediumInterface;</div><p>


</p>
<p>Indirect rays require a few additions to the <a href="#RayWorkItem"><tt>RayWorkItem</tt></a> class
including the current path throughput <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.334ex" height="2.509ex" style="vertical-align: -0.671ex;" viewBox="0 -791.3 574.5 1080.4" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">beta</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D6FD" d="M574 574c0 -12 -2 -24 -5 -37c-11 -45 -41 -86 -81 -116c-10 -8 -20 -14 -30 -20c17 -11 31 -26 43 -43c20 -31 30 -68 30 -108c0 -20 -3 -42 -8 -64c-14 -53 -51 -104 -99 -140c-52 -38 -113 -57 -170 -57c-68 0 -114 40 -131 98l-68 -274c-1 -4 -5 -7 -10 -7h-5 c-6 0 -10 4 -10 12l154 615c34 136 125 273 245 273c47 0 89 -18 116 -50c18 -22 29 -51 29 -82zM518 592c0 19 -3 36 -12 51c-16 26 -44 40 -78 40c-110 0 -188 -129 -220 -255l-60 -242c-4 -17 -6 -33 -6 -49c0 -71 41 -126 113 -126c44 0 91 19 129 52 c39 35 61 82 73 128c7 29 12 59 12 87c0 25 -4 48 -14 69c-7 16 -17 29 -30 39c-25 -9 -50 -13 -75 -13c-35 0 -76 0 -76 24c0 0 0 5 1 7c7 27 49 27 85 27c24 0 47 -5 67 -13c9 5 18 12 26 19c31 29 49 67 58 105c5 17 7 34 7 50zM395 403c-11 3 -23 5 -36 5 c-24 0 -57 0 -60 -9c-1 -4 30 -4 52 -4c14 0 29 3 44 8Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D6FD" x="0" y="0"></use>
</g>
</svg>, rescaled path probabilities,
and the information necessary to compute MIS weights if the ray
encounters emission. 

</p>
<p></p>
<span class="anchor" id="fragment-RayWorkItemPublicMembers-1"></span><div class="fragmentname">&lt;&lt;RayWorkItem Public Members&gt;&gt;+=&nbsp;<a href="#fragment-RayWorkItemPublicMembers-0"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode"><a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <span class="anchor" id="RayWorkItem::beta"></span>beta, <span class="anchor" id="RayWorkItem::r_u"></span>r_u, <span class="anchor" id="RayWorkItem::r_l"></span>r_l;
<a href="../Light_Sources/Light_Interface.html#LightSampleContext" class="code">LightSampleContext</a> <span class="anchor" id="RayWorkItem::prevIntrCtx"></span>prevIntrCtx;
Float <span class="anchor" id="RayWorkItem::etaScale"></span>etaScale;
int <span class="anchor" id="RayWorkItem::specularBounce"></span>specularBounce;
int <span class="anchor" id="RayWorkItem::anyNonSpecularBounces"></span>anyNonSpecularBounces;</div><p>


</p>
<p>

</p>
<p>The direct lighting calculation follows a similar path as in the
<a href="../Light_Transport_II_Volume_Rendering/Volume_Scattering_Integrators.html#VolPathIntegrator"><tt>VolPathIntegrator</tt></a>.

</p>
<p></p>
<span class="anchor" id="fragment-Samplelightandenqueueshadowrayatintersectionpoint-0"></span><div class="fragmentname">&lt;&lt;Sample light and enqueue shadow ray at intersection point&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Reflection_Models/BSDF_Representation.html#BxDFFlags" class="code">BxDFFlags</a> flags = bsdf.<a href="../Reflection_Models/BSDF_Representation.html#BSDF::Flags" class="code">Flags</a>();
if (<a href="../Reflection_Models/BSDF_Representation.html#BxDFFlags::IsNonSpecular" class="code">IsNonSpecular</a>(flags)) {
    &lt;&lt;<span class="fragmentname">Choose a light source using the <tt>LightSampler</tt></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2617" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2617"><i></i></a><div id="fragbit-2617" class="collapse"><div class="fragmentcode">       <a href="../Light_Sources/Light_Interface.html#LightSampleContext" class="code">LightSampleContext</a> ctx(w.pi, w.n, ns);
       if (IsReflective(flags) &amp;&amp; !IsTransmissive(flags))
           ctx.pi = OffsetRayOrigin(ctx.pi, w.n, wo);
       else if (IsTransmissive(flags) &amp;&amp; IsReflective(flags))
           ctx.pi = OffsetRayOrigin(ctx.pi, w.n, -wo);
       pstd::optional&lt;SampledLight&gt; sampledLight =
           lightSampler.Sample(ctx, raySamples.direct.uc);
       if (!sampledLight)
           return;
       <a href="../Light_Sources/Light_Interface.html#Light" class="code">Light</a> light = sampledLight-&gt;light;</div></div>
    &lt;&lt;<span class="fragmentname">Sample light source and evaluate BSDF for direct lighting</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2618" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2618"><i></i></a><div id="fragbit-2618" class="collapse"><div class="fragmentcode">       pstd::optional&lt;<a href="../Light_Sources/Light_Interface.html#LightLiSample" class="code">LightLiSample</a>&gt; ls =
           light.<a href="../Light_Sources/Light_Interface.html#Light::SampleLi" class="code">SampleLi</a>(ctx, raySamples.direct.<a href="#RaySamples::direct::u" class="code">u</a>, lambda,
           true);
       if (!ls || !ls-&gt;<a href="../Light_Sources/Light_Interface.html#LightLiSample::L" class="code">L</a> || ls-&gt;<a href="../Light_Sources/Light_Interface.html#LightLiSample::pdf" class="code">pdf</a> == 0) return;
       <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> <a href="../Light_Sources/Light_Interface.html#LightLiSample::wi" class="code">wi</a> = ls-&gt;<a href="../Light_Sources/Light_Interface.html#LightLiSample::wi" class="code">wi</a>;
       <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> f = bsdf.f&lt;ConcreteBxDF&gt;(wo, <a href="../Light_Sources/Light_Interface.html#LightLiSample::wi" class="code">wi</a>);
       if (!f) return;</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-ComputepaththroughputandpathPDFsforlightsample-0">Compute path throughput and path PDFs for light sample</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2619" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2619"><i></i></a><div id="fragbit-2619" class="collapse"><div class="fragmentcode">       <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <a href="#MaterialEvalWorkItem::beta" class="code">beta</a> = w.<a href="#MaterialEvalWorkItem::beta" class="code">beta</a> * f * <a href="../Geometry_and_Transformations/Vectors.html#AbsDot" class="code">AbsDot</a>(wi, ns);
       Float lightPDF = ls-&gt;<a href="../Light_Sources/Light_Interface.html#LightLiSample::pdf" class="code">pdf</a> * sampledLight-&gt;<a href="../Light_Sources/Light_Sampling.html#SampledLight::p" class="code">p</a>;
       Float bsdfPDF = <a href="../Light_Sources/Light_Interface.html#IsDeltaLight" class="code">IsDeltaLight</a>(light.<a href="../Light_Sources/Light_Interface.html#Light::Type" class="code">Type</a>()) ? 0.f
                                                  : bsdf.<a href="../Reflection_Models/BSDF_Representation.html#BSDF::PDF" class="code">PDF</a>&lt;ConcreteBxDF&gt;(wo, wi);
       <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <a href="#MaterialEvalWorkItem::r_u" class="code">r_u</a> = w.<a href="#MaterialEvalWorkItem::r_u" class="code">r_u</a> * bsdfPDF;
       <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> r_l = w.<a href="#MaterialEvalWorkItem::r_u" class="code">r_u</a> * lightPDF;</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Enqueueshadowraywithtentativeradiancecontribution-0">Enqueue shadow ray with tentative radiance contribution</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2620" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2620"><i></i></a><div id="fragbit-2620" class="collapse"><div class="fragmentcode">       <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> Ld = beta * ls-&gt;<a href="../Light_Sources/Light_Interface.html#LightLiSample::L" class="code">L</a>;
       <a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> ray = <a href="../Shapes/Managing_Rounding_Error.html#SpawnRayTo" class="code">SpawnRayTo</a>(w.<a href="../Geometry_and_Transformations/Interactions.html#Interaction::pi" class="code">pi</a>, w.<a href="../Geometry_and_Transformations/Interactions.html#Interaction::n" class="code">n</a>, w.<a href="#MaterialEvalWorkItem::time" class="code">time</a>, ls-&gt;<a href="../Light_Sources/Light_Interface.html#LightLiSample::pLight" class="code">pLight</a>.<a href="../Geometry_and_Transformations/Interactions.html#Interaction::pi" class="code">pi</a>, ls-&gt;<a href="../Light_Sources/Light_Interface.html#LightLiSample::pLight" class="code">pLight</a>.<a href="../Geometry_and_Transformations/Interactions.html#Interaction::n" class="code">n</a>);
       &lt;&lt;<span class="fragmentname"><a href="#fragment-Initializemonoraymediumifmediaarepresent-0">Initialize <tt>ray</tt> medium if media are present</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2621" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2621"><i></i></a><div id="fragbit-2621" class="collapse"><div class="fragmentcode">          if (haveMedia)
              ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::medium" class="code">medium</a> = <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::d" class="code">d</a>, w.<a href="#MaterialEvalWorkItem::n" class="code">n</a>) &gt; 0 ? w.<a href="#MaterialEvalWorkItem::mediumInterface" class="code">mediumInterface</a>.outside
                                               : w.<a href="#MaterialEvalWorkItem::mediumInterface" class="code">mediumInterface</a>.inside;</div></div>
       <a href="#WavefrontPathIntegrator::shadowRayQueue" class="code">shadowRayQueue</a>-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#WorkQueue::Push" class="code">Push</a>(ShadowRayWorkItem{ray, 1 - <a href="../Shapes/Managing_Rounding_Error.html#ShadowEpsilon" class="code">ShadowEpsilon</a>, lambda, Ld,
                                              r_u, r_l, w.<a href="#MaterialEvalWorkItem::pixelIndex" class="code">pixelIndex</a>});
       </div></div>
}</div><p>


</p>
<p>

</p>
<p>We will omit the &lt;&lt;<span class="fragmentname">Choose a light source using the
<tt>LightSampler</tt></span>&gt;&gt; and &lt;&lt;<span class="fragmentname">Sample light source and evaluate BSDF
for direct lighting</span>&gt;&gt; fragments, as they are essentially the same as
corresponding fragments that we have seen in earlier integrators.  The
first fragment gives us the <tt>sampledLight</tt> variable that stores a
<a href="../Light_Sources/Light_Sampling.html#SampledLight"><tt>SampledLight</tt></a> and the second calls <a href="../Light_Sources/Light_Interface.html#Light::SampleLi"><tt>Light::SampleLi()</tt></a> with that
light, giving an <tt>ls</tt> variable that stores the <a href="../Light_Sources/Light_Interface.html#LightLiSample"><tt>LightLiSample</tt></a>.

</p>
<p>

</p>
<p>The path throughput and path sampling weights are computed in the same way
as they are in the <a href="../Light_Transport_II_Volume_Rendering/Volume_Scattering_Integrators.html#VolPathIntegrator::SampleLd"><tt>VolPathIntegrator::SampleLd()</tt></a> method, though here
it is again possible to use the templated <tt>BSDF::PDF()</tt> method that
avoids the dynamic dispatch overhead to compute the BSDF&rsquo;s PDF.

</p>
<p></p>
<span class="anchor" id="fragment-ComputepaththroughputandpathPDFsforlightsample-0"></span><div class="fragmentname">&lt;&lt;Compute path throughput and path PDFs for light sample&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <a href="#MaterialEvalWorkItem::beta" class="code">beta</a> = w.<a href="#MaterialEvalWorkItem::beta" class="code">beta</a> * f * <a href="../Geometry_and_Transformations/Vectors.html#AbsDot" class="code">AbsDot</a>(wi, ns);
Float lightPDF = ls-&gt;<a href="../Light_Sources/Light_Interface.html#LightLiSample::pdf" class="code">pdf</a> * sampledLight-&gt;<a href="../Light_Sources/Light_Sampling.html#SampledLight::p" class="code">p</a>;
Float bsdfPDF = <a href="../Light_Sources/Light_Interface.html#IsDeltaLight" class="code">IsDeltaLight</a>(light.<a href="../Light_Sources/Light_Interface.html#Light::Type" class="code">Type</a>()) ? 0.f
                                           : bsdf.<a href="../Reflection_Models/BSDF_Representation.html#BSDF::PDF" class="code">PDF</a>&lt;ConcreteBxDF&gt;(wo, wi);
<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <a href="#MaterialEvalWorkItem::r_u" class="code">r_u</a> = w.<a href="#MaterialEvalWorkItem::r_u" class="code">r_u</a> * bsdfPDF;
<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> r_l = w.<a href="#MaterialEvalWorkItem::r_u" class="code">r_u</a> * lightPDF;</div><p>


</p>
<p>We go ahead and compute <tt>Ld</tt>, which is the final weighted contribution
that the shadow ray would give to the pixel sample&rsquo;s radiance estimate if
it is unoccluded.  If the ray is unoccluded and there are participating
media in the scene, <tt>Ld</tt> may still be reduced due to the effect of
extinction along the shadow ray; that factor is handled when the shadow ray
is traced.
 
</p>
<span class="anchor" id="fragment-Enqueueshadowraywithtentativeradiancecontribution-0"></span><div class="fragmentname">&lt;&lt;Enqueue shadow ray with tentative radiance contribution&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> Ld = beta * ls-&gt;<a href="../Light_Sources/Light_Interface.html#LightLiSample::L" class="code">L</a>;
<a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> ray = <a href="../Shapes/Managing_Rounding_Error.html#SpawnRayTo" class="code">SpawnRayTo</a>(w.<a href="../Geometry_and_Transformations/Interactions.html#Interaction::pi" class="code">pi</a>, w.<a href="../Geometry_and_Transformations/Interactions.html#Interaction::n" class="code">n</a>, w.<a href="#MaterialEvalWorkItem::time" class="code">time</a>, ls-&gt;<a href="../Light_Sources/Light_Interface.html#LightLiSample::pLight" class="code">pLight</a>.<a href="../Geometry_and_Transformations/Interactions.html#Interaction::pi" class="code">pi</a>, ls-&gt;<a href="../Light_Sources/Light_Interface.html#LightLiSample::pLight" class="code">pLight</a>.<a href="../Geometry_and_Transformations/Interactions.html#Interaction::n" class="code">n</a>);
&lt;&lt;<span class="fragmentname"><a href="#fragment-Initializemonoraymediumifmediaarepresent-0">Initialize <tt>ray</tt> medium if media are present</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2622" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2622"><i></i></a><div id="fragbit-2622" class="collapse"><div class="fragmentcode">   if (haveMedia)
       ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::medium" class="code">medium</a> = <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::d" class="code">d</a>, w.<a href="#MaterialEvalWorkItem::n" class="code">n</a>) &gt; 0 ? w.<a href="#MaterialEvalWorkItem::mediumInterface" class="code">mediumInterface</a>.outside
                                        : w.<a href="#MaterialEvalWorkItem::mediumInterface" class="code">mediumInterface</a>.inside;</div></div>
<a href="#WavefrontPathIntegrator::shadowRayQueue" class="code">shadowRayQueue</a>-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#WorkQueue::Push" class="code">Push</a>(ShadowRayWorkItem{ray, 1 - <a href="../Shapes/Managing_Rounding_Error.html#ShadowEpsilon" class="code">ShadowEpsilon</a>, lambda, Ld,
                                       r_u, r_l, w.<a href="#MaterialEvalWorkItem::pixelIndex" class="code">pixelIndex</a>});
</div><p>


</p>
<p>

</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#ShadowRays"><i class="fas fa-link h3h4marginlink"></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span id="ShadowRays"></span><h3>15.3.10  Shadow Rays</h3><p>


</p>
<p>The set of shadow rays to be traced after material evaluation and the
direct lighting calculation in the <tt>EvaluateMaterialAndBSDF()</tt> method
are stored in a <a href="#ShadowRayQueue"><tt>ShadowRayQueue</tt></a>.

</p>
<p></p>
<span class="anchor" id="fragment-ShadowRayQueueDefinition-0"></span><div class="fragmentname">&lt;&lt;ShadowRayQueue Definition&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">using <span class="anchor" id="ShadowRayQueue"></span>ShadowRayQueue = <a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#WorkQueue" class="code">WorkQueue</a>&lt;<a href="#ShadowRayWorkItem" class="code">ShadowRayWorkItem</a>&gt;;</div><p>


</p>
<p>A single <a href="#ShadowRayQueue"><tt>ShadowRayQueue</tt></a> is maintained by the <a href="#WavefrontPathIntegrator"><tt>WavefrontPathIntegrator</tt></a>.

</p>
<p></p>
<span class="anchor" id="fragment-WavefrontPathIntegratorMemberVariables-10"></span><div class="fragmentname">&lt;&lt;WavefrontPathIntegrator Member Variables&gt;&gt;+=&nbsp;<a href="#fragment-WavefrontPathIntegratorMemberVariables-9"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode">ShadowRayQueue *<span class="anchor" id="WavefrontPathIntegrator::shadowRayQueue"></span>shadowRayQueue = nullptr;</div><p>


</p>
<p>
The work items in the queue store values that include the ray to be traced,
its wavelengths, and tentative contribution <tt>Ld</tt>, as well as the
rescaled path probabilities up to the ray&rsquo;s origin.

</p>
<p></p>
<span class="anchor" id="fragment-ShadowRayWorkItemDefinition-0"></span><div class="fragmentname">&lt;&lt;ShadowRayWorkItem Definition&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">struct <span class="anchor" id="ShadowRayWorkItem"></span>ShadowRayWorkItem {
    <a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> <span class="anchor" id="ShadowRayWorkItem::ray"></span>ray;
    Float <span class="anchor" id="ShadowRayWorkItem::tMax"></span>tMax;
    <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> <span class="anchor" id="ShadowRayWorkItem::lambda"></span>lambda;
    <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <span class="anchor" id="ShadowRayWorkItem::Ld"></span>Ld, <span class="anchor" id="ShadowRayWorkItem::r_u"></span>r_u, <span class="anchor" id="ShadowRayWorkItem::r_l"></span>r_l;
    int <span class="anchor" id="ShadowRayWorkItem::pixelIndex"></span>pixelIndex;
};</div><p>


</p>
<p>The <a href="#WavefrontAggregate"><tt>WavefrontAggregate</tt></a> interface includes two methods for tracing
shadow rays: <tt>IntersectShadow()</tt>, which is called for scenes that have
no participating media where only a binary visibility test is needed, and
<tt>IntersectShadowTr()</tt> for scenes that do have media and where
transmittance must be computed. A call to the
<tt>WavefrontPathIntegrator::TraceShadowRays()</tt><span class="anchor" id="WavefrontPathIntegrator::TraceShadowRays"></span>
method leads to a call of the appropriate method; the shadow ray queue is
reset immediately afterward.

</p>
<p></p>
<span class="anchor" id="fragment-WavefrontAggregateInterface-2"></span><div class="fragmentname">&lt;&lt;WavefrontAggregate Interface&gt;&gt;+=&nbsp;<a href="#fragment-WavefrontAggregateInterface-1"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode">virtual void <span class="anchor" id="WavefrontAggregate::IntersectShadow"></span>IntersectShadow(int maxRays, ShadowRayQueue *shadowRayQueue,
    SOA&lt;<a href="#PixelSampleState" class="code">PixelSampleState</a>&gt; *pixelSampleState) const = 0;
virtual void <span class="anchor" id="WavefrontAggregate::IntersectShadowTr"></span>IntersectShadowTr(int maxRays, ShadowRayQueue *shadowRayQueue,
    SOA&lt;<a href="#PixelSampleState" class="code">PixelSampleState</a>&gt; *pixelSampleState) const = 0;</div><p>


</p>
<p>The CPU implementation of <tt>IntersectShadow()</tt> processes
items from the queue in parallel and calls its aggregate&rsquo;s
<tt>IntersectP()</tt> method to determine if each ray is occluded.  A call to
<tt>RecordShadowRayResult()</tt>, another utility function shared by
both CPU and GPU aggregates that is defined in
<a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/wavefront/intersect.h"><tt>wavefront/intersect.h</tt></a>, takes care of the additional work to be
done after the intersection test has been resolved.

</p>
<p></p>
<span class="anchor" id="fragment-CPUAggregateMethodDefinitions-0"></span><div class="fragmentname">&lt;&lt;CPUAggregate Method Definitions&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">void <span class="anchor" id="CPUAggregate::IntersectShadow"></span>CPUAggregate::IntersectShadow(
        int maxRays, ShadowRayQueue *shadowRayQueue,
        SOA&lt;<a href="#PixelSampleState" class="code">PixelSampleState</a>&gt; *pixelSampleState) const {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-IntersectshadowraysfrommonoshadowRayQueueinparallel-0">Intersect shadow rays from <tt>shadowRayQueue</tt> in parallel</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2623" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2623"><i></i></a><div id="fragbit-2623" class="collapse"><div class="fragmentcode">       <a href="../Utilities/Parallelism.html#ParallelFor" class="code">ParallelFor</a>(0, shadowRayQueue-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#WorkQueue::Size" class="code">Size</a>(),
                   [=] (int index) {
                       const ShadowRayWorkItem w = (*shadowRayQueue)[index];
                       bool hit = aggregate.<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive::IntersectP" class="code">IntersectP</a>(w.<a href="#ShadowRayWorkItem::ray" class="code">ray</a>, w.<a href="#ShadowRayWorkItem::tMax" class="code">tMax</a>);
                       <a href="#RecordShadowRayResult" class="code">RecordShadowRayResult</a>(w, pixelSampleState, hit);
                   });</div></div>
}</div><p>


</p>
<p></p>
<span class="anchor" id="fragment-IntersectshadowraysfrommonoshadowRayQueueinparallel-0"></span><div class="fragmentname">&lt;&lt;Intersect shadow rays from <tt>shadowRayQueue</tt> in parallel&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Utilities/Parallelism.html#ParallelFor" class="code">ParallelFor</a>(0, shadowRayQueue-&gt;<a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#WorkQueue::Size" class="code">Size</a>(),
            [=] (int index) {
                const ShadowRayWorkItem w = (*shadowRayQueue)[index];
                bool hit = aggregate.<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive::IntersectP" class="code">IntersectP</a>(w.<a href="#ShadowRayWorkItem::ray" class="code">ray</a>, w.<a href="#ShadowRayWorkItem::tMax" class="code">tMax</a>);
                <a href="#RecordShadowRayResult" class="code">RecordShadowRayResult</a>(w, pixelSampleState, hit);
            });</div><p>


</p>
<p>If the ray was occluded, then no further work is necessary.  Otherwise, the
final MIS-weighted radiance is found by dividing by the two rescaled path
probabilities and is
then added to the running sum of the radiance estimate in the
<tt>PixelSampleState</tt> for the ray.

</p>
<p></p>
<span class="anchor" id="fragment-WavefrontRayIntersectionEnqueuingFunctions-1"></span><div class="fragmentname">&lt;&lt;Wavefront Ray Intersection Enqueuing Functions&gt;&gt;+=&nbsp;<a href="#fragment-WavefrontRayIntersectionEnqueuingFunctions-0"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode">void <span class="anchor" id="RecordShadowRayResult"></span>RecordShadowRayResult(const ShadowRayWorkItem w,
        SOA&lt;<a href="#PixelSampleState" class="code">PixelSampleState</a>&gt; *pixelSampleState, bool foundIntersection) {
    if (foundIntersection)
        return;
    <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <a href="#ShadowRayWorkItem::Ld" class="code">Ld</a> = w.<a href="#ShadowRayWorkItem::Ld" class="code">Ld</a> / (w.<a href="#ShadowRayWorkItem::r_u" class="code">r_u</a> + w.<a href="#ShadowRayWorkItem::r_l" class="code">r_l</a>).<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum::Average" class="code">Average</a>();
    <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> Lpixel = pixelSampleState-&gt;<a href="#PixelSampleState::L" class="code">L</a>[w.<a href="#ShadowRayWorkItem::pixelIndex" class="code">pixelIndex</a>];
    pixelSampleState-&gt;<a href="#PixelSampleState::L" class="code">L</a>[w.<a href="#ShadowRayWorkItem::pixelIndex" class="code">pixelIndex</a>] = Lpixel + <a href="#ShadowRayWorkItem::Ld" class="code">Ld</a>;
}</div><p>


</p>
<p>In the presence of participating media, there is more work to do for shadow
rays.  The computation proceeds just as in the latter two thirds of the
<a href="../Light_Transport_II_Volume_Rendering/Volume_Scattering_Integrators.html#VolPathIntegrator::SampleLd"><tt>VolPathIntegrator::SampleLd()</tt></a> method: the ray is successively
intersected against the scene geometry, terminating if it hits an opaque
surface.  Otherwise a call to <a href="../Light_Transport_II_Volume_Rendering/The_Equation_of_Transfer.html#SampleT_maj"><tt>SampleT_maj()</tt></a> samples the
medium, so that transmittance can be estimated using ratio tracking just
as in &lt;&lt;<span class="fragmentname"><a href="../Light_Transport_II_Volume_Rendering/Volume_Scattering_Integrators.html#fragment-Updatetransmittanceforcurrentraysegment-0">Update transmittance for current ray segment</a></span>&gt;&gt; in that
method.  Given the close similarities, we will not include that code for
the wavefront integrator here.

</p>
<p>

</p>
<p>

</p>
<p>

</p>
<p>

</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#UpdatingtheFilm"><i class="fas fa-link h3h4marginlink"></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span class="anchor" id="sec:gpu-film-update"></span><span id="UpdatingtheFilm"></span><h3>15.3.11  Updating the Film</h3><p>



</p>
<p>Each pixel sample&rsquo;s value is provided to the <a href="../Cameras_and_Film/Film_and_Imaging.html#Film"><tt>Film</tt></a>  only after all of
them are finished.  One might wonder: why not push samples on to a queue
whenever their ray paths terminate and add film samples sooner by
periodically running a kernel that processes the items on the queue?  There
are two costs to such an approach: the first is that samples would be added
to the film in an arbitrary order, so the accesses to values like
<a href="#PixelSampleState::L"><tt>PixelSampleState::L</tt></a> would be irregular across threads in thread
groups, which could harm performance.

</p>
<p>The second cost is the unnecessary bandwidth that would be used to push
work onto the queue and to process it.  We know that every pixel sample
taken at the start of tracing each path will eventually be added to the
film, so there is no need to separately enumerate them.  For both of these
reasons, it is more efficient to use a plain <a href="../Wavefront_Rendering_on_GPUs/Implementation_Foundations.html#GPUParallelFor"><tt>GPUParallelFor()</tt></a> loop
and process the <a href="#PixelSampleState"><tt>PixelSampleState</tt></a> structures in order.

</p>
<p></p>
<span class="anchor" id="fragment-WavefrontPathIntegratorFilmMethods-0"></span><div class="fragmentname">&lt;&lt;WavefrontPathIntegrator Film Methods&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">void <span class="anchor" id="WavefrontPathIntegrator::UpdateFilm"></span>WavefrontPathIntegrator::UpdateFilm() {
    <a href="#WavefrontPathIntegrator::ParallelFor" class="code">ParallelFor</a>("Update film", <a href="#WavefrontPathIntegrator::maxQueueSize" class="code">maxQueueSize</a>,
        PBRT_CPU_GPU_LAMBDA (int pixelIndex) {
            &lt;&lt;<span class="fragmentname"><a href="#fragment-Checkpixelagainstfilmbounds-0">Check pixel against film bounds</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2624" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2624"><i></i></a><div id="fragbit-2624" class="collapse"><div class="fragmentcode">               <a href="../Geometry_and_Transformations/Points.html#Point2i" class="code">Point2i</a> <a href="#PixelSampleState::pPixel" class="code">pPixel</a> = <a href="#WavefrontPathIntegrator::pixelSampleState" class="code">pixelSampleState</a>.<a href="#PixelSampleState::pPixel" class="code">pPixel</a>[pixelIndex];
               if (!<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds2::InsideExclusive" class="code">InsideExclusive</a>(<a href="#PixelSampleState::pPixel" class="code">pPixel</a>, <a href="#WavefrontPathIntegrator::film" class="code">film</a>.<a href="../Cameras_and_Film/Film_and_Imaging.html#Film::PixelBounds" class="code">PixelBounds</a>()))
                   return;</div></div>
            &lt;&lt;<span class="fragmentname"><a href="#fragment-Computefinalweightedradiancevalue-0">Compute final weighted radiance value</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2625" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2625"><i></i></a><div id="fragbit-2625" class="collapse"><div class="fragmentcode">               <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> Lw = <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a>(<a href="#WavefrontPathIntegrator::pixelSampleState" class="code">pixelSampleState</a>.<a href="#PixelSampleState::L" class="code">L</a>[pixelIndex]) *
                                    <a href="#WavefrontPathIntegrator::pixelSampleState" class="code">pixelSampleState</a>.<a href="#PixelSampleState::cameraRayWeight" class="code">cameraRayWeight</a>[pixelIndex];</div></div>
            &lt;&lt;<span class="fragmentname"><a href="#fragment-Providesampleradiancevaluetofilm-0">Provide sample radiance value to film</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2626" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2626"><i></i></a><div id="fragbit-2626" class="collapse"><div class="fragmentcode">               <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> <a href="#PixelSampleState::lambda" class="code">lambda</a> = <a href="#WavefrontPathIntegrator::pixelSampleState" class="code">pixelSampleState</a>.<a href="#PixelSampleState::lambda" class="code">lambda</a>[pixelIndex];
               Float <a href="#PixelSampleState::filterWeight" class="code">filterWeight</a> = <a href="#WavefrontPathIntegrator::pixelSampleState" class="code">pixelSampleState</a>.<a href="#PixelSampleState::filterWeight" class="code">filterWeight</a>[pixelIndex];
               if (initializeVisibleSurface) {
                   &lt;&lt;<span class="fragmentname"><a href="#fragment-CallmonoFilm::AddSamplewithmonoVisibleSurfaceforpixelsample-0">Call <tt>Film::AddSample()</tt> with <tt>VisibleSurface</tt> for pixel sample</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2627" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2627"><i></i></a><div id="fragbit-2627" class="collapse"><div class="fragmentcode">                      <a href="../Cameras_and_Film/Film_and_Imaging.html#VisibleSurface" class="code">VisibleSurface</a> <a href="#PixelSampleState::visibleSurface" class="code">visibleSurface</a> = <a href="#WavefrontPathIntegrator::pixelSampleState" class="code">pixelSampleState</a>.<a href="#PixelSampleState::visibleSurface" class="code">visibleSurface</a>[pixelIndex];
                      <a href="#WavefrontPathIntegrator::film" class="code">film</a>.<a href="../Cameras_and_Film/Film_and_Imaging.html#Film::AddSample" class="code">AddSample</a>(pPixel, Lw, lambda, &amp;<a href="#PixelSampleState::visibleSurface" class="code">visibleSurface</a>, filterWeight);</div></div>
               } else
                   <a href="#WavefrontPathIntegrator::film" class="code">film</a>.<a href="../Cameras_and_Film/Film_and_Imaging.html#Film::AddSample" class="code">AddSample</a>(pPixel, Lw, <a href="#PixelSampleState::lambda" class="code">lambda</a>, nullptr, <a href="#PixelSampleState::filterWeight" class="code">filterWeight</a>);</div></div>
    });
}</div><p>


</p>
<p>Recall that the <tt>GenerateCameraRays()</tt> method sets the
<a href="#PixelSampleState::pPixel"><tt>PixelSampleState::pPixel</tt></a> coordinates for all the threads, but that
it then exits immediately for threads corresponding to extra scanlines beyond
the end of the image.   Therefore, we must perform the same check of the
pixel coordinates against the film bounds here, and not do any further
processing for such pixels.

</p>
<p></p>
<span class="anchor" id="fragment-Checkpixelagainstfilmbounds-0"></span><div class="fragmentname">&lt;&lt;Check pixel against film bounds&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Geometry_and_Transformations/Points.html#Point2i" class="code">Point2i</a> <a href="#PixelSampleState::pPixel" class="code">pPixel</a> = <a href="#WavefrontPathIntegrator::pixelSampleState" class="code">pixelSampleState</a>.<a href="#PixelSampleState::pPixel" class="code">pPixel</a>[pixelIndex];
if (!<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds2::InsideExclusive" class="code">InsideExclusive</a>(<a href="#PixelSampleState::pPixel" class="code">pPixel</a>, <a href="#WavefrontPathIntegrator::film" class="code">film</a>.<a href="../Cameras_and_Film/Film_and_Imaging.html#Film::PixelBounds" class="code">PixelBounds</a>()))
    return;</div><p>


</p>
<p>The final radiance value is scaled by the camera ray weight returned by the
<a href="../Cameras_and_Film/Camera_Interface.html#Camera"><tt>Camera</tt></a> before it is provided to the <a href="../Cameras_and_Film/Film_and_Imaging.html#Film"><tt>Film</tt></a>.<button style="button" data-toggle="tooltip" data-placement="right" data-html="true" class="btn footnote-button" title="The explicit
<tt>SampledSpectrum</tt> cast of the <tt>L</tt> value read from
<tt>pixelSampleState</tt> is an unfortunate artifact of the
<tt>GetSetIndirector</tt> used in the <tt>SOA</tt> classes.  If the value read
from the array is not immediately converted to a <tt>SampledSpectrum</tt>,
then the compiler is left with what seems to be an attempt to multiply a
<tt>GetSetIndirector</tt> type with a <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum"><tt>SampledSpectrum</tt></a>, leading to a
syntax error.">
      <sup>&dagger;</sup>
    </button>
		

</p>
<p></p>
<span class="anchor" id="fragment-Computefinalweightedradiancevalue-0"></span><div class="fragmentname">&lt;&lt;Compute final weighted radiance value&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> Lw = <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a>(<a href="#WavefrontPathIntegrator::pixelSampleState" class="code">pixelSampleState</a>.<a href="#PixelSampleState::L" class="code">L</a>[pixelIndex]) *
                     <a href="#WavefrontPathIntegrator::pixelSampleState" class="code">pixelSampleState</a>.<a href="#PixelSampleState::cameraRayWeight" class="code">cameraRayWeight</a>[pixelIndex];</div><p>


</p>
<p>A few more values read from <tt>pixelSampleState</tt> and we have everything
that we need to call the <a href="../Cameras_and_Film/Film_and_Imaging.html#Film"><tt>Film</tt></a>&rsquo;s <tt>AddSample()</tt> method.  The
implementation uses the <tt>initializeVisibleSurface</tt> member variable,
set in the constructor, to distinguish between <a href="../Cameras_and_Film/Film_and_Imaging.html#Film"><tt>Film</tt></a> implementations that
make use of the <a href="../Cameras_and_Film/Film_and_Imaging.html#VisibleSurface"><tt>VisibleSurface</tt></a> and those that do not in order to save the
memory bandwidth of reading it if it will not be used.

</p>
<p></p>
<span class="anchor" id="fragment-Providesampleradiancevaluetofilm-0"></span><div class="fragmentname">&lt;&lt;Provide sample radiance value to film&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> <a href="#PixelSampleState::lambda" class="code">lambda</a> = <a href="#WavefrontPathIntegrator::pixelSampleState" class="code">pixelSampleState</a>.<a href="#PixelSampleState::lambda" class="code">lambda</a>[pixelIndex];
Float <a href="#PixelSampleState::filterWeight" class="code">filterWeight</a> = <a href="#WavefrontPathIntegrator::pixelSampleState" class="code">pixelSampleState</a>.<a href="#PixelSampleState::filterWeight" class="code">filterWeight</a>[pixelIndex];
if (initializeVisibleSurface) {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-CallmonoFilm::AddSamplewithmonoVisibleSurfaceforpixelsample-0">Call <tt>Film::AddSample()</tt> with <tt>VisibleSurface</tt> for pixel sample</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2628" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2628"><i></i></a><div id="fragbit-2628" class="collapse"><div class="fragmentcode">       <a href="../Cameras_and_Film/Film_and_Imaging.html#VisibleSurface" class="code">VisibleSurface</a> <a href="#PixelSampleState::visibleSurface" class="code">visibleSurface</a> = <a href="#WavefrontPathIntegrator::pixelSampleState" class="code">pixelSampleState</a>.<a href="#PixelSampleState::visibleSurface" class="code">visibleSurface</a>[pixelIndex];
       <a href="#WavefrontPathIntegrator::film" class="code">film</a>.<a href="../Cameras_and_Film/Film_and_Imaging.html#Film::AddSample" class="code">AddSample</a>(pPixel, Lw, lambda, &amp;<a href="#PixelSampleState::visibleSurface" class="code">visibleSurface</a>, filterWeight);</div></div>
} else
    <a href="#WavefrontPathIntegrator::film" class="code">film</a>.<a href="../Cameras_and_Film/Film_and_Imaging.html#Film::AddSample" class="code">AddSample</a>(pPixel, Lw, <a href="#PixelSampleState::lambda" class="code">lambda</a>, nullptr, <a href="#PixelSampleState::filterWeight" class="code">filterWeight</a>);</div><p>


</p>
<p>One interesting detail is that the <a href="../Cameras_and_Film/Film_and_Imaging.html#VisibleSurface"><tt>VisibleSurface</tt></a> must be
loaded from SOA format into the regular <a href="../Cameras_and_Film/Film_and_Imaging.html#VisibleSurface"><tt>VisibleSurface</tt></a> structure
layout so that a pointer to it can be passed to the <tt>AddSample()</tt>
method; a pointer to its current in-memory representation does not
correspond to the layout that this method expects.

</p>
<p></p>
<span class="anchor" id="fragment-CallmonoFilm::AddSamplewithmonoVisibleSurfaceforpixelsample-0"></span><div class="fragmentname">&lt;&lt;Call <tt>Film::AddSample()</tt> with <tt>VisibleSurface</tt> for pixel sample&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Cameras_and_Film/Film_and_Imaging.html#VisibleSurface" class="code">VisibleSurface</a> <a href="#PixelSampleState::visibleSurface" class="code">visibleSurface</a> = <a href="#WavefrontPathIntegrator::pixelSampleState" class="code">pixelSampleState</a>.<a href="#PixelSampleState::visibleSurface" class="code">visibleSurface</a>[pixelIndex];
<a href="#WavefrontPathIntegrator::film" class="code">film</a>.<a href="../Cameras_and_Film/Film_and_Imaging.html#Film::AddSample" class="code">AddSample</a>(pPixel, Lw, lambda, &amp;<a href="#PixelSampleState::visibleSurface" class="code">visibleSurface</a>, filterWeight);</div><p>


</p>
<p>

</p>
<p>

</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

</div>  <!-- container-fluid -->
</div>  <!-- maincontainer -->

<nav class="navbar navbar-expand-md bg-light navbar-light">
<div class="container-fluid">
  <span class="navbar-text"><i>Physically Based Rendering: From Theory To Implementation</i>,<br>
<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">&copy; 2004-2023</a> Matt Pharr, Wenzel Jakob, and Greg Humphreys.
<a href="https://github.com/mmp/pbr-book-website/"><span class="fab fa-github"></span></a><br>
Purchase a printed copy: <a href="https://www.amazon.com/Physically-Based-Rendering-fourth-Implementation/dp/0262048027?keywords=physically+based+rendering+4th+edition&qid=1671730412&sprefix=physically+based%!C(MISSING)aps%!C(MISSING)145&sr=8-1&linkCode=ll1&tag=pharr-20&linkId=81a816d90f0c7e872617f1f930a51fd6&language=en_US&ref_=as_li_ss_tl"><span class="fab fa-amazon"></span></a>
<a href="https://mitpress.mit.edu/9780262048026/physically-based-rendering/"><img src="/mitpress.png" width=10 height=16></a>
</span>
</div>
  <div class="container">
    <ul class="nav navbar-nav ml-auto">
      <li class="nav-item">Next: <a href="../Wavefront_Rendering_on_GPUs/Further_Reading.html">Wavefront Rendering on GPUs / Further Reading</a></li>
    </ul>
  </div>

</nav>

<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script>
  $(function () {
    $('[data-toggle="popover"]').popover()
    $('[data-toggle="tooltip"]').tooltip()
   })
</script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>

<script>
// https://stackoverflow.com/a/17535094
// The function actually applying the offset
function offsetAnchor() {
  if (location.hash.length !== 0) {
    window.scrollTo(window.scrollX, window.scrollY - window.innerHeight / 8);
  }
}

// Captures click events of all <a> elements with href starting with #
$(document).on('click', 'a[href^="#"]', function(event) {
  // Click events are captured before hashchanges. Timeout
  // causes offsetAnchor to be called after the page jump.
  window.setTimeout(function() {
    offsetAnchor();
  }, 500);
});

// Set the offset when entering page with hash present in the url
window.setTimeout(offsetAnchor, 1500);
</script>

</body>
</html>
