
<!doctype html>
<html lang="en">
<head>

<!-- all praise to https://realfavicongenerator.net -->
<link rel="icon" href="/favicon.ico?v=2" /> <!-- force refresh -->
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">

  <!-- Required meta tags -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="/fonts.css">
  <link rel="stylesheet" href="../pbrstyle.css">
  <link rel="stylesheet" href="/fontawesome-free-5.15.3-web/css/all.css">

  <script async src="https://cse.google.com/cse.js?cx=003601324460585362024:4xwpwgaitgd"></script>
  <script src="/react.min.js"></script>
  <script src="/react-dom.min.js"></script>
  <script src="/jeri.min.js"></script>
  <link rel="preload" href="/exr.worker.js" as="script" crossorigin="anonymous">
        
  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/bootstrap.min.css">

  <title>Light Interface</title>
</head>
        
<body>

<nav class="fixed-top-lg-navbar navbar navbar-expand bg-light navbar-light">
  <ul class="nav navbar-nav">
    <a class="navbar-brand" href="../contents.html"><img src="../pbr.jpg" width=25 height=25></a>
    <li class="nav-item"><a class="nav-link" href="../Light_Sources.html">Light Sources</a></li>
    <span class="navbar-text">/</span>
    <li class="nav-item"><a class="nav-link" href="#">Light Interface</a></li>
    <span class="navbar-text">&nbsp;&nbsp;</span>
    <li class="nav-item"><a class="nav-link" href="../Light_Sources.html">(Previous: Light Sources)</a></li>
  </ul>

  <ul class="nav navbar-nav ml-auto d-none d-md-block">
        <li class="nav-item"><div class="gcse-search"></div></li>
    </ul>
  <ul class="nav navbar-nav d-block d-md-none">
        <li class="nav-item"><div class="gcse-search"></div></li>
    </ul>
</nav>

<div class="maincontainer">
<div class="container-fluid">

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">

</div>
<div class="col-md-10 col-lg-8">

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#"><i class="fas fa-link "></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span class="anchor" id="sec:light"></span><h2>12.1 Light Interface</h2><p>



</p>
<p>The <a href="#Light"><tt>Light</tt></a> class defines the interface that light sources must
implement. It is defined in the file <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/base/light.h"><tt>base/light.h</tt></a> and all the light
implementations in the following sections are in the files
<a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/lights.h"><tt>lights.h</tt></a> and <a href="https://github.com/mmp/pbrt-v4/tree/master/src/pbrt/lights.cpp"><tt>lights.cpp</tt></a>.

</p>
<p></p>
<span class="anchor" id="fragment-LightDefinition-0"></span><div class="fragmentname">&lt;&lt;Light Definition&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">class <span class="anchor" id="Light"></span>Light : public <a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer" class="code">TaggedPointer</a>&lt;&lt;&lt;<span class="fragmentname"><a href="#fragment-LightSourceTypes-0">Light Source Types</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1627" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-1627"><i></i></a><div id="fragbit-1627" class="collapse"><div class="fragmentcode">        <a href="../Light_Sources/Point_Lights.html#PointLight" class="code">PointLight</a>, <a href="../Light_Sources/Distant_Lights.html#DistantLight" class="code">DistantLight</a>, <a href="../Light_Sources/Point_Lights.html#ProjectionLight" class="code">ProjectionLight</a>, <a href="../Light_Sources/Point_Lights.html#GoniometricLight" class="code">GoniometricLight</a>, <a href="../Light_Sources/Point_Lights.html#SpotLight" class="code">SpotLight</a>,
        <a href="../Light_Sources/Area_Lights.html#DiffuseAreaLight" class="code">DiffuseAreaLight</a>, <a href="../Light_Sources/Infinite_Area_Lights.html#UniformInfiniteLight" class="code">UniformInfiniteLight</a>, <a href="../Light_Sources/Infinite_Area_Lights.html#ImageInfiniteLight" class="code">ImageInfiniteLight</a>,
        <a href="../Light_Sources/Infinite_Area_Lights.html#PortalImageInfiniteLight" class="code">PortalImageInfiniteLight</a></div></div>&gt; {
  public:
    &lt;&lt;<span class="fragmentname"><a href="#fragment-LightInterface-0">Light Interface</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1628" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-1628"><i></i></a><div id="fragbit-1628" class="collapse"><div class="fragmentcode">       using <a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer" class="code">TaggedPointer</a>::<a href="../Utilities/Containers_and_Memory_Management.html#TaggedPointer" class="code">TaggedPointer</a>;
       
       static <a href="#Light" class="code">Light</a> Create(const std::string &amp;name,
                                 const ParameterDictionary &amp;parameters,
                                 const <a href="../Geometry_and_Transformations/Transformations.html#Transform" class="code">Transform</a> &amp;renderFromLight,
                                 const <a href="../Cameras_and_Film/Camera_Interface.html#CameraTransform" class="code">CameraTransform</a> &amp;cameraTransform,
                                 <a href="../Volume_Scattering/Media.html#Medium" class="code">Medium</a> outsideMedium, const FileLoc *loc,
                                 Allocator alloc);
       static <a href="#Light" class="code">Light</a> CreateArea(const std::string &amp;name,
                                     const ParameterDictionary &amp;parameters,
                                     const <a href="../Geometry_and_Transformations/Transformations.html#Transform" class="code">Transform</a> &amp;renderFromLight,
                                     const <a href="../Volume_Scattering/Media.html#MediumInterface" class="code">MediumInterface</a> &amp;mediumInterface,
                                     const <a href="../Shapes/Basic_Shape_Interface.html#Shape" class="code">Shape</a> shape, <a href="../Textures_and_Materials/Texture_Interface_and_Basic_Textures.html#FloatTexture" class="code">FloatTexture</a> alpha, const FileLoc *loc,
                                     Allocator alloc);
       <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> Phi(<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> lambda) const;
       LightType Type() const;
       pstd::optional&lt;<a href="#LightLiSample" class="code">LightLiSample</a>&gt;
       SampleLi(<a href="#LightSampleContext" class="code">LightSampleContext</a> ctx, <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a> u, <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> lambda,
                bool allowIncompletePDF = false) const;
       Float PDF_Li(<a href="#LightSampleContext" class="code">LightSampleContext</a> ctx, <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> wi,
                    bool allowIncompletePDF = false) const;
       std::string ToString() const;
       <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> L(<a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a> p, <a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a> n, <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a> uv, <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> w,
                         const <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> &amp;lambda) const;
       <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> Le(const <a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> &amp;ray, const <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> &amp;lambda) const;
       void Preprocess(const <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> &amp;sceneBounds);
       pstd::optional&lt;<a href="../Light_Sources/Light_Sampling.html#LightBounds" class="code">LightBounds</a>&gt; Bounds() const;</div></div> 
};</div><p>


</p>
<p>This chapter will describe all 9 of the following types of light source.

</p>
<p></p>
<span class="anchor" id="fragment-LightSourceTypes-0"></span><div class="fragmentname">&lt;&lt;Light Source Types&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Light_Sources/Point_Lights.html#PointLight" class="code">PointLight</a>, <a href="../Light_Sources/Distant_Lights.html#DistantLight" class="code">DistantLight</a>, <a href="../Light_Sources/Point_Lights.html#ProjectionLight" class="code">ProjectionLight</a>, <a href="../Light_Sources/Point_Lights.html#GoniometricLight" class="code">GoniometricLight</a>, <a href="../Light_Sources/Point_Lights.html#SpotLight" class="code">SpotLight</a>,
<a href="../Light_Sources/Area_Lights.html#DiffuseAreaLight" class="code">DiffuseAreaLight</a>, <a href="../Light_Sources/Infinite_Area_Lights.html#UniformInfiniteLight" class="code">UniformInfiniteLight</a>, <a href="../Light_Sources/Infinite_Area_Lights.html#ImageInfiniteLight" class="code">ImageInfiniteLight</a>,
<a href="../Light_Sources/Infinite_Area_Lights.html#PortalImageInfiniteLight" class="code">PortalImageInfiniteLight</a></div><p>


</p>
<p>

</p>
<p>All lights must be able to return their total emitted power, <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.678ex" height="2.176ex" style="vertical-align: -0.338ex;" viewBox="0 -791.3 722.5 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">normal upper Phi</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-3A6" d="M665 341c0 -101 -111 -194 -266 -206v-56c0 -35 0 -48 95 -48h33v-31c-36 3 -129 3 -170 3s-133 0 -169 -3v31h33c95 0 95 14 95 48v56c-149 15 -260 104 -260 207c0 99 107 191 260 206v56c0 35 0 48 -95 48h-33v31c36 -3 129 -3 170 -3s133 0 169 3v-31h-33 c-95 0 -95 -14 -95 -48v-56c152 -12 266 -103 266 -207zM316 158v367c-150 -20 -160 -132 -160 -184c0 -62 18 -164 160 -183zM565 342c0 76 -28 168 -166 184v-369c151 18 166 125 166 185Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-3A6" x="0" y="0"></use>
</g>
</svg>.  Among
other things, this makes it possible to sample lights according to their
relative power in the forthcoming <a href="../Light_Sources/Light_Sampling.html#PowerLightSampler"><tt>PowerLightSampler</tt></a>.  Devoting more
samples to the lights that make the largest contribution
can significantly improve rendering efficiency.

</p>
<p></p>
<span class="anchor" id="fragment-LightInterface-0"></span><div class="fragmentname">&lt;&lt;Light Interface&gt;&gt;=&nbsp;<a href="#fragment-LightInterface-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode"><a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <span class="anchor" id="Light::Phi"></span>Phi(<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> lambda) const;</div><p>


</p>
<p>The <tt>Light</tt><span class="anchor" id="Light"></span> interface does not completely abstract
away all the differences among different types of light source.  While
doing so would be desirable in principle, in practice <tt>pbrt</tt>&rsquo;s integrators
sometimes need to handle different types of light source differently, both
for efficiency and for correctness.  We have already seen an example of
this issue in the <a href="../Introduction/pbrt_System_Overview.html#RandomWalkIntegrator"><tt>RandomWalkIntegrator</tt></a> in
Section&nbsp;<a href="../Introduction/pbrt_System_Overview.html#sec:random-walk-integrator">1.3.6</a>.  There, &ldquo;infinite&rdquo; lights
received special handling since they must be considered for rays that
escape the scene without hitting any geometry.

</p>
<p>

</p>
<p>Another example is that the Monte Carlo algorithms
that sample illumination from light sources need
to be aware of which lights are described by delta distributions, since
this affects some of their computations.  Lights therefore categorize themselves into
one of a few different types; the <tt>Type()</tt> method returns which one a
light is.

</p>
<p></p>
<span class="anchor" id="fragment-LightInterface-1"></span><div class="fragmentname">&lt;&lt;Light Interface&gt;&gt;+=&nbsp;<a href="#fragment-LightInterface-0"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-LightInterface-2"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">LightType <span class="anchor" id="Light::Type"></span>Type() const;</div><p>


</p>
<p>There are four different light categories:
</p>
<ul>
<li> <tt>DeltaPosition</tt>: lights that emit solely from a single point in
space. (&ldquo;Delta&rdquo; refers to the fact that such lights can be described by
Dirac delta distributions.)
<li> <tt>DeltaDirection</tt>: lights that emit radiance along a single
direction.
<li> <tt>Area</tt>: lights that emit radiance from the surface of a
geometric shape.
<li> <tt>Infinite</tt>: lights &ldquo;at infinity&rdquo; that do not have geometry
associated with them but provide radiance to rays that escape the scene.
</ul><p>


</p>
<p></p>
<span class="anchor" id="fragment-LightTypeDefinition-0"></span><div class="fragmentname">&lt;&lt;LightType Definition&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">enum class <span class="anchor" id="LightType"></span>LightType { <span class="anchor" id="LightType::DeltaPosition"></span>DeltaPosition, <span class="anchor" id="LightType::DeltaDirection"></span>DeltaDirection, <span class="anchor" id="LightType::Area"></span>Area, <span class="anchor" id="LightType::Infinite"></span>Infinite };</div><p>


</p>
<p>A helper function checks if a light is defined using a Dirac delta
distribution.

</p>
<p></p>
<span class="anchor" id="fragment-LightInlineFunctions-0"></span><div class="fragmentname">&lt;&lt;Light Inline Functions&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">bool <span class="anchor" id="IsDeltaLight"></span>IsDeltaLight(<a href="#LightType::DeltaDirection" class="code">LightType</a> type) {
    return (type == <a href="#LightType::DeltaDirection" class="code">LightType</a>::DeltaPosition ||
            type == <a href="#LightType::DeltaDirection" class="code">LightType</a>::DeltaDirection);
}</div><p>


</p>
<p>Being able to sample directions at a point where 
illumination may be incident is an important sampling operation for
rendering.  Consider a diffuse surface illuminated by a small spherical
area light source (Figure&nbsp;<a href="#fig:mc-small-sphere-light">12.1</a>): sampling
directions using the BSDF&rsquo;s sampling distribution is likely to be very
inefficient because the light is only visible within a small cone of
directions from the point.  A much better approach is to instead use a
sampling distribution that is based on the light source.  In this case, the
sampling routine should choose from among only those directions where the
sphere is potentially visible.

</p>
<p></p>
<span class="anchor" id="fig:mc-small-sphere-light"></span><div class="card outerfigure"><div class="card-body figure"><p>



</p>
<div class="figure-row">
<img src="pha12f01.png" style="max-width: 100%; height: auto;" width=1253 height=461>
</div>
<p>


</p>
<figcaption class="caption">Figure 12.1: <span class="legend"> An effective sampling
strategy for choosing an incident direction from a point for direct
lighting computations is to allow the light source to define a distribution
of directions with respect to solid angle at the point.  Here, a small
spherical light source is illuminating the point. The cone of directions
that the sphere subtends is a much better sampling distribution to use than
a uniform distribution over the hemisphere, for example.</span>
</figcaption><p>


</p>
</div></div><p>


</p>
<p>This important task is the responsibility of implementations of
the <tt>SampleLi()</tt> method. Its caller passes a <a href="#LightSampleContext"><tt>LightSampleContext</tt></a> that
provides information about a reference point in the scene, and the light
optionally returns a <a href="#LightLiSample"><tt>LightLiSample</tt></a> that encapsulates incident
radiance, information about where it is being emitted from, and the value
of the probability density function (PDF) for the sampled point.
If it is impossible for light to reach the reference point or if there is
no valid light sample associated with <tt>u</tt>, an invalid sample can be
returned.
Finally, <tt>allowIncompletePDF</tt> indicates whether the sampling routine
may skip generating samples for directions where the light&rsquo;s contribution is
small. This capability is used by integrators that apply MIS compensation
(Section&nbsp;<a href="../Monte_Carlo_Integration/Improving_Efficiency.html#sec:multiple-importance-sampling">2.2.3</a>).

</p>
<p></p>
<span class="anchor" id="fragment-LightInterface-2"></span><div class="fragmentname">&lt;&lt;Light Interface&gt;&gt;+=&nbsp;<a href="#fragment-LightInterface-1"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-LightInterface-3"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">pstd::optional&lt;<a href="#LightLiSample" class="code">LightLiSample</a>&gt;
<span class="anchor" id="Light::SampleLi"></span>SampleLi(<a href="#LightSampleContext" class="code">LightSampleContext</a> ctx, <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a> u, <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> lambda,
         bool allowIncompletePDF = false) const;</div><p>


</p>
<p>The <tt>LightSampleContext</tt> takes the usual role of encapsulating just as
much information about the point receiving illumination as the various
sampling routines need.

</p>
<p></p>
<span class="anchor" id="fragment-LightSampleContextDefinition-0"></span><div class="fragmentname">&lt;&lt;LightSampleContext Definition&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">class <span class="anchor" id="LightSampleContext"></span>LightSampleContext {
public:
    &lt;&lt;<span class="fragmentname"><a href="#fragment-LightSampleContextPublicMethods-0">LightSampleContext Public Methods</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1629" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-1629"><i></i></a><div id="fragbit-1629" class="collapse"><div class="fragmentcode">       <a href="#LightSampleContext" class="code">LightSampleContext</a>(const <a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction" class="code">SurfaceInteraction</a> &amp;si)
           : <a href="#LightSampleContext::pi" class="code">pi</a>(si.<a href="#LightSampleContext::pi" class="code">pi</a>), n(si.n), ns(si.shading.n) {}
       <a href="#LightSampleContext" class="code">LightSampleContext</a>(const <a href="../Geometry_and_Transformations/Interactions.html#Interaction" class="code">Interaction</a> &amp;intr) : <a href="#LightSampleContext::pi" class="code">pi</a>(intr.<a href="#LightSampleContext::pi" class="code">pi</a>) {}
       <a href="#LightSampleContext" class="code">LightSampleContext</a>(Point3fi <a href="#LightSampleContext::pi" class="code">pi</a>, <a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a> n, <a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a> ns)
           : <a href="#LightSampleContext::pi" class="code">pi</a>(<a href="#LightSampleContext::pi" class="code">pi</a>), n(n), ns(ns) {}
       <a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a> p() const { return <a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a>(<a href="#LightSampleContext::pi" class="code">pi</a>); }</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-LightSampleContextPublicMembers-0">LightSampleContext Public Members</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1630" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-1630"><i></i></a><div id="fragbit-1630" class="collapse"><div class="fragmentcode">       Point3fi pi;
       <a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a> n, ns;</div></div>
};</div><p>


</p>
<p>The context just stores a point in the scene, a surface normal, and
a shading normal.  The point is provided as a <tt>Point3fi</tt> that makes it
possible to include error bounds around the computed ray intersection
point.  Some of the following sampling routines will need this information
as part of their sampling process.  If the point is in a scattering medium
and not on a surface, the two normals are left at their default <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="7.365ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 3170.8 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">left-parenthesis 0 comma 0 comma 0 right-parenthesis</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-28" d="M332 -238c0 -5 -5 -10 -10 -10c-2 0 -4 1 -6 2c-110 83 -215 283 -215 454v84c0 171 105 371 215 454c2 1 4 2 6 2c5 0 10 -5 10 -10c0 -3 -2 -6 -4 -8c-104 -78 -173 -278 -173 -438v-84c0 -160 69 -360 173 -438c2 -2 4 -5 4 -8Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-30" d="M460 320c0 -79 -5 -157 -37 -226c-44 -95 -120 -116 -174 -116c-49 0 -122 20 -165 101c-41 76 -45 166 -45 241c0 80 5 158 37 227c41 93 114 119 174 119c42 0 124 -16 170 -112c35 -74 40 -154 40 -234zM377 332c0 63 0 139 -10 195c-19 99 -85 117 -118 117 c-25 0 -100 -9 -119 -128c-8 -54 -8 -120 -8 -184c0 -59 0 -151 11 -211c18 -96 77 -121 116 -121c45 0 102 30 117 125c11 64 11 132 11 207Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2C" d="M203 1c0 -117 -80 -194 -91 -194c-5 0 -10 4 -10 11c0 3 0 5 11 16c33 33 68 93 68 167c0 14 -2 15 -2 15s-2 -1 -5 -3c-10 -9 -23 -13 -35 -13c-33 0 -53 26 -53 53c0 28 20 53 53 53c39 0 64 -39 64 -105Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-29" d="M288 208c0 -171 -105 -371 -215 -454c-2 -1 -4 -2 -6 -2c-5 0 -10 5 -10 10c0 3 2 6 4 8c104 78 173 278 173 438v84c0 160 -69 360 -173 438c-2 2 -4 5 -4 8c0 5 5 10 10 10c2 0 4 -1 6 -2c110 -83 215 -283 215 -454v-84Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-28" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-30" x="389" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="890" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-30" x="1335" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="1835" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-30" x="2280" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-29" x="2781" y="0"></use>
</g>
</svg>
values.

</p>
<p>Note that the context does not include a time&mdash;<tt>pbrt</tt>&rsquo;s light sources do not
support animated transformations.  An exercise at the end of the chapter
discusses issues related to extending them to do so.  

</p>
<p></p>
<span class="anchor" id="fragment-LightSampleContextPublicMembers-0"></span><div class="fragmentname">&lt;&lt;LightSampleContext Public Members&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">Point3fi <span class="anchor" id="LightSampleContext::pi"></span>pi;
<a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a> <span class="anchor" id="LightSampleContext::n"></span>n, <span class="anchor" id="LightSampleContext::ns"></span>ns;</div><p>


</p>
<p>As with the other <tt>Context</tt> classes, a variety of constructors make it
easy to create a <tt>LightSampleContext</tt>.

</p>
<p></p>
<span class="anchor" id="fragment-LightSampleContextPublicMethods-0"></span><div class="fragmentname">&lt;&lt;LightSampleContext Public Methods&gt;&gt;=&nbsp;<a href="#fragment-LightSampleContextPublicMethods-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode"><a href="#LightSampleContext" class="code">LightSampleContext</a>(const <a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction" class="code">SurfaceInteraction</a> &amp;si)
    : pi(si.pi), n(si.n), ns(si.shading.n) {}
<a href="#LightSampleContext" class="code">LightSampleContext</a>(const <a href="../Geometry_and_Transformations/Interactions.html#Interaction" class="code">Interaction</a> &amp;intr) : pi(intr.pi) {}
<a href="#LightSampleContext" class="code">LightSampleContext</a>(Point3fi pi, <a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a> n, <a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a> ns)
    : pi(pi), n(n), ns(ns) {}</div><p>


</p>
<p>A convenience method provides the point as a regular <tt>Point3f</tt> for
the routines that would prefer to access it as such.

</p>
<p></p>
<span class="anchor" id="fragment-LightSampleContextPublicMethods-1"></span><div class="fragmentname">&lt;&lt;LightSampleContext Public Methods&gt;&gt;+=&nbsp;<a href="#fragment-LightSampleContextPublicMethods-0"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode"><a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a> <span class="anchor" id="LightSampleContext::p"></span>p() const { return <a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a>(<a href="#LightSampleContext::pi" class="code">pi</a>); }</div><p>


</p>
<p> </p>
<span class="anchor" id="fig:light-sample-l"></span><div class="card outerfigure"><div class="card-body figure"><p>



</p>
<div class="figure-row">
<img src="pha12f02.png" style="max-width: 100%; height: auto;" width=1154 height=437>
</div>
<p>


</p>
<figcaption class="caption">Figure 12.2: <span class="legend"> The <a href="#Light::SampleLi"><tt>Light::SampleLi()</tt></a> method
returns incident radiance from the light at a point and also returns
the direction vector <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.135ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 919.4 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">omega Subscript normal i</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D714" d="M604 372c0 -40 -12 -90 -23 -133c-30 -121 -93 -250 -197 -250c-67 0 -102 44 -113 106c-38 -62 -90 -106 -153 -106c-76 0 -105 62 -105 143c0 35 5 74 15 112c16 63 41 127 82 184c5 6 12 9 18 9c3 0 6 0 9 -2c5 -3 9 -8 9 -14c0 -4 -2 -9 -5 -13 c-38 -53 -74 -109 -89 -169c-5 -22 -8 -45 -8 -65c0 -63 26 -113 87 -113c55 0 103 39 136 93c1 29 5 59 13 90c5 22 15 47 34 47c14 0 19 -11 19 -26c0 -8 -2 -17 -4 -26c-7 -30 -17 -60 -30 -88c9 -52 42 -90 98 -90c79 0 137 92 160 183c3 12 4 25 4 37 c0 35 -13 66 -38 88c-7 7 -11 15 -11 25c0 11 5 22 14 32c10 10 23 16 35 16c9 0 17 -3 23 -9c15 -13 20 -35 20 -61Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-69" d="M247 0c-34 1 -69 3 -104 3l-110 -3v31c67 0 78 0 78 45v269c0 49 -9 55 -74 55v31l140 11v-367c0 -39 4 -44 70 -44v-31zM192 604c0 -25 -20 -53 -54 -53c-30 0 -53 26 -53 53c0 25 20 53 54 53c30 0 53 -26 53 -53Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D714" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-69" x="880" y="-213"></use>
</g>
</svg> that gives the direction from which radiance is
arriving.</span>
</figcaption><p>


</p>
</div></div><p>


</p>
<p>Light samples are bundled up into instances of the <tt>LightLiSample</tt>
structure.  The radiance <tt>L</tt> is the amount of radiance leaving the
light toward the receiving point; it does not include the effect of
extinction due to participating media or occlusion, if there is an object
between the light and the receiver.  <tt>wi</tt> gives the direction along
which light arrives at the point that was specified via the
<a href="#LightSampleContext"><tt>LightSampleContext</tt></a> (see Figure&nbsp;<a href="#fig:light-sample-l">12.2</a>) and the
point from which light is being emitted is provided by <tt>pLight</tt>.
Finally, the PDF value for the light sample is returned in <tt>pdf</tt>.
This PDF should be measured with respect to solid angle at the receiving
point.

</p>
<p></p>
<span class="anchor" id="fragment-LightLiSampleDefinition-0"></span><div class="fragmentname">&lt;&lt;LightLiSample Definition&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">struct <span class="anchor" id="LightLiSample"></span>LightLiSample {
    &lt;&lt;<span class="fragmentname">LightLiSample Public Methods</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1631" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-1631"><i></i></a><div id="fragbit-1631" class="collapse"><div class="fragmentcode">       <a href="#LightLiSample" class="code">LightLiSample</a>() = default;
       PBRT_CPU_GPU
       <a href="#LightLiSample" class="code">LightLiSample</a>(const <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> &amp;L, <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> wi, Float pdf, const <a href="../Geometry_and_Transformations/Interactions.html#Interaction" class="code">Interaction</a> &amp;pLight)
           : L(L), wi(wi), pdf(pdf), pLight(pLight) {}
       std::string ToString() const;</div></div>
    <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <span class="anchor" id="LightLiSample::L"></span>L;
    <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> <span class="anchor" id="LightLiSample::wi"></span>wi;
    Float <span class="anchor" id="LightLiSample::pdf"></span>pdf;
    <a href="../Geometry_and_Transformations/Interactions.html#Interaction" class="code">Interaction</a> <span class="anchor" id="LightLiSample::pLight"></span>pLight;
};</div><p>


</p>
<p>Just as we saw for perfect specular reflection and transmission with BSDFs, light
sources that are defined in terms of delta distributions fit naturally into
this sampling framework, although they require care on the part of the
routines that call their sampling methods, since there are implicit delta
distributions in the radiance and PDF values that they return.  For the
most part, these delta distributions naturally cancel out when estimators
are evaluated, although multiple importance sampling code must be aware of
this case, just as with BSDFs.  For samples taken from delta distribution
lights, the <tt>pdf</tt> value in the returned <a href="#LightLiSample"><tt>LightLiSample</tt></a> should
be set to&nbsp;1.

</p>
<p>

</p>
<p>Related to this, the <tt>PDF_Li()</tt> method returns the value of the PDF for
sampling the given direction <tt>wi</tt> from the point represented by
<tt>ctx</tt>.  This method is particularly useful in the context of multiple
importance sampling (MIS) where, for example, the BSDF may have sampled a
direction and we need to compute the PDF for the light&rsquo;s sampling that
direction in order to compute the MIS weight.  Implementations of this
method may assume that a ray from <tt>ctx</tt> in direction <tt>wi</tt> has
already been found to intersect the light source, and as with
<tt>SampleLi()</tt>, the PDF should be measured with respect to solid angle.
Here, the returned PDF value should be&nbsp;0 if the light is described by a
Dirac delta distribution.

</p>
<p></p>
<span class="anchor" id="fragment-LightInterface-3"></span><div class="fragmentname">&lt;&lt;Light Interface&gt;&gt;+=&nbsp;<a href="#fragment-LightInterface-2"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-LightInterface-4"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">Float <span class="anchor" id="Light::PDF_Li"></span>PDF_Li(<a href="#LightSampleContext" class="code">LightSampleContext</a> ctx, <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> wi,
             bool allowIncompletePDF = false) const;</div><p>


</p>
<p>

</p>
<p>If a ray happens to intersect an area light source, it is necessary to find
the radiance that is emitted back along the ray.  This task is handled by
the <tt>L()</tt> method, which takes local information about the intersection
point and the outgoing direction.  This method should never be called for
any light that does not have geometry associated with it.

</p>
<p></p>
<span class="anchor" id="fragment-LightInterface-4"></span><div class="fragmentname">&lt;&lt;Light Interface&gt;&gt;+=&nbsp;<a href="#fragment-LightInterface-3"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-LightInterface-5"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode"><a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <span class="anchor" id="Light::L"></span>L(<a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a> p, <a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a> n, <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a> uv, <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> w,
                  const <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> &amp;lambda) const;</div><p>


</p>
<p>Another interface method that only applies to some types of lights is
<tt>Le()</tt>.  It enables infinite area lights to contribute
radiance to rays that do not hit any geometry in the scene.  This method
should only be called for lights that report their type to be
<a href="#LightType::Infinite"><tt>LightType::Infinite</tt></a>.

</p>
<p></p>
<span class="anchor" id="fragment-LightInterface-5"></span><div class="fragmentname">&lt;&lt;Light Interface&gt;&gt;+=&nbsp;<a href="#fragment-LightInterface-4"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-LightInterface-6"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode"><a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <span class="anchor" id="Light::Le"></span>Le(const <a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> &amp;ray, const <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> &amp;lambda) const;</div><p>


</p>
<p>Finally, the <tt>Light</tt> interface includes a <tt>Preprocess()</tt> method that
is invoked prior to rendering. It takes the rendering space bounds of the
scene as an argument.  Some light sources need to know these bounds and
they are not available when lights are initially created, so this method
makes the bounds available to them.

</p>
<p></p>
<span class="anchor" id="fragment-LightInterface-6"></span><div class="fragmentname">&lt;&lt;Light Interface&gt;&gt;+=&nbsp;<a href="#fragment-LightInterface-5"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="Light_Sampling.html#fragment-LightInterface-7"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">void <span class="anchor" id="Light::Preprocess"></span>Preprocess(const <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> &amp;sceneBounds);</div><p>


</p>
<p>There are three additional light interface methods that will be defined
later, closer to the code that uses them.  <a href="../Light_Sources/Light_Sampling.html#Light::Bounds"><tt>Light::Bounds()</tt></a> provides
information that bounds the light&rsquo;s spatial and directional emission
distribution; one use of it is to build acceleration hierarchies for light
sampling, as is done in Section&nbsp;<a href="../Light_Sources/Light_Sampling.html#sec:bvh-light-sampling">12.6.3</a>.
<tt>Light::SampleLe()</tt> and <tt>Light::PDF_Le()</tt> are used to sample rays
leaving light sources according to their distribution of emission.  They
are cornerstones of bidirectional light transport algorithms and are
defined in

the online edition of the book along with algorithms that use them.



</p>
<p>

</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#PhotometricLightSpecification"><i class="fas fa-link h3h4marginlink"></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span id="PhotometricLightSpecification"></span><h3>12.1.1  Photometric Light Specification</h3><p>


</p>
<p><tt>pbrt</tt> uses radiometry as the basis of its model of light transport.
However, light sources are often described using photometric units&mdash;a
light bulb package might report that it emits 1,000 lumens of light, for
example.  Beyond their familiarity, one advantage of photometric
descriptions of light emission is that they also account for the variation
of human visual response with wavelength.  It is also more intuitive to
describe lights in terms of the visible power that they emit rather than
the power they consume in the process of doing so. (Related to this topic,
recall the discussion of luminous efficacy in Section&nbsp;<a href="../Radiometry,_Spectra,_and_Color/Light_Emission.html#sec:emission">4.4</a>.)

</p>
<p>Therefore, light sources in <tt>pbrt</tt>&rsquo;s scene description files can be
specified in terms of the luminous power that they emit.  These specifications
are then converted to radiometric quantities in the code that initializes
the scene representation.  Radiometric values are then passed to the
constructors of the <a href="#Light"><tt>Light</tt></a> implementations in this chapter, often in
the form of a base spectral distribution and a scale factor that is applied
to it.

</p>
<p>

</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#TheLightBaseClass"><i class="fas fa-link h3h4marginlink"></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span id="TheLightBaseClass"></span><h3>12.1.2  The LightBase Class</h3><p>


</p>
<p>As there was with classes like <a href="../Cameras_and_Film/Camera_Interface.html#CameraBase"><tt>CameraBase</tt></a> and <a href="../Cameras_and_Film/Film_and_Imaging.html#FilmBase"><tt>FilmBase</tt></a> for
<a href="../Cameras_and_Film/Camera_Interface.html#Camera"><tt>Camera</tt></a> and <a href="../Cameras_and_Film/Film_and_Imaging.html#Film"><tt>Film</tt></a> implementations, there is a <a href="#LightBase"><tt>LightBase</tt></a>
class that all of <tt>pbrt</tt>&rsquo;s light sources inherit from.  <tt>LightBase</tt> stores
a number of values that are common to all of <tt>pbrt</tt>&rsquo;s lights and is thus
able to implement some of the <a href="#Light"><tt>Light</tt></a> interface methods.  It is not
required that a <a href="#Light"><tt>Light</tt></a> in <tt>pbrt</tt> inherit from <a href="#LightBase"><tt>LightBase</tt></a>, but
lights must provide implementations of a few more <a href="#Light"><tt>Light</tt></a> methods if they
do not.

</p>
<p></p>
<span class="anchor" id="fragment-LightBaseDefinition-0"></span><div class="fragmentname">&lt;&lt;LightBase Definition&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">class <span class="anchor" id="LightBase"></span>LightBase {
  public:
    &lt;&lt;<span class="fragmentname"><a href="#fragment-LightBasePublicMethods-0">LightBase Public Methods</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1632" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-1632"><i></i></a><div id="fragbit-1632" class="collapse"><div class="fragmentcode">       LightBase(<a href="#LightType" class="code">LightType</a> <a href="#LightBase::type" class="code">type</a>, const <a href="../Geometry_and_Transformations/Transformations.html#Transform" class="code">Transform</a> &amp;renderFromLight,
                 const <a href="../Volume_Scattering/Media.html#MediumInterface" class="code">MediumInterface</a> &amp;mediumInterface);
       <a href="#LightType" class="code">LightType</a> Type() const { return <a href="#LightBase::type" class="code">type</a>; }
       <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> L(<a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a> p, <a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a> n, <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a> uv, <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> w,
                         const <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> &amp;lambda) const {
           return <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a>(0.f);
       }
       <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> Le(const <a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> &amp;, const <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> &amp;) const {
           return <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a>(0.f);
       }</div></div>
  protected:
    &lt;&lt;<span class="fragmentname">LightBase Protected Methods</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1633" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-1633"><i></i></a><div id="fragbit-1633" class="collapse"><div class="fragmentcode">       static const DenselySampledSpectrum *LookupSpectrum(<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#Spectrum" class="code">Spectrum</a> s);</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-LightBaseProtectedMembers-0">LightBase Protected Members</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1634" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-1634"><i></i></a><div id="fragbit-1634" class="collapse"><div class="fragmentcode">       <a href="#LightType" class="code">LightType</a> type;
       <a href="../Geometry_and_Transformations/Transformations.html#Transform" class="code">Transform</a> renderFromLight;
       <a href="../Volume_Scattering/Media.html#MediumInterface" class="code">MediumInterface</a> mediumInterface;
       static <a href="../Utilities/Containers_and_Memory_Management.html#InternCache" class="code">InternCache</a>&lt;<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#DenselySampledSpectrum" class="code">DenselySampledSpectrum</a>&gt; *spectrumCache;</div></div>
};</div><p>


</p>
<p>

</p>
<p>The following three values are passed to the <a href="#LightBase"><tt>LightBase</tt></a> constructor,
which stores them in these member variables:
</p>
<ul>
<li> <tt>type</tt> characterizes the light&rsquo;s type.

<li> <tt>renderFromLight</tt> is a transformation that defines the light&rsquo;s
coordinate system with respect to rendering space.  As with shapes, it is often
handy to be able to implement a light assuming a particular coordinate
system (e.g., that a spotlight is always located at the origin of its light
space, shining down the <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.894ex" height="2.176ex" style="vertical-align: -0.505ex;" viewBox="0 -719.6 1246 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">plus z</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-2B" d="M722 250c0 -11 -9 -20 -20 -20h-293v-293c0 -11 -9 -20 -20 -20s-20 9 -20 20v293h-293c-11 0 -20 9 -20 20s9 20 20 20h293v293c0 11 9 20 20 20s20 -9 20 -20v-293h293c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D467" d="M467 432c0 -4 -22 -52 -117 -145c-36 -36 -98 -90 -98 -90c-36 -31 -65 -56 -119 -114c9 3 27 3 27 3c21 0 36 -4 70 -17c21 -7 39 -13 59 -13c33 0 97 19 120 84c3 7 5 13 14 13c8 0 12 -5 12 -10c0 -27 -58 -154 -157 -154c-29 0 -47 16 -64 37c-25 29 -35 38 -58 38 c-32 0 -62 -27 -85 -62c-6 -11 -8 -13 -16 -13c0 0 -12 0 -12 10c0 7 35 64 103 131l90 84c19 16 103 88 139 131c-26 0 -37 0 -77 15c-23 8 -42 15 -63 15c-8 0 -66 -1 -85 -47c-2 -6 -4 -11 -13 -11s-12 6 -12 11c0 21 46 114 121 114c33 0 50 -20 69 -43 c15 -17 27 -32 51 -32s45 16 75 64c5 9 8 11 15 11c0 0 11 0 11 -10Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-2B" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D467" x="778" y="0"></use>
</g>
</svg> axis).  The rendering-from-light transformation
makes it possible to place such lights at arbitrary positions and
orientations in the scene.

<li> A <a href="../Volume_Scattering/Media.html#MediumInterface"><tt>MediumInterface</tt></a> describes the participating medium on the inside
and the outside of the light source.  For lights that do not have &ldquo;inside&rdquo;
and &ldquo;outside&rdquo; (e.g., a point light), the <a href="../Volume_Scattering/Media.html#MediumInterface"><tt>MediumInterface</tt></a> stores the
same <a href="../Volume_Scattering/Media.html#Medium"><tt>Medium</tt></a> on both sides.
</ul><p>


</p>
<p></p>
<span class="anchor" id="fragment-LightBaseProtectedMembers-0"></span><div class="fragmentname">&lt;&lt;LightBase Protected Members&gt;&gt;=&nbsp;<a href="#fragment-LightBaseProtectedMembers-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode"><a href="#LightType" class="code">LightType</a> <span class="anchor" id="LightBase::type"></span>type;
<a href="../Geometry_and_Transformations/Transformations.html#Transform" class="code">Transform</a> <span class="anchor" id="LightBase::renderFromLight"></span>renderFromLight;
<a href="../Volume_Scattering/Media.html#MediumInterface" class="code">MediumInterface</a> <span class="anchor" id="LightBase::mediumInterface"></span>mediumInterface;</div><p>


</p>
<p><tt>LightBase</tt> can thus take care of providing an implementation of the
<tt>Type()</tt> interface method.

</p>
<p></p>
<span class="anchor" id="fragment-LightBasePublicMethods-0"></span><div class="fragmentname">&lt;&lt;LightBase Public Methods&gt;&gt;=&nbsp;<a href="#fragment-LightBasePublicMethods-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode"><a href="#LightType" class="code">LightType</a> <span class="anchor" id="LightBase::Type"></span>Type() const { return <a href="#LightBase::type" class="code">type</a>; }</div><p>


</p>
<p>It also provides default implementations of <tt>L()</tt> and <tt>Le()</tt> so
that lights that are not respectively area or infinite lights do not need
to implement these themselves.

</p>
<p></p>
<span class="anchor" id="fragment-LightBasePublicMethods-1"></span><div class="fragmentname">&lt;&lt;LightBase Public Methods&gt;&gt;+=&nbsp;<a href="#fragment-LightBasePublicMethods-0"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-LightBasePublicMethods-2"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode"><a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <span class="anchor" id="LightBase::L"></span>L(<a href="../Geometry_and_Transformations/Points.html#Point3f" class="code">Point3f</a> p, <a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a> n, <a href="../Geometry_and_Transformations/Points.html#Point2f" class="code">Point2f</a> uv, <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> w,
                  const <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> &amp;lambda) const {
    return <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a>(0.f);
}</div><p>


</p>
<p></p>
<span class="anchor" id="fragment-LightBasePublicMethods-2"></span><div class="fragmentname">&lt;&lt;LightBase Public Methods&gt;&gt;+=&nbsp;<a href="#fragment-LightBasePublicMethods-1"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode"><a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a> <span class="anchor" id="LightBase::Le"></span>Le(const <a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> &amp;, const <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths" class="code">SampledWavelengths</a> &amp;) const {
    return <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledSpectrum" class="code">SampledSpectrum</a>(0.f);
}</div><p>


</p>
<p>Most of the following <tt>Light</tt> implementations take a <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#Spectrum"><tt>Spectrum</tt></a>
value in their constructor to specify the light&rsquo;s spectral emission but
then convert it to a <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#DenselySampledSpectrum"><tt>DenselySampledSpectrum</tt></a> to store in a member
variable.  By doing so, they enjoy the benefits of efficient sampling
operations from tabularizing the spectrum and a modest performance benefit
from not requiring dynamic dispatch to call <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#Spectrum"><tt>Spectrum</tt></a> methods.

</p>
<p>However, a <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#DenselySampledSpectrum"><tt>DenselySampledSpectrum</tt></a> that covers the visible wavelengths
uses approximately 2&nbsp;kB of storage; for scenes with millions of light
sources, the memory required may be significant.  Therefore,
<a href="#LightBase"><tt>LightBase</tt></a> provides a <tt>LookupSpectrum()</tt> method that helps reduce
memory use by eliminating redundant copies of the same
<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#DenselySampledSpectrum"><tt>DenselySampledSpectrum</tt></a>.  It uses the <a href="../Utilities/Containers_and_Memory_Management.html#InternCache"><tt>InternCache</tt></a> from
Section&nbsp;<a href="../Utilities/Containers_and_Memory_Management.html#sec:interned-objects">B.4.2</a> to do so, only allocating storage for a single instance
of each <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#DenselySampledSpectrum"><tt>DenselySampledSpectrum</tt></a> provided.  If many lights have the
same spectral emission profile, the memory savings may be significant.

</p>
<p>

</p>
<p></p>
<span class="anchor" id="fragment-LightBaseMethodDefinitions-0"></span><div class="fragmentname">&lt;&lt;LightBase Method Definitions&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">const DenselySampledSpectrum *<span class="anchor" id="LightBase::LookupSpectrum"></span>LightBase::LookupSpectrum(<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#Spectrum" class="code">Spectrum</a> s) {
    &lt;&lt;<span class="fragmentname">Initialize <tt>spectrumCache</tt> on first call</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1635" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-1635"><i></i></a><div id="fragbit-1635" class="collapse"><div class="fragmentcode">       static std::mutex mutex;
       mutex.lock();
       if (!spectrumCache)
           spectrumCache = new InternCache&lt;DenselySampledSpectrum&gt;(
       #ifdef PBRT_BUILD_GPU_RENDERER
                            Options-&gt;useGPU ? Allocator(&amp;CUDATrackedMemoryResource::singleton) :
       #endif
                            Allocator{});
       mutex.unlock();</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-ReturnuniquemonoDenselySampledSpectrumfrominterncacheformonos-0">Return unique <tt>DenselySampledSpectrum</tt> from intern cache for <tt>s</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1636" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-1636"><i></i></a><div id="fragbit-1636" class="collapse"><div class="fragmentcode">       auto create = [](Allocator alloc, const <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#DenselySampledSpectrum" class="code">DenselySampledSpectrum</a> &amp;s) {
           return alloc.<a href="../Introduction/Using_and_Understanding_the_Code.html#std::pmr::polymorphic_allocator::new_object" class="code">new_object</a>&lt;<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#DenselySampledSpectrum" class="code">DenselySampledSpectrum</a>&gt;(s, alloc);
       };
       return <a href="#LightBase::spectrumCache" class="code">spectrumCache</a>-&gt;<a href="../Utilities/Containers_and_Memory_Management.html#InternCache::Lookup" class="code">Lookup</a>(<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#DenselySampledSpectrum" class="code">DenselySampledSpectrum</a>(s), create);</div></div>
}</div><p>


</p>
<p>The &lt;&lt;<span class="fragmentname">Initialize <tt>spectrumCache</tt> on first call</span>&gt;&gt; fragment, not
included here, handles the details of initializing the
<tt>spectrumCache</tt>, including ensuring mutual exclusion if multiple
threads have called <tt>LookupSpectrum()</tt> concurrently and using an
appropriate memory allocator&mdash;notably, one that allocates memory on the
GPU if GPU rendering has been enabled. 

</p>
<p><tt>LookupSpectrum()</tt> then calls the <a href="../Utilities/Containers_and_Memory_Management.html#InternCache::Lookup"><tt>InternCache::Lookup()</tt></a> method
that takes a callback function to create the object that is stored in the
cache.  In this way, it is able to pass the provided allocator to the
<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#DenselySampledSpectrum"><tt>DenselySampledSpectrum</tt></a> constructor, which in turn ensures that it is
used to allocate the storage needed for its spectral samples.

</p>
<p></p>
<span class="anchor" id="fragment-ReturnuniquemonoDenselySampledSpectrumfrominterncacheformonos-0"></span><div class="fragmentname">&lt;&lt;Return unique <tt>DenselySampledSpectrum</tt> from intern cache for <tt>s</tt>&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">auto create = [](Allocator alloc, const <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#DenselySampledSpectrum" class="code">DenselySampledSpectrum</a> &amp;s) {
    return alloc.<a href="../Introduction/Using_and_Understanding_the_Code.html#std::pmr::polymorphic_allocator::new_object" class="code">new_object</a>&lt;<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#DenselySampledSpectrum" class="code">DenselySampledSpectrum</a>&gt;(s, alloc);
};
return <a href="#LightBase::spectrumCache" class="code">spectrumCache</a>-&gt;<a href="../Utilities/Containers_and_Memory_Management.html#InternCache::Lookup" class="code">Lookup</a>(<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#DenselySampledSpectrum" class="code">DenselySampledSpectrum</a>(s), create);</div><p>


</p>
<p></p>
<span class="anchor" id="fragment-LightBaseProtectedMembers-1"></span><div class="fragmentname">&lt;&lt;LightBase Protected Members&gt;&gt;+=&nbsp;<a href="#fragment-LightBaseProtectedMembers-0"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode">static <a href="../Utilities/Containers_and_Memory_Management.html#InternCache" class="code">InternCache</a>&lt;<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#DenselySampledSpectrum" class="code">DenselySampledSpectrum</a>&gt; *<span class="anchor" id="LightBase::spectrumCache"></span>spectrumCache;</div><p>


</p>
<p>

</p>
<p>

</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

</div>  <!-- container-fluid -->
</div>  <!-- maincontainer -->

<nav class="navbar navbar-expand-md bg-light navbar-light">
<div class="container-fluid">
  <span class="navbar-text"><i>Physically Based Rendering: From Theory To Implementation</i>,<br>
<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">&copy; 2004-2023</a> Matt Pharr, Wenzel Jakob, and Greg Humphreys.
<a href="https://github.com/mmp/pbr-book-website/"><span class="fab fa-github"></span></a><br>
Purchase a printed copy: <a href="https://www.amazon.com/Physically-Based-Rendering-fourth-Implementation/dp/0262048027?keywords=physically+based+rendering+4th+edition&qid=1671730412&sprefix=physically+based%!C(MISSING)aps%!C(MISSING)145&sr=8-1&linkCode=ll1&tag=pharr-20&linkId=81a816d90f0c7e872617f1f930a51fd6&language=en_US&ref_=as_li_ss_tl"><span class="fab fa-amazon"></span></a>
<a href="https://mitpress.mit.edu/9780262048026/physically-based-rendering/"><img src="/mitpress.png" width=10 height=16></a>
</span>
</div>
  <div class="container">
    <ul class="nav navbar-nav ml-auto">
      <li class="nav-item">Next: <a href="../Light_Sources/Point_Lights.html">Light Sources / Point Lights</a></li>
    </ul>
  </div>

</nav>

<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script>
  $(function () {
    $('[data-toggle="popover"]').popover()
    $('[data-toggle="tooltip"]').tooltip()
   })
</script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>

<script>
// https://stackoverflow.com/a/17535094
// The function actually applying the offset
function offsetAnchor() {
  if (location.hash.length !== 0) {
    window.scrollTo(window.scrollX, window.scrollY - window.innerHeight / 8);
  }
}

// Captures click events of all <a> elements with href starting with #
$(document).on('click', 'a[href^="#"]', function(event) {
  // Click events are captured before hashchanges. Timeout
  // causes offsetAnchor to be called after the page jump.
  window.setTimeout(function() {
    offsetAnchor();
  }, 500);
});

// Set the offset when entering page with hash present in the url
window.setTimeout(offsetAnchor, 1500);
</script>

</body>
</html>
